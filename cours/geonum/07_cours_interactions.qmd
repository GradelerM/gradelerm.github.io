---
title: "Interactions carte-interface"
format: html
---

## Objectifs de la session

-   Comprendre les Ã©vÃ¨nements du navigateurs

-   Utiliser les Ã©vÃ¨nements pour crÃ©er de lâ€™interaction entre HTML, CSS et JavaScript

-   Apprendre Ã  identifier les Ã©vÃ¨nements spÃ©cifiques Ã  OpenLayers

-   Utiliser les Ã©vÃ¨nements pour ajouter de lâ€™interaction entre la carte et le reste de la page

-   CrÃ©er un menu dâ€™affichage/masquage des couches

## Supports

[CoursÂ : Ajouter des interactions Ã  ma carte](./07_diapos_interactions.qmd){target="_blank"}

## TP â€“ GÃ©rer lâ€™affichage de mes couches et ajouter une table attributaire

::: callout-important
## Avant de commencer le TP

Ce TP suppose que vous avez dÃ©jÃ  ajoutÃ© les couches du jeu de donnÃ©es Land Matrix dans votre GeoServer et que vous pouvez les rÃ©cupÃ©rer dans votre application. Si ce nâ€™est pas le cas, veuillez vous rÃ©fÃ©rer aux Ã©tapes prÃ©cÃ©dentes, sinon vous allez Ãªtre un peu perdus.
:::

**Pour rÃ©fÃ©rence,** je vous mets ici le contenu de mon code au **dÃ©marrage** de ce TP. Ã‡a veut dire quâ€™il manque les Ã©lÃ©ments quâ€™on a ajoutÃ©s pendant le cours, alors repartez plutÃ´t du votreÂ !

**index.html**

``` html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="https://openlayers.org/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Transition Minerals</title>
  </head>
  <body>
    <div id="map"></div>
    <script type="module" src="./main.js"></script>
  </body>
</html>
```

**style.css**

``` css
@import "node_modules/ol/ol.css";

html, body {
  margin: 0;
  height: 100%;
}
#map {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 100%;
}
```

**main.js**

``` javascript
import './style.css';
import {Map, View} from 'ol';
import { ImageWMS } from 'ol/source';
import TileLayer from 'ol/layer/Tile';
import ImageLayer from 'ol/layer/Image';
import OSM from 'ol/source/OSM';

// WMS de mon GeoServer
const geoserverWms = 'http://localhost:8080/geoserver/land_matrix/wms'

// Layer: Fond de carte OSM
const layerOsm = new TileLayer({ source: new OSM() });

// Layer: deals by country
const layerDealsByCountry = new ImageLayer({
  source: new ImageWMS({
    url: geoserverWms,
    params: { 'LAYERS' : 'land_matrix:deals_by_country' },
    serverType: 'geoserver',
  })
});

// Layer: deals
const sourceDeals = new ImageWMS({
  url: geoserverWms,
  params: { 'LAYERS' : 'land_matrix:deals' },
  serverType: 'geoserver',
});

const layerDeals = new ImageLayer({
  source: sourceDeals
});

// Map
const map = new Map({
  target: 'map',
  layers: [ layerOsm, layerDealsByCountry, layerDeals ],
  view: new View({
    center: [0, 0],
    zoom: 2
  })
});
```

### CrÃ©er un menu dâ€™affichage de couches

On souhaite maintenant crÃ©er un menu avec des cases de type "checkbox" qui vont nous permettre de choisir si on veut afficher ou masquer une couche. On doit commencer par crÃ©er cet Ã©lÃ©ment dans lâ€™interface en modifiant `index.html`.

-   DÃ©finissez une `<div>` dans laquelle on souhaite afficher notre menu de couches et positionnez-la avec du CSS

-   Ajoutez Ã  lâ€™intÃ©rieur un input de type checkbox avec la balise `<input type="checkbox"/>` et donnez lui un label avec le nom de la couche

Comme câ€™est la premiÃ¨re fois quâ€™on doit Ã©crire du HTML ensemble, je vous guide pas Ã  pas. Commencez par ouvrir `index.html` et ajouter sous la `div` de votre carte (la div `map`) une autre div, comme ceciÂ :

``` html
<div id="layers" class="menu"></div>
```

On crÃ©e une nouvelle `div` dont lâ€™identifiant est `layers`, ce qui nous permettra de la retrouver par la suite. On lui a aussi ajoutÃ© une classe quâ€™on appelle `menu` et qui nous permettra dâ€™appliquer un seul style Ã  tous nos Ã©lÃ©ments de menu. Si câ€™est un peu flou maintenant, vous comprendrez plus tard en ajoutant dâ€™autres menus.

Comme notre `div` est vide, on ne la voit pas. Ã‡a va Ãªtre difficile de la positionner ailleurs sur la carte. Jâ€™ai lâ€™habitude de mettre un peu nâ€™importe quoi Ã  lâ€™intÃ©rieur, juste le temps de rÃ©gler mon CSS correctement. Ma div ressemble donc Ã Â :

``` html
<div id="layers" class="menu">cthulhu fhtagn</div>
```

On pourra retirer le texte aprÃ¨s. Vous remarquerez quâ€™on ne voit (probablement) toujours pas notre texte. Essayez de rafraÃ®chir la page - sauf si vous avez dÃ©jÃ  modifiÃ© votre CSS, vous devriez le voir tout en haut Ã  gauche de lâ€™Ã©cran avant que la carte ne le recouvreÂ ! Câ€™est normal, nous nâ€™avons pas "positionnÃ©" notre Ã©lÃ©ment. Ce nâ€™est pas un cours de CSS donc on ne rentrera pas dans les dÃ©tails. Ouvrez `styles.css` et ajoutez le code suivantÂ :

``` css
.menu {
  position: absolute;
}
```

On sÃ©lectionne toutes les balises HTML avec la classe `menu` et on leur applique un positionnement absolu. Sauvegardez et vous devriez voir apparaÃ®tre le texte. SuperÂ ! Maisâ€¦ câ€™est moche et Ã§a ne ressemble pas DU TOUT Ã  un menu. Pas de souci, on y arrive. Ajoutez les Ã©lÃ©ments suivants (jâ€™ai commentÃ© le code pour vous aider Ã  comprendre)Â :

``` css
.menu {
  /* Positionnement dans le body */
  position: absolute;
  top: 20px;
  right: 20px;

  /* Padding */
  padding: 8px;

  /* Dimensions minimales */
  min-height: 80px;
  min-width: 160px;

  /* Rectangle blanc avec coins arrondis */
  background-color: white;
  border-radius: 8px;
}
```

Ah, câ€™est dÃ©jÃ  plus sympaÂ ! On va mÃªme pouvoir supprimer le texte de notre balise HTML dans `index.html`. En gros, voilÃ  ce que je fais avec ce code CSSÂ :

-   Jâ€™indique que lâ€™Ã©lÃ©ment a une position absolue dans le body (donc pas relative Ã  un Ã©lÃ©ment) et quâ€™il doit se trouver Ã  20 pixels du haut (`top`) et 20 pixels de la droite (`right`) de lâ€™Ã©cran.

-   Je donne un *padding*, une marge intÃ©rieure, Ã  mon Ã©lÃ©ment de menu. Pour mieux comprendre, essayez de supprimer/commenter cette ligne et regardez ce qui change.

-   Je donne une hauteur et une largeur minimales Ã  mon Ã©lÃ©ment pour Ã©viter quâ€™il ne disparaÃ®sse quand il est vide. Par dÃ©faut, mon Ã©lÃ©ment aurait grandi et rÃ©trÃ©ci avec son contenu.

-   Jâ€™ai donnÃ© un peu de style Ã  mon menu en lui donnant un fond blanc et des coins arrondis.

VoilÃ  globalement le niveau maximum de difficultÃ© du CSS que je vais vous demander pour styliser votre application, mais vous pouvez Ã©videmment allez plus loinÂ !

Maintenant quâ€™on a un menu, il va falloir ajouter la checkbox qui permettra dâ€™afficher ou masquer ma couche. Retournez dans `index.html` et ajoutez la balise `<input>` et son `<label>` dans notre `<div id="layers>`, comme ceciÂ :

``` html
<div id="layers" class="menu">
  <input type="checkbox" id="checkbox-countries" name="checkbox-countries" checked />
  <label for="checkbox-countries">Deals by countries</label>
</div>
```

VÃ©rifiez que vous pouvez cliquer sur la checkbox pour la cocher/dÃ©cocher. Lâ€™interface est prÃªteÂ ! Il faut maintenant quâ€™on parvienne Ã  dire Ã  notre application quâ€™il faut afficher ou masquer la couche deals_by_country en fonction.

::: callout-important
## Attention Ã  bien diffÃ©rencier ajouter/retirer une couche et modifier sa visibilitÃ©

Dans les diapos, on a vu que `addLayer()` et `removeLayer()` permettent dâ€™ajouter/retirer une couche de la carte. Câ€™est pratique dans plein de cas, mais pas vraiment dans celui dâ€™un menu dâ€™affichage. En effet, quand on rajoute, une couche, elle viendra forcÃ©ment se placer par-dessus les autres.

Pour conserver lâ€™ordre de nos couches (dÃ©fini par lâ€™ordre dans lequel on les a ajoutÃ©es Ã  la carte), on va plutÃ´t les rendre visibles ou les masquer.
:::

![](https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExODJjeW4zc3hidHd4aDUwOTBrcnFxNGVpdXJiM2RqdG1udTlwMXZ6eCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/5pl3EHRYqMHwQ/giphy.gif){fig-alt="GIFÂ : Cape dâ€™invisibilitÃ©" fig-align="center"}

ğŸ¤” **On doit dâ€™abord se demander comment sâ€™y prendre pour masquer une couche dans OpenLayers.**

On va se servir des mÃ©thodes qui sont disponibles pour tous les objets `Layer` de OpenLayers. La [documentation](https://openlayers.org/en/latest/apidoc/module-ol_layer_Base-BaseLayer.html#setVisible) nous apprend lâ€™existence de la mÃ©thode `setVisible()`. VoilÃ  ce quâ€™on nous en ditÂ :

![](media/set_visible_ol.png){fig-alt="Documentation de la mÃ©thode setVisible() OpenLayers" fig-align="center"}

La mÃ©thode `setVisible()` prend un argument `visible`. Cet argument est de type "boolean", il peut donc prendre la valeur `true` ou `false`. On va faire le test et utiliser cette fonction pour faire disparaÃ®tre notre couche. Allez dans `main.js` et ajouter cette ligne Ã  la fin de votre script.

**AttentionÂ !** `layerDealsByCountry` est le nom de la variable dans laquelle jâ€™ai crÃ©Ã© ma couche "deals_by_country". Si vous avez nommÃ© votre couche diffÃ©remment, nâ€™oubliez pas de changer le nomÂ !

``` javascript
layerDealsByCountry.setVisible(false);
```

Normalement, la couche ne devrait plus Ãªtre visible sur la carte. Super, la mÃ©thode a fonctionnÃ©Â ! Il ne nous reste plus quâ€™Ã  "connecter" cette mÃ©thode Ã  notre Ã©lÃ©ment checkbox.

On a dÃ©jÃ  vu quâ€™il est possible de trouver un Ã©lÃ©ment HTML et de le modifier en utilisant du JavaScript. Pour trouver un Ã©lÃ©ment, le plus facile est de rechercher son identifiant `id`. Ajoutez en bas de `main.js`Â :

``` javascript
const checkboxCountries = document.getElementById('checkbox-countries');
console.log(checkboxCountries);
```

Sauvegardez et allez dans la console de votre navigateur. Vous devriez voir apparaÃ®tre votre tag `<input>` dans la console. Si vous le survolez avec la souris, la checkbox devrait Ãªtre passÃ©e en surbrillance. Si Ã§a fonctionne, parfait ! Ã‡a veut dire quâ€™on arrive bien Ã  rÃ©cupÃ©rer notre Ã©lÃ©ment de checkbox. Maintenant, on souhaite exÃ©cuter du code lorsque son statut "checked" change. Pour cela, on doit "Ã©couter" la checkbox pour savoir si lâ€™Ã©vÃ¨nement "change" a eu lieu.

``` javascript
const checkboxCountries = document.getElementById('checkbox-countries');

checkboxCountries.addEventListener('change', (event) => {
  if (event.currentTarget.checked) {
    // On fait des trucs quand la checkbox est checkÃ©e
    console.log("Checked");
  } else {
    // On fait des trucs quand la checkbox nâ€™est PAS checkÃ©e
    console.log("Pas checked");
  }
});
```

-   `addEventListener` indique quâ€™on souhaite "Ã©couter" les Ã©vÃ¨nements de notre checkbox. On prÃ©cise le type dâ€™Ã©vÃ¨nement avec le premier paramÃ¨tre, `'change'`.

-   La condition `if` vÃ©rifie si notre checkbox est checkÃ©e ou non. On rÃ©cupÃ¨re cette information grÃ¢ce Ã  `event.current.checked`. Si cette condition est `true`, on affiche "Checked" dans la console. Si cette condition est `false`, on affiche "Pas checked".

EssayezÂ ! Cliquez sur la checkbox et surveillez votre console. On voit bien sâ€™afficher les messages. On y est presqueÂ ! Maintenant, au lieu dâ€™afficher du texte, on souhaite afficher la couche quand la condition est `true` et la masquer quand la condition est `false`.

``` javascript
const checkboxCountries = document.getElementById('checkbox-countries');

checkboxCountries.addEventListener('change', (event) => {
  if (event.currentTarget.checked) {
    // On fait des trucs quand la checkbox est checkÃ©e
    layer_deals_by_country.setVisible(true);
  } else {
    // On fait des trucs quand la checkbox nâ€™est PAS checkÃ©e
    layer_deals_by_country.setVisible(false);
  }
});
```

::: callout-caution
## Pensez bien Ã â€¦

-   Changer le nom de la couche `layerDealsByCountry` si vous nâ€™avez pas appelÃ© votre couche comme Ã§a.

-   Supprimer la ligne `layerDealsByCountry.setVisible(false);` toute seule au dessus ou votre couche sera masquÃ©e par dÃ©faut au moment de charger la carte.
:::

VoilÃ , on peut dÃ©sormais afficher et masquer la couche Ã  volontÃ©Â !

![](https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExNWd3eWhzaGFoNWhyNmllaXhrNGh3bDBybGI4NDRscDBnbWtydDdiZCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/8Ry7iAVwKBQpG/giphy.gif){fig-alt="GIF : Adventure TimeÂ : Jake arc en ciel" fig-align="center" width="435"}

Ã€ vousÂ ! CrÃ©ez une autre checkbox qui permet dâ€™afficher ou masquer la couche deals. Jâ€™aimerais que cette checkbox soit **au-dessus** de la premiÃ¨reÂ !

::: callout-tip
Sauf indication contraire (via du CSS), les Ã©lÃ©ments HTML sont affichÃ©s dans lâ€™ordre dans lequel ils sont dÃ©clarÃ©s.

``` html
<div id="2"></div>
<div id="1"></div>
```

Dans cet exemple, ma div 1 sera plus bas que ma div 2. Ã‡a devrait vous aider !
:::

### Interroger une couche WMS et afficher les rÃ©sultats

On souhaite maintenant interroger la couche deals en cliquant dessus. Cette Ã©tape est plus compliquÃ©e que la prÃ©cÃ©dente car elle va nous demander dâ€™utiliser `fetch()`. Normalement vous lâ€™avez dÃ©jÃ  abordÃ© dans un autre cours, mais on va procÃ©der petit Ã  petit pour bien comprendre ce quâ€™on fait. Ouvrez lâ€™exemple OpenLayers [WMS GetFeatureInfo (Image Layer)](https://openlayers.org/en/latest/examples/getfeatureinfo-image.html).

CommenÃ§ons par sâ€™intÃ©resser Ã  cette partie du codeÂ :

``` javascript
map.on('singleclick', function (evt) {
  document.getElementById('info').innerHTML = '';
  const viewResolution = /** @type {number} */ (view.getResolution());
  const url = wmsSource.getFeatureInfoUrl(
    evt.coordinate,
    viewResolution,
    'EPSG:3857',
    {'INFO_FORMAT': 'text/html'},
  );
  if (url) {
    fetch(url)
      .then((response) => response.text())
      .then((html) => {
        document.getElementById('info').innerHTML = html;
      });
  }
});
```

-   `.on('singleclick')` permet dâ€™exÃ©cuter une fonction lorsquâ€™on clique sur la carte.

-   `document.getElementById()` rÃ©cupÃ¨re lâ€™Ã©lÃ©ment 'info' dans lequel ils affichent leurs rÃ©sultats.

-   On rÃ©cupÃ¨re la rÃ©solution de la vue de la carte grÃ¢ce Ã  la mÃ©thode dans `viewResolution`. On a besoin de passer cette rÃ©solution dans la fonction suivante.

-   On rÃ©cupÃ¨re lâ€™url qui contient les informations de lâ€™Ã©lÃ©ment cliquÃ© avec la mÃ©thode `getFeatureInfoUrl()` de la source de donnÃ©es.

-   Si notre url est dÃ©finie, alors on utilise la fonction `fetch()` pour rÃ©cupÃ©rer la donnÃ©e Ã  partir de cette adresse.

-   `document.getElementById()` rÃ©cupÃ¨re Ã  nouveau lâ€™Ã©lÃ©ment 'info' et dÃ©finir la valeur de son `innerHTML` pour pouvoir afficher les rÃ©sultats.

CompliquÃ©Â ? Non, Ã§a va allerÂ ! On va tranquillement rÃ©Ã©crire cette fonction pour la couche `deals`. Pour rappel, voici comment jâ€™appelle la couche `deals` dans mon codeÂ :

``` javascript
const sourceDeals = new ImageWMS({
  url: geoserverWms,
  params: { 'LAYERS' : 'land_matrix:deals' },
  serverType: 'geoserver',
});

const layerDeals = new ImageLayer({
  source: sourceDeals
});
```

Je commence donc par exÃ©cuter une fonction lorsque je clique sur la carteÂ :

``` javascript
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");
});
```

Sauvegardez, gardez la console de votre navigateur ouverte et cliquez sur la carte pour vÃ©rifier que le message apparaÃ®t bien. Si câ€™est bon, on vient dâ€™apprendre comment exÃ©cuter des fonctions en cliquant sur la carteÂ ! On sait ensuite que dans lâ€™exemple ils utilisent la mÃ©thode `getFeatureInfoUrl()` de leur source de donnÃ©es pour rÃ©cupÃ©rer les informations des features. Ouvrez la [documentation de ImageWMS](https://openlayers.org/en/latest/apidoc/module-ol_source_ImageWMS-ImageWMS.html#getFeatureInfoUrl), on va en avoir besoin. VoilÃ  ce quâ€™elle nous dit au sujet de la mÃ©thode `getFeatureInfoUrl()`Â :

![](media/get_feature_info_url_ol.png){fig-alt="Documentation getFeatureInfoUrl() dâ€™OpenLayers" fig-align="center"}

La mÃ©thode prend plusieurs paramÃ¨tresÂ :

-   `coordinate`, les coordonnÃ©es visÃ©es par le clic de lâ€™utilisateur (on les a appelÃ©es dans lâ€™exemple du cours)

-   `resolution`, la rÃ©solution de la carte (liÃ©e Ã  la `view` de ma carte)

-   `projection`, le systÃ¨me de projection de la carteÂ : "EPSG:3857'"

-   `params`, un objet contenant plusieurs paramÃ¨tres comme le format dÃ©sirÃ© du rÃ©sultat ou encore les couches quâ€™on souhaite interroger

RÃ©cupÃ©rons ces Ã©lÃ©ments dans lâ€™ordre en commenÃ§ant par les coordonnÃ©es. Dans lâ€™exemple, ils rÃ©fÃ©rencent directement la source de coordonnÃ©es `evt.coordinate` dans la fonctionâ€¦ mais Ã§a va un peu vite. Pour mieux comprendre, on va stocker les coordonnÃ©es de notre Ã©vÃ¨nement (= notre clic) dans une constante.

``` javascript
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");
  
  const coord = event.coordinate;
});
```

En fait, lâ€™Ã©vÃ¨nement 'singleclick' de la carte `map` permet de rÃ©cupÃ©rer les coordonnÃ©es du clic en accÃ©dant Ã  sa propriÃ©tÃ© `coordinate`. On Ã©crit donc `event.coordinate`.

::: {.callout-note collapse="true"}
## Pourquoi on a "event" et pas "evt"Â ?

Jâ€™ai fait exprÃ¨s de changer le nom du paramÃ¨tre pour appeler tous les Ã©vÃ¨nements "event" dans notre code et pour ajouter cette petite note. En fait, quand on crÃ©e une fonction, on peut nommer notre paramÃ¨tre comme on veut. Par exemple, dans le code suivantÂ :

``` javascript
map.on('singleclick', (event) => {
  const coord = event.coordinate;
});
```

â€¦ la variable `coordinates` a la mÃªme valeur que si jâ€™Ã©crisÂ :

``` javascript
map.on('singleclick', (evt) => {
  const coord = evt.coordinate;
});
```

â€¦ ou encoreÂ :

``` javascript
map.on('singleclick', (monEvenementQuiVientDeMaCarteQuandJeClique) => {
  const coord = monEvenementQuiVientDeMaCarteQuandJeClique.coordinate;
});
```

Bien sÃ»r, si vous ne vous sentez pas encore trop en confiance, inutile de renommer ce genre dâ€™Ã©lÃ©ments pour uniformiser le code. Vous pouvez garder ce que vous voyez dans le code OpenLayers.
:::

AprÃ¨s les coordonnÃ©es, on rÃ©cupÃ¨re la rÃ©solution. On sait quâ€™on lit la rÃ©solution depuis la vue de la carte, donc on peut dâ€™abord rÃ©cupÃ©rer cette vue PUIS lire sa rÃ©solution (toujours dans notre fonction, pas Ã  lâ€™extÃ©rieurÂ !)Â :

``` javascript
const view = map.getView();
const res = view.getResolution();
```

On peut aussi enchaÃ®ner les mÃ©thodes comme ceciÂ :

``` javascript
const res = map.getView().getResolution();
```

::: {.callout-note collapse="true"}
## Pourquoi on ne reprend pas le /\*\* \@type \*/ du code originalÂ ?

Parce quâ€™on nâ€™en est pas Ã  faire du TypeScriptÂ ! Ils ont fait un excÃ¨s de zÃ¨le dans cet exemple. Cette syntaxe Ã©trange signifie que le type de la constante est de type "number", donc un nombre. Câ€™est une info quâ€™on retrouve aussi dans la documentation.
:::

On est Ã  mi-chemin et le reste est trÃ¨s simple. La projection doit Ãªtre indiquÃ©e par une chaÃ®ne de caractÃ¨resÂ :

``` javascript
const proj = 'EPSG:3857';
```

Et on reprend les paramÃ¨tres de lâ€™exemple pour indiquer quâ€™on veut rÃ©cupÃ©rer notre rÃ©ponse au format HTML. Par dÃ©faut, GeoServer renverra la table attributaire de lâ€™Ã©lÃ©ment sous forme dâ€™un tableau en HTML.

``` javascript
const parametres = {'INFO_FORMAT': 'text/html'};
```

On a tous nos Ã©lÃ©ments, il ne nous reste quâ€™Ã  appeler la mÃ©thode `getFeatureInfoUrl()` sur notre **source** de donnÃ©es (attention, pas la coucheÂ !) pour gÃ©nÃ©rer lâ€™url qui nous permettra de rÃ©cupÃ©rer la rÃ©ponse. La documentation nous indique que les paramÃ¨tres doivent Ãªtre renseignÃ©s dans lâ€™ordre suivantÂ :

-   coordinate

-   resolution

-   projection

-   params

``` javascript
const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);
```

Ou encore, pour ressembler Ã  lâ€™exempleÂ :

``` javascript
const url = sourceDeals.getFeatureInfoUrl(
  coord,
  res,
  proj,
  parametres
);
```

Pour rÃ©capituler, voilÃ  Ã  quoi ressemble ma fonction pour le moment. Jâ€™ai ajoutÃ© un `console.log()` pour voir lâ€™url sâ€™afficher dans ma console et donc bien vÃ©rifier que jâ€™arrive Ã  gÃ©nÃ©rer cette adresse.

``` javascript
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");

  const coord = event.coordinate;
  const res = map.getView().getResolution();
  const proj = 'EPSG:3857';
  const parametres = {'INFO_FORMAT': 'text/html'};

  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);

  console.log(url);
});
```

Attention, voilÃ  la partie plus compliquÃ©eÂ : maintenant quâ€™on a une addresse, on doit utilier la fonction `fetch()` pour rÃ©cupÃ©rer la donnÃ©e. Câ€™est une fonction bien particuliÃ¨re. Elle est dite "asynchrone" car elle ne bloque pas le reste du code lorsquâ€™elle tourne, contrairement aux autres fonctions "synchrones". Si jâ€™Ã©cris une fonction `reboursSynchrone()`, lâ€™exÃ©cution de mon code et donc mon application est bloquÃ©e pendant que la fonction de mon compte Ã  rebours sâ€™exÃ©cute. Si câ€™est quasiment instantanÃ©, Ã§a ne pose pas de problÃ¨me. Si câ€™est quelque chose de plus lent, par exemple un compte Ã  rebours de dix secondes ou bien **attendre la rÃ©ponse dâ€™un serveur** dans le cas de notre fetch, notre application est bloquÃ©e et on est bien embÃªtÃ©s. Au contraire, si jâ€™Ã©cris une fonction `reboursAsynchrone()` **lâ€™application nâ€™attendra pas** que la fonction ait terminÃ© son compte Ã  rebours pour pouvoir continuer de faire des trucs.

Du coup, lâ€™asynchrone, câ€™est trÃ¨s pratiqueÂ ! Par contre, comme câ€™est particulier et quâ€™il est plus difficile de prÃ©voir quand elle va terminer son exÃ©cution et si elle va rencontrer des erreurs ou non, on va devoir lui rÃ©server un traitement particulier. Reprenons le code de lâ€™exemple pour lâ€™expliquer petit Ã  petit.

``` javascript
fetch(url)
  .then((response) => response.text())
  .then((html) => {
    // Jâ€™ai modifiÃ© la ligne suivante pour simplifier, on sâ€™intÃ©ressera Ã  elle un peu plus tard
    console.log("Câ€™est une rÃ©ussiteÂ !");
  });
```

Vous noterez lâ€™utilisation de mÃ©thodes `.then()` qui contiennent des fonctions. Ce sont les fonctions Ã  exÃ©cuter quand le maillon prÃ©cÃ©dent de la chaÃ®ne a fini de se rÃ©soudre. Si on devait Ã©crire en langage courant ce que signifie ce code, voilÃ  ce que Ã§a donneraitÂ :

-   `fetch(url)` â†’ "RÃ©cupÃ¨re les informations qui sont disponibles Ã  cette adresse"

-   `.then((response) => response.text())` â†’ "Ensuite ("*then*"), quand tu as **rÃ©ussi** Ã  rÃ©cupÃ©rer la rÃ©ponse, stocke-la dans une variable que jâ€™appelle "response" puis utilise sa mÃ©thode `.text()` pour rÃ©cupÃ©rer du texte au format HTML"

-   `.then((html) => { console.log("Câ€™est une rÃ©ussiteÂ !"); })` â†’ "Ensuite, quand tu as **rÃ©ussi** lâ€™Ã©tape prÃ©cÃ©dente, stocke le texte au format HTML de lâ€™Ã©tape prÃ©cÃ©dente dans une variable que jâ€™appelle "html" et affiche un message dans ma console"

Vous noterez que jâ€™ai prÃ©cisÃ© que `.then()` sâ€™exÃ©cute si lâ€™Ã©tape prÃ©cÃ©dente a rÃ©ussi. Si ce nâ€™est pas le cas, lâ€™exÃ©cution de notre chaÃ®ne de mÃ©thodes `fetch()` sâ€™arrÃªte et un message dâ€™erreur sâ€™affiche dans la console. Comme on a plutÃ´t confiance en notre GeoServer, on peut se lancer et exÃ©cuter ce `fetch()` mais attention, seulement si on a bien une addresse Ã  interrogerÂ ! Si la variable `url` est `undefined`, notre application risque de pÃ©ter les plombs. On ajoute une condition autour du `fetch()` pour Ã©viter les erreursÂ :

``` javascript
if (url) {
  fetch(url)
    .then((response) => response.text())
    .then((html) => {
      console.log("Câ€™est une rÃ©ussiteÂ !");
      console.log(html);
    });
}
```

Vous pouvez tester les `console.log()`. Le HTML quâ€™on obtient nâ€™est pas trÃ¨s gracieux tel quel, il vaudrait mieux lâ€™afficher dans lâ€™interface de lâ€™applicationÂ !

::: {.callout-note collapse="true"}
## Au secours, je nâ€™ai toujours pas compris fetch()

![](https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExYm5odGpnZTVnY3V4ZGZyNHQ2aDhqZjFqMGVlNnhpZXZ5Yjgxa3gxaiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/9iBIdXITr6LoVf8XgY/giphy.webp){fig-alt="GIF : Kermit qui nâ€™en peut plus" fig-align="center"}

Si votre cerveau est un peu comme Ã§a quand on parle de `fetch()`, nâ€™hÃ©sitez pas Ã  mâ€™appeler pour avoir une nouvelle explication. Jâ€™ai peur de ne pas pouvoir faire mieux par Ã©crit. La notion de fonction asynchrone est complexe et jâ€™ai mis pas mal de temps Ã  la comprendre, donc en deux minutes en plein milieu dâ€™un TP câ€™est encore pire.

Sinon, vous pouvez continuer le TP, on aura dâ€™autres occasions dâ€™utiliser `fetch()`. Peut-Ãªtre que les autres exemples seront plus clairsÂ !
:::

Quand on doit afficher un nouvel Ã©lÃ©ment dans lâ€™interface, il faut toujours penser Ã  crÃ©er une nouvelle balise HTML (souvent une `<div>`) pour le mettre Ã  lâ€™intÃ©rieur. Comme pour lâ€™exemple prÃ©cÃ©dent, on crÃ©e une div dans le HTML. Je place la mienne aprÃ¨s `<div id="layers">` et je remets nâ€™importe quoi dedans juste pour la voir dans mon interface.

``` html
<div id="attributes" class="menu">cthulhu ftaghn</div>
```

Sauvegardez et regardez lâ€™application. Et lÃ , horreurÂ ! Notre menu de couches est remplacÃ© par la nouvelle div quâ€™on vient de crÃ©erÂ ! Câ€™est normal, elles ont le mÃªme style car on a aussi appelÃ© `class="menu"` dans la div. Le problÃ¨me, câ€™est que dans `styles.css`, on voit que tous nos menus sont positionnÃ©s au mÃªme endroitÂ : regardez `top` et `right`.

``` css
.menu {
  /* Positionnement dans le body */
  position: absolute;
  top: 20px;
  right: 20px;

  /* Padding */
  padding: 8px;

  /* Dimensions minimales */
  min-height: 80px;
  min-width: 160px;

  /* Rectangle blanc avec coins arrondis */
  background-color: white;
  border-radius: 8px;
}
```

On va donc devoir positionner nos deux `<div>` indÃ©pendamment lâ€™une de lâ€™autre. Pour les sÃ©lectionner individuellement, on peut utiliser le sÃ©lecteur `#` qui permet de chercher par `id`. VoilÃ  mon codeÂ :

``` css
.menu {
  /* Padding */
  padding: 8px;

  /* Dimensions minimales */
  min-height: 80px;
  min-width: 160px;

  /* Rectangle blanc avec coins arrondis */
  background-color: white;
  border-radius: 8px;
}

#layers {
  /* Positionnement dans le body */
  position: absolute;
  top: 20px;
  right: 20px;
}

#attributes {
  /* Positionnement dans le body */
  position: absolute;
  top: 20px;
  left: 20px;
}
```

VoilÃ , maintenant `.menu` me permet de dÃ©finir un padding, des dimensions minimales, une couleur de background et des coins arrondis pour tous mes Ã©lÃ©ments avec la classe `class="menu"`, mais par contre jâ€™ai bien positionnÃ© indÃ©pendamment mon menu de layers et ma nouvelle div `attributes`.

Maintenant, modifiez le style de `#attributes` pour lâ€™afficher en bas de la carte et sur toute la largeur de lâ€™Ã©cran. Il nous faut beaucoup dâ€™espace pour afficher notre table.

Câ€™est bon, vous avez une `<div id="attributes">` qui vous plaÃ®tÂ ? Vous pouvez supprimer le texte qui Ã©tait dans la div, on nâ€™en aura plus besoin. Maintenant, on cherche Ã  dire Ã  notre applicationÂ : "Prends le texte HTML que je rÃ©cupÃ¨re grÃ¢ce Ã  ma fonction et mets-le dans ma div Attributes". On a formulÃ© notre idÃ©e en langage naturel, on va maintenant pouvoir lâ€™Ã©crire en JavaScript. Dâ€™abord, on se demande Ã  quel endroit dans notre code on rÃ©cupÃ¨re ce HTML. Souvenez-vousÂ :

``` javascript
// Interroger la couche deals et afficher les rÃ©sultats
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");

  const coord = event.coordinate;
  const res = map.getView().getResolution();
  const proj = 'EPSG:3857';
  const parametres = {'INFO_FORMAT': 'text/html'};

  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);

  if (url) {
    fetch(url)
      .then((response) => response.text())
      .then((html) => {
        // Dans cette fonction, on a accÃ¨s Ã  notre "html" !
        console.log("Câ€™est une rÃ©ussiteÂ !");
        console.log(html);
      });
  }
});
```

Vous voyez mon commentaireÂ ? Câ€™est dans cette fonction quâ€™on va Ã©crire notre code. Zoomons sur cette petite partieÂ :

``` javascript
      .then((html) => {
        // Dans cette fonction, on a accÃ¨s Ã  notre "html" !
        console.log("Câ€™est une rÃ©ussiteÂ !");
        console.log(html);
      });
```

Si je traduis le texte prÃ©cÃ©dent en langage naturel, pour rappel, Ã§a faitÂ :

-   Quand tu as **rÃ©ussi** lâ€™Ã©tape prÃ©cÃ©dente (souvenez-vous de *then*), alors stocke le rÃ©sultat dans une variable `html` etÂ :

-   Affiche "Câ€™est une rÃ©ussiteÂ !" dans ma console, puisÂ :

-   Affiche le contenu du HTML dans ma console

On aimerait remplacer les deux derniÃ¨res Ã©tapes par "affiche le HTML dans mon interface". Pour cela, on utilise la ligne de code suivante (Ã  ajouter au bon endroit dans la fonction, Ã  vous de jouer)Â :

``` javascript
document.getElementById('attributes').innerHTML = html;
```

Super, vous savez maintenant requÃªter une couche WMSÂ ! Le rÃ©sultat est un peu moche pour le moment mais vous pourrez revenir plus tard pour lâ€™affiner.

### Filtrer des couches WMS

On a vu dans lâ€™Ã©tape prÃ©cÃ©dente quâ€™il Ã©tait possible de requÃªter une couche WMS. Vous ne serez donc pas surpris dâ€™apprendre quâ€™il est aussi possible de filtrer ces couchesÂ ! Les flux WMS ont beau nous renvoyer une image, on sait maintenant quâ€™elles ne manquent pas dâ€™interactivitÃ©.

GeoServer permet dâ€™ajouter des filtres Ã©crits au format SQL Ã  la requÃªte pour lui dire "applique ce filtre Ã  ma couche avant de mâ€™envoyer le rÃ©sultat". Le filtrage se fait donc **du cÃ´tÃ© du serveur**. Vous pouvez trouver les spÃ©cifications WMS avec `cql_filter` [ici](https://docs.geoserver.org/main/en/user/services/wms/vendor.html#cql-filter) et le tutoriel de filtrage [lÃ ](https://docs.geoserver.org/2.24.x/en/user/tutorials/cql/cql_tutorial.html) mais comme câ€™est une notion un peu complexe Ã  appliquer seul, on va une fois de plus procÃ©der Ã©tape par Ã©tape ensemble.

Dans votre GeoServer, prÃ©visualisez la couche `deals` et cliquez sur les `...` bleus en haut Ã  gauche de la carte. Vous devriez voir plusieurs nouvelles options apparaÃ®tre dont une qui sâ€™appelle "Filter:". Lâ€™option "CQL" devrait dÃ©jÃ  Ãªtre sÃ©lectionnÃ©e, gardez-la. Câ€™est ce quâ€™on va utiliser pour la suite.

![](media/geoserver_cql_filter.png){fig-alt="Capture dâ€™Ã©cran de la preview de ma couche deals avec les options affichÃ©es" fig-align="center"}

Collez le texte suivant dans le champ CQL et cliquez sur "Appliquer"Â :

``` {.html .cql}
deal_size > 10000
```

Normalement, vous avez vu certains points disparaÃ®tre. Il ne vous reste plus que les deals de plus de 10Â 000 hectares. Si vous avez un doute, vous pouvez vÃ©rifier en cliquant sur les points pour afficher leurs attributs. Câ€™est facile, nonÂ ? Essayez les filtres suivant et essayez de comprendre Ã  quoi ils peuvent servirÂ :

``` html
silver = true
```

``` html
target_country = 'Argentina'
```

``` html
target_country = 'Argentina' OR target_country = 'Philippines'
```

::: callout-important
Quand vous Ã©crivez des chaÃ®nes de caractÃ¨res ("*string*") dans un filtre CQL, il faut **impÃ©rativement** utiliser les guillemets simples `'my_string'` et pas les doubles `"my_string"`.

*Ne me demandez pas pourquoi, ce nâ€™est pas expliquÃ©, il faut juste lâ€™accepter et vivre avec.*
:::

Bien, vous savez maintenant Ã©crire un filtre simple en CQL, mais comment est-ce quâ€™on fait pour filtrer la couche depuis notre application OpenLayersÂ ? Voici mon code pour appliquer Ã  ma couche `deals` un filtre qui va uniquement rÃ©cupÃ©rer les mines qui se trouvent en Argentine (*Argentina*) ou aux Philippines (*Philippines*). Comparez ce snippet avec votre code pour comprendre oÃ¹ mettre ce code et ce quâ€™il faitÂ :

``` javascript
const sourceDeals = new ImageWMS({
  url: geoserverWms,
  params: {
    'LAYERS' : 'land_matrix:deals',
    "CQL_FILTER" : "target_country = 'Argentina' OR target_country = 'Philippines'",
  },
  serverType: 'geoserver',
});
```

::: callout-important
Si vous vous Ãªtes contentÃ© de copier-coller tout Ã§a dans votre code, câ€™est sÃ»rement ratÃ©Â ! Il faut regarder mon snippet de code pour comprendre ce que **vous devez ajouter Ã  votre code existant**Â !
:::

Sauvegardez et regardez votre carte. Si vous avez compris ce que fait mon CQL, vous devriez rapidement Ãªtre capables de dire si le filtre a fonctionnÃ© ou non. Vous voyez, filtrer un flux WMS, câ€™est facileÂ !

**Maintenant, modifiez votre code pour afficher uniquement des mines qui produisent de lâ€™or.** Je vous donne deux indicesÂ : regardez la table attributaire de la couche `deals` et souvenez vous que "or" se dit "*Gold*" en anglais. Pour ceux qui ont eu des consoles portables, il y a une licence vidÃ©oludique bien pratique pour retenir des noms de minÃ©raux en anglaisÂ :

![](https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExbXlmbngwNmNlM3FwZWkzank0N3J2YndnMG43em43enp1bW1ta2MwdyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Pn21gQZ3CHzFhL8uep/giphy.webp){fig-alt="GIF : PokÃ©mon Gold" fig-align="center" width="220"}

*(Si vous Ãªtes capable dâ€™entendre ce GIF juste en le regardant, vous commencez Ã  Ãªtre vieux aussi, dÃ©solÃ©e. Quoi quâ€™il en soit, jâ€™espÃ¨re que les interruptions GIFs vous font un peu dÃ©compresser.)*

Maintenant que vous savez filtrer la couche, vous pouvez ajouter un peu plus dâ€™interactivitÃ© Ã  votre carte. On va afficher un menu avec des boutons de type "radio" pour sÃ©lectionner des filtres. Je vous fais un schÃ©ma moche Ã  la main pour vous aider Ã  comprendre.

![](media/map_select_produce.png){fig-alt="SchÃ©ma du menu \"Production\" Ã  ajouter Ã  la carte" fig-align="center"}

Vous voyez oÃ¹ on veut en venirÂ ? Comme on commence Ã  avoir lâ€™habitude de faire des menus, je vous laisse crÃ©er et positionner celui-ci avec un peu de HTML et de CSS et on passe directement Ã  lâ€™ajout des boutons. On va devoir mettre dans notre Ã©lÃ©ment `<div>` plusieurs boutons radio avec la balise `<input type="radio">`. VoilÃ  le code pour les Ã©lÃ©ments "Or" et "Argent"Â :

``` html
    <!-- Radio button menu - production -->
    <div id="production" class="menu">
  
      <div>
        <input type="radio" id="button-gold" name="produce" value="gold" />
        <label for="gold">Or</label>
      </div>
  

      <div>
        <input type="radio" id="button-silver" name="produce" value="silver" />
        <label for="silver">Argent</label>
      </div>

    </div>
```

Vous noterez plusieurs chosesÂ :

-   `<input>` et `<label>` vont par paires

-   la balise `<label>` contient le nom en franÃ§ais de mon Ã©lÃ©ment, câ€™est ce qui sâ€™affiche dans lâ€™application

-   toutes les balises `<input>` on la mÃªme propriÃ©tÃ© `name="produce"`, on dirait donc quâ€™il vaut mieux continuer dans ce sens

-   on a une propriÃ©tÃ© `id` unique Ã  chaque `<input>` qui nous permettra, au besoin, dâ€™aller les chercher avec du JavaScript

-   la propriÃ©tÃ© `value` de mes `<input>` semble correspondre Ã  des colonnes de la table attributaire de ma couche

Avec ces Ã©lÃ©ments, ajoutez les boutons pour Charbon, Lithium et Cobalt comme indiquÃ©s sur mon schÃ©ma plus haut. **Attention Ã  bien mettre Charbon en haut, comme sur lâ€™exempleÂ !** Quand câ€™est terminÃ©, allez sur votre carte et cliquez un peu sur ces boutons radio. Normalement, vous ne pouvez pas sÃ©lectionner plus dâ€™un seul Ã©lÃ©ment Ã  la fois au sein du groupe. Votre application sait que tous ces boutons font partie du mÃªme groupe car vous leur avez tous donnÃ© la mÃªme valeur `name="produce"`. Si vous commencez Ã  modifier cette valeur, votre carte va commencer Ã  se comportez bizarrement.

Une fois que votre menu est prÃªt, bien positionnÃ© sur la carte et que vos cinq boutons radio fonctionnent, on va pouvoir passer au JavaScript. Comme dâ€™habitude, on va exprimer notre besoin en langage naturelÂ : **"Lorsque je sÃ©lectionne un minÃ©ral, je souhaite modifier le filtre de ma couche `deals` pour rÃ©cupÃ©rer uniquement les deals qui produisent les minÃ©raux sÃ©lectionnÃ©s"**.

Pour rappel, voici les Ã©lÃ©ments dont on disposeÂ :

-   on a des boutons radio avec une valeur `value` qui correspond Ã  une colonne de la table attributaire

-   vous avez dÃ©jÃ  une couche qui filtre les deals qui produisent de lâ€™or avec un filtre CQL

-   le filtre CQL est tout simplement une chaÃ®ne de caractÃ¨res (*string*)

Le rÃ©sultat auquel on voudrait arriver, câ€™est doncÂ : **"Mon CQL dans les `params` de la source de ma couche `deals` change dÃ¨s que je sÃ©lectionne un nouveau minÃ©ral"**.

Ã‡a tombe bienÂ ! La [documentation de la source ImageWMS](https://openlayers.org/en/latest/apidoc/module-ol_source_ImageWMS-ImageWMS.html#updateParams) (celle quâ€™on utilise pour notre couche) nous apprend quâ€™il existe une mÃ©thode `.updateParams()` qui permet de mettre Ã  jour les paramÃ¨tres dâ€™une couche.

Commencez par ajouter ces deux Ã©lÃ©ments en bas de `main.js`. Souvenez-vous de la maniÃ¨re dont on a "Ã©coutÃ©" notre checkbox du premier exercice de ce TP. Le code ressemble beaucoup, nonÂ ?

``` javascript
const buttonGold = document.getElementById('button-gold');

buttonGold.addEventListener('change', () => {
  console.log("Test");
});
```

Voici ce que font les deux Ã©lÃ©ments du codeÂ :

-   la premiÃ¨re ligne rÃ©cupÃ¨re mon bouton radio qui grÃ¢ce Ã  son identifiant en utilisant la mÃ©thode `.getElementById()` que vous avons dÃ©jÃ  vue prÃ©cÃ©demment

-   les trois lignes suivantes nous permettent dâ€™Ã©couter notre bouton radio grÃ¢ce Ã  `.addEventListener()` et dâ€™exÃ©cuter une fonction quand le bouton radio est cochÃ©, et la fonction affiche "Test" dans la console de dÃ©veloppement

On y est presque. On arrive Ã  exÃ©cuter quelque chose quand on sÃ©lectionne "Or" dans notre carte, mais Ã§a ne nous permet pas de filtrer la couche. On va retirer notre `console.log()` et demander Ã  JavaScript de modifier les paramÃ¨tres de la source de notre couche deals grÃ¢ce Ã  la ligne suivanteÂ :

``` javascript
sourceDeals.updateParams({ 'CQL_FILTER' : 'gold=true' });
```

Pour rappel, la source de mes deals est stockÃ©e dans la variable `sourceDeals` mais attention, il est possible que la votre porte un autre nom. Pensez Ã  vÃ©rifierÂ !

Histoire de pouvoir tester au moins avec les boutons "Or" et "Argent", je vous donne un snippet de code plus complet.

``` javascript
// Or
const buttonGold = document.getElementById('button-gold');
buttonGold.addEventListener('change', () => {
  // Quand lâ€™utilisateur clique sur le bouton "Or", je mets Ã  jour mon filtre CQL
  sourceDeals.updateParams({ 'CQL_FILTER' : 'gold=true' });
});

// Argent
const buttonSilver = document.getElementById('button-silver');
buttonSilver.addEventListener('change', () => {
  sourceDeals.updateParams({ 'CQL_FILTER' : 'silver=true' });
});
```

Testez lâ€™application en cliquant alternativement sur les boutons radio de Or et Argent. Si les deux couches sont diffÃ©rentes, super, Ã§a fonctionneÂ !

Maintenant que vous avez compris comment faire, **faites la mÃªme chose pour toutes les autres options de filtrage de vos boutons radio.**

Quand vous avez terminÃ©, rajoutez une option "Tous" avec la valeur `value="all"` et faites en sorte quâ€™il affiche tous les deals (je vous ai mis des indices ci-dessous si vous avez du mal mais essayez dâ€™abord de rÃ©flÃ©chir sans)

::: {.callout-note collapse="true"}
## Indice 1 - ajouter lâ€™option "Tous" dans mon menu

Souvenez vousÂ : si vous voulez ajouter un Ã©lÃ©ment Ã  lâ€™interface, commencez par `index.html`.
:::

::: {.callout-note collapse="true"}
## Indice 2 - filtrer "Tous"

Comme on Ã©crit du code JavaScript, on doit le faire dans `main.js`. Comme pour les autres options, vous pouvez rÃ©cupÃ©rer le bouton radio avec `.getElementById()` puis lâ€™Ã©couter avec `.addEventListener()`.

Pour ce qui est du filtre CQLÂ : si on veut tous les deals, il suffit que notre filtre soit **vide**. Donc vous devriez avoir quelque part une chaÃ®ne de caractÃ¨res (*string*) vide.
:::

Une fois que câ€™est terminÃ©, bravoÂ ! Vous avez un super menu fonctionnel pour votre couche. Vous avez maintenant un bon bagage pour comprendre comment ajouter de lâ€™interaction entre votre application, les flux quâ€™elle lit et lâ€™interface. Câ€™est donc la fin de ce TP, merci pour votre attentionÂ !

![](https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExMjlteWxjN3JjYzU4aXBmY3huODRxYmk4ZGg5MWdza216MDdhNzlyNyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/ZfK4cXKJTTay1Ava29/giphy.webp){fig-alt="GIF : The Office Thank You" fig-align="center"}