---
title: "Enrichir ma carte en fonctionnalitÃ©s"
subtitle: "Enrichir ma carte OpenLayers en fonctionnalitÃ©s en utilisant les capabilities de GeoServer et plus de fonctions et objets OpenLayers."
---

## Objectifs

-   CrÃ©er un menu dâ€™affichage des couches
-   Interroger une couche WMS et afficher les rÃ©sultats
-   Filtrer une couche WMS
-   Lire un flux WFS et afficher la gÃ©omÃ©trie
-   CrÃ©er un curseur dâ€™Ã©volution temporelle
-   Ajouter une Ã©chelle Ã  la carte
-   Polir un peu lâ€™interface de lâ€™application avec du CSS
-   Pour aller plus loin, apprendre Ã  utiliser des plugins OpenLayers

## Cours

Aujourdâ€™hui, câ€™est de la pratique. Mâ€™entendre parler pendant des heures, câ€™est finiÂ !

![](https://kaamelott-gifboard.fr/gifs/on-en-a-gros.gif){fig-alt="GIF : Kaamelott on en a gros" fig-align="center" width="427"}

## TP - Faire une carte interactive sur le thÃ¨me de lâ€™exploitation miniÃ¨re et ses impacts nÃ©gatifs sur les populations locales

::: callout-important
Ce TP se base sur lâ€™architecture dÃ©ployÃ©e et le code Ã©crit au cours du TP "OpenLayers & GeoServer".
:::

Câ€™est un titre Ã  rallonge, mais voici en gros dans quelle direction la donnÃ©e de la Land Matrix va nous permettre de partir. Nous allons nous baser sur tout ce qui a Ã©tÃ© crÃ©Ã© lors du TD "OpenLayers & GeoServer". Si vous nâ€™avez pas pu suivre le TD ou que vous avez Ã©garÃ© vos fichiers, merci de le signaler maintenant.

### CrÃ©er un menu dâ€™affichage des couches

Si jamais vous nâ€™aviez pas eu le temps dâ€™afficher plus dâ€™une couche, voici le code avec lequel jâ€™ai commencÃ© ce TP. **Nâ€™oubliez pas de remplacer les Ã©lÃ©ments comme lâ€™adresse de votre GeoServerÂ !** Et si votre application affiche dÃ©jÃ  la couche "deals" et "deals_by_country", inutile de copier mon code, câ€™est plus intÃ©ressant de repartir du votre.

**index.html**

``` html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="https://openlayers.org/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Transition Minerals</title>
  </head>
  <body>
    <div id="map"></div>
    <script type="module" src="./main.js"></script>
  </body>
</html>
```

**style.css**

``` css
@import "node_modules/ol/ol.css";

html, body {
  margin: 0;
  height: 100%;
}
#map {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 100%;
}
```

**main.js**

``` javascript
import './style.css';
import {Map, View} from 'ol';
import { ImageWMS } from 'ol/source';
import TileLayer from 'ol/layer/Tile';
import ImageLayer from 'ol/layer/Image';
import OSM from 'ol/source/OSM';

// WMS de mon GeoServer
const geoserverWms = 'http://localhost:8080/geoserver/land_matrix/wms'

// Layer: Fond de carte OSM
const layerOsm = new TileLayer({ source: new OSM() });

// Layer: deals by country
const layerDealsByCountry = new ImageLayer({
  source: new ImageWMS({
    url: geoserverWms,
    params: { 'LAYERS' : 'land_matrix:deals_by_country' },
    serverType: 'geoserver',
  })
});

// Layer: deals
const sourceDeals = new ImageWMS({
  url: geoserverWms,
  params: { 'LAYERS' : 'land_matrix:deals' },
  serverType: 'geoserver',
});

const layerDeals = new ImageLayer({
  source: sourceDeals
});

// Map
const map = new Map({
  target: 'map',
  layers: [ layerOsm, layerDealsByCountry, layerDeals ],
  view: new View({
    center: [0, 0],
    zoom: 2
  })
});
```

On souhaite maintenant crÃ©er un menu avec des cases de type "checkbox" qui vont nous permettre de choisir si on veut afficher ou masquer une couche. On doit commencer par crÃ©er cet Ã©lÃ©ment dans lâ€™interface en modifiant `index.html`.

-   DÃ©finissez une `<div>` dans laquelle on souhaite afficher notre menu de couches et positionnez-la avec du CSS

-   Ajoutez Ã  lâ€™intÃ©rieur un input de type checkbox avec la balise `<input type="checkbox"/>` et donnez lui un label avec le nom de la couche

Comme câ€™est la premiÃ¨re fois quâ€™on doit Ã©crire du HTML ensemble, je vous guide pas Ã  pas. Commencez par ouvrir `index.html` et ajouter sous la `div` de votre carte (la div `map`) une autre div, comme ceciÂ :

``` html
<div id="layers" class="menu"></div>
```

On crÃ©e une nouvelle `div` dont lâ€™identifiant est `layers`, ce qui nous permettra de la retrouver par la suite. On lui a aussi ajoutÃ© une classe quâ€™on appelle `menu` et qui nous permettra dâ€™appliquer un seul style Ã  tous nos Ã©lÃ©ments de menu. Si câ€™est un peu flou maintenant, vous comprendrez plus tard en ajoutant dâ€™autres menus.

Comme notre `div` est vide, on ne la voit pas. Ã‡a va Ãªtre difficile de la positionner ailleurs sur la carte. Jâ€™ai lâ€™habitude de mettre un peu nâ€™importe quoi Ã  lâ€™intÃ©rieur, juste le temps de rÃ©gler mon CSS correctement. Ma div ressemble donc Ã Â :

``` html
<div id="layers" class="menu">cthulhu fhtagn</div>
```

On pourra retirer le texte aprÃ¨s. Vous remarquerez quâ€™on ne voit toujours pas notre texte. Essayez de rafraÃ®chir la page - vous devriez le voir tout en haut Ã  gauche de lâ€™Ã©cran avant que la carte ne le recouvreÂ ! Câ€™est normal, nous nâ€™avons pas "positionnÃ©" notre Ã©lÃ©ment. Ce nâ€™est pas un cours de CSS donc on ne rentrera pas dans les dÃ©tails. Ouvrez `styles.css` et ajoutez le code suivantÂ :

``` css
.menu {
  position: absolute;
}
```

On sÃ©lectionne toutes les balises html avec la classe `menu` et on leur applique un positionnement absolu. Sauvegardez et vous devriez voir apparaÃ®tre le texte. SuperÂ ! Maisâ€¦ câ€™est moche et Ã§a ne ressemble pas DU TOUT Ã  un menu. Pas de souci, on y arrive. Ajoutez les Ã©lÃ©ments suivants (jâ€™ai commentÃ© le code pour vous aider Ã  comprendre)Â :

``` css
.menu {
  /* Positionnement dans le body */
  position: absolute;
  top: 20px;
  right: 20px;

  /* Padding */
  padding: 8px;

  /* Dimensions minimales */
  min-height: 80px;
  min-width: 160px;

  /* Rectangle blanc avec coins arrondis */
  background-color: white;
  border-radius: 8px;
}
```

Ah, câ€™est dÃ©jÃ  plus sympaÂ ! On va mÃªme pouvoir supprimer le texte de notre balise HTML dans `index.html`. En gros, voilÃ  ce que je fais avec ce code CSSÂ :

-   Jâ€™indique que lâ€™Ã©lÃ©ment a une position absolue dans le body (donc pas relative Ã  un Ã©lÃ©ment) et quâ€™il doit se trouver Ã  20 pixels du haut (`top`) et 20 pixels de la droite (`right`) de lâ€™Ã©cran.

-   Je donne un *padding*, une marge intÃ©rieur, Ã  mon Ã©lÃ©ment de menu. Pour mieux comprendre, essayez de supprimer cette ligne et regardez ce qui change.

-   Je donne une hauteur et une largeur minimales Ã  mon Ã©lÃ©ment pour Ã©viter quâ€™il ne disparaÃ®sse quand il est vide. Par dÃ©faut, mon Ã©lÃ©ment aurait grandi et rÃ©trÃ©ci avec son contenu.

-   Jâ€™ai donnÃ© un peu de style Ã  mon menu en lui donnant un fond blanc et des coins arrondis.

VoilÃ  globalement le niveau maximum de difficultÃ© du CSS que je vais vous demander pour styliser votre application, mais vous pouvez Ã©videmment allez plus loinÂ !

Maintenant quâ€™on a un menu, il va falloir ajouter la checkbox qui permettra dâ€™afficher ou masquer ma couche. Retournez dans `index.html` et ajoutez la balise `<input>` et son `<label>` dans notre `<div id="layers>`, comme ceciÂ :

``` html
<div id="layers" class="menu">
  <input type="checkbox" id="checkbox-countries" name="checkbox-countries" checked />
  <label for="checkbox-countries">Deals by countries</label>
</div>
```

VÃ©rifiez que vous pouvez cliquer sur la checkbox pour la cocher/dÃ©cocher. Lâ€™interface est prÃªteÂ ! Il faut maintenant quâ€™on parvienne Ã  dire Ã  notre application quâ€™il faut afficher ou masquer la couche deals_by_country en fonction.

ğŸ¤” **On doit dâ€™abord se demander comment sâ€™y prendre pour masquer une couche dans OpenLayers.**

On va se servir des mÃ©thodes qui sont disponibles pour tous les objets `Layer` de OpenLayers. La [documentation](https://openlayers.org/en/latest/apidoc/module-ol_layer_Base-BaseLayer.html#setVisible) nous apprend lâ€™existence de la mÃ©thode `setVisible()`. VoilÃ  ce quâ€™on nous en ditÂ :

![](media/set_visible_ol.png){fig-alt="Documentation de la mÃ©thode setVisible() OpenLayers" fig-align="center"}

La mÃ©thode `setVisible()` prend un argument `visible`. Cet argument est de type "boolean", il peut donc prendre la valeur `true` ou `false`. On va faire le test et utiliser cette fonction pour faire disparaÃ®tre notre couche. Allez dans `main.js` et ajouter cette ligne Ã  la fin de votre scriptÂ :

``` javascript
layer_deals_by_country.setVisible(false);
```

**AttentionÂ !** `layer_deals_by_country` est le nom de la variable dans laquelle jâ€™ai crÃ©Ã© ma couche "deals_by_country". Si vous avez nommÃ© votre couche diffÃ©remment, nâ€™oubliez pas de changer le nomÂ !

Normalement, la couche ne devrait plus Ãªtre visible sur la carte. Super, la mÃ©thode a fonctionnÃ©Â ! Il ne nous reste plus quâ€™Ã  "connecter" cette mÃ©thode Ã  notre Ã©lÃ©ment checkbox.

On lâ€™a dÃ©jÃ  vu dans le TP Serveurs cartographiques (lorsquâ€™on affichait la lÃ©gende des couches), il est possible de trouver un Ã©lÃ©ment HTML et de le modifier en utilisant du JavaScript. Pour trouver un Ã©lÃ©ment, le plus facile est de rechercher son identifiant `id`. Ajoutez en bas de `main.js`Â :

``` javascript
const checkbox_countries = document.getElementById('checkbox-countries');
console.log(checkbox_countries);
```

Sauvegardez et allez dans la console de votre navigateur. Vous devriez voir apparaÃ®tre votre tag `<input>` dans la console. Si vous le survolez avec la souris, la checkbox devrait Ãªtre passÃ©e en surbrillance. Si Ã§a fonctionne, parfait ! Ã‡a veut dire quâ€™on arrive bien Ã  rÃ©cupÃ©rer notre Ã©lÃ©ment de checkbox. Maintenant, on souhaite exÃ©cuter du code lorsque son statut "checked" change. Pour cela, on doit "Ã©couter" la checkbox pour savoir si lâ€™Ã©vÃ¨nement "change" a eu lieu.

``` javascript
const checkboxCountries = document.getElementById('checkbox-countries');

checkboxCountries.addEventListener('change', (event) => {
  if (event.currentTarget.checked) {
    // On fait des trucs quand la checkbox est checkÃ©e
    console.log("Checked");
  } else {
    // On fait des trucs quand la checkbox nâ€™est PAS checkÃ©e
    console.log("Pas checked");
  }
});
```

-   `addEventListener` indique quâ€™on souhaite "Ã©couter" les Ã©vÃ¨nements de notre checkbox. On prÃ©cise le type dâ€™Ã©vÃ¨nement avec le premier paramÃ¨tre, `'change'`.

-   La condition `if` vÃ©rifie si notre checkbox est checkÃ©e ou non. On rÃ©cupÃ¨re cette information grÃ¢ce Ã  `event.current.checked`. Si cette condition est `true`, on affiche "Checked" dans la console. Si cette condition est `false`, on affiche "Pas checked".

EssayezÂ ! Cliquez sur la checkbox et surveillez votre console. On voit bien sâ€™afficher les messages. On y est presqueÂ ! Maintenant, au lieu dâ€™afficher du texte, on souhaite afficher la couche quand la condition est `true` et la masquer quand la condition est `false`.

``` javascript
const checkboxCountries = document.getElementById('checkbox-countries');

checkboxCountries.addEventListener('change', (event) => {
  if (event.currentTarget.checked) {
    // On fait des trucs quand la checkbox est checkÃ©e
    layer_deals_by_country.setVisible(true);
  } else {
    // On fait des trucs quand la checkbox nâ€™est PAS checkÃ©e
    layer_deals_by_country.setVisible(false);
  }
});
```

::: callout-caution
## Pensez bien Ã â€¦

-   Changer le nom de la couche `layer_deals_by_country` si vous nâ€™avez pas appelÃ© votre couche comme Ã§a.

-   Supprimer la ligne `layer_deals_by_country.setVisible(false);` toute seule au dessus ou votre couche sera masquÃ©e par dÃ©faut au moment de charger la carte.
:::

VoilÃ , on peut dÃ©sormais afficher et masquer la couche Ã  volontÃ©Â !

![](https://media1.tenor.com/m/wn2_Qq6flogAAAAC/magical-magic.gif){fig-alt="GIF : Magic" fig-align="center" width="435"}

Ã€ vousÂ ! CrÃ©ez une autre checkbox qui permet dâ€™afficher ou masquer la couche deals. Jâ€™aimerais que cette checkbox soit **au-dessus** de la premiÃ¨reÂ !

::: callout-tip
Sauf indication contraire (via du CSS), les Ã©lÃ©ments HTML sont affichÃ©s dans lâ€™ordre dans lequel ils sont dÃ©clarÃ©s.

``` html
<div id="2"></div>
<div id="1"></div>
```

Dans cet exemple, ma div 1 sera plus bas que ma div 2. Ã‡a devrait vous aider !
:::

### Interroger une couche WMS et afficher les rÃ©sultats

On souhaite maintenant interroger la couche deals en cliquant dessus. Cette Ã©tape est plus compliquÃ©e que la prÃ©cÃ©dente car elle va nous demander dâ€™utiliser `fetch()`, on va donc lÃ -aussi procÃ©der petit Ã  petit pour bien comprendre ce quâ€™on fait. Ouvrez lâ€™exemple OpenLayers [WMS GetFeatureInfo (Image Layer)](https://openlayers.org/en/latest/examples/getfeatureinfo-image.html).

CommenÃ§ons par sâ€™intÃ©resser Ã  cette partie du codeÂ :

``` javascript
map.on('singleclick', function (evt) {
  document.getElementById('info').innerHTML = '';
  const viewResolution = /** @type {number} */ (view.getResolution());
  const url = wmsSource.getFeatureInfoUrl(
    evt.coordinate,
    viewResolution,
    'EPSG:3857',
    {'INFO_FORMAT': 'text/html'},
  );
  if (url) {
    fetch(url)
      .then((response) => response.text())
      .then((html) => {
        document.getElementById('info').innerHTML = html;
      });
  }
});
```

-   `.on('singleclick')` permet dâ€™exÃ©cuter une fonction lorsquâ€™on clique sur la carte.

-   `document.getElementById()` rÃ©cupÃ¨re lâ€™Ã©lÃ©ment 'info' dans lequel ils affichent leurs rÃ©sultats.

-   On rÃ©cupÃ¨re la rÃ©solution de la vue de la carte grÃ¢ce Ã  la mÃ©thode dans `viewResolution`. On a besoin de passer cette rÃ©solution dans la fonction suivante.

-   On rÃ©cupÃ¨re lâ€™url qui contient les informations de lâ€™Ã©lÃ©ment cliquÃ© avec la mÃ©thode `getFeatureInfoUrl()` de la source de donnÃ©es.

-   Si notre url est dÃ©finie, alors on utilise la fonction `fetch()` pour rÃ©cupÃ©rer la donnÃ©e Ã  partir de cette adresse.

-   `document.getElementById()` rÃ©cupÃ¨re Ã  nouveau lâ€™Ã©lÃ©ment 'info' et dÃ©finir la valeur de son `innerHTML` pour pouvoir afficher les rÃ©sultats.

CompliquÃ©Â ? Non, Ã§a va allerÂ ! On va tranquillement rÃ©Ã©crire cette fonction pour la couche `deals`. Pour rappel, voici comment jâ€™appelle la couche `deals` dans mon codeÂ :

``` javascript
const sourceDeals = new ImageWMS({
  url: geoserverWms,
  params: { 'LAYERS' : 'land_matrix:deals' },
  serverType: 'geoserver',
});

const layerDeals = new ImageLayer({
  source: sourceDeals
});
```

Je commence donc par exÃ©cuter une fonction lorsque je clique sur la carteÂ :

``` javascript
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");
});
```

Sauvegardez, gardez la console de votre navigateur ouverte et cliquez sur la carte pour vÃ©rifier que le message apparaÃ®t bien. Si câ€™est bon, on vient dâ€™apprendre comment exÃ©cuter des fonctions en cliquant sur la carteÂ ! On sait ensuite que dans lâ€™exemple ils utilisent la mÃ©thode `getFeatureInfoUrl()` de leur source de donnÃ©es pour rÃ©cupÃ©rer les informations des features. Ouvrez la [documentation de ImageWMS](https://openlayers.org/en/latest/apidoc/module-ol_source_ImageWMS-ImageWMS.html#getFeatureInfoUrl) on va en avoir besoin. VoilÃ  ce quâ€™elle nous dit au sujet de la mÃ©thode `fetFeatureInfoUrl()`Â :

![](media/get_feature_info_url_ol.png){fig-alt="Documentation getFeatureInfoUrl() dâ€™OpenLayers" fig-align="center"}

La mÃ©thode prend plusieurs paramÃ¨tresÂ :

-   `coordinate`, les coordonnÃ©es visÃ©es par le clic de lâ€™utilisateur

-   `resolution`, la rÃ©solution de la carte (liÃ©e Ã  la `view` de ma carte)

-   `projection`, le systÃ¨me de projection de la carteÂ : "EPSG:3857'"

-   `params`, un objet contenant plusieurs paramÃ¨tres comme le format dÃ©sirÃ© du rÃ©sultat ou encore les couches quâ€™on souhaite interroger

RÃ©cupÃ©rons ces Ã©lÃ©ments dans lâ€™ordre en commenÃ§ant par les coordonnÃ©es. Dans lâ€™exemple, ils rÃ©fÃ©rencent directement la source de coordonnÃ©es `evt.coordinate` dans la fonction mais Ã§a va un peu vite. Pour mieux comprendre, on va stocker les coordonnÃ©es de notre Ã©vÃ¨nement (= notre clic) dans une constante.

``` javascript
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");
  
  const coord = event.coordinate;
});
```

En fait, lâ€™Ã©vÃ¨nement 'singleclick' de la carte `map` permet de rÃ©cupÃ©rer les coordonnÃ©es du clic en accÃ©dant Ã  sa propriÃ©tÃ© `coordinate`. On Ã©crit donc `event.coordinate`.

::: {.callout-note collapse="true"}
## Pourquoi on a "event" et pas "evt"Â ?

Jâ€™ai fait exprÃ¨s de changer le nom du paramÃ¨tre pour appeler tous les Ã©vÃ¨nements "event" dans notre code et pour ajouter cette petite note. En fait, quand on crÃ©e une fonction, on peut nommer notre paramÃ¨tre comme on veut. Par exemple, dans le code suivantÂ :

``` javascript
map.on('singleclick', (event) => {
  const coord = event.coordinate;
});
```

â€¦ la variable `coordinates` a la mÃªme valeur que si jâ€™Ã©crisÂ :

``` javascript
map.on('singleclick', (evt) => {
  const coord = evt.coordinate;
});
```

â€¦ ou encoreÂ :

``` javascript
map.on('singleclick', (mon_evenement_qui_vient_de_ma_carte_avec_mon_clic) => {
  const coord = mon_evenement_qui_vient_de_ma_carte_avec_mon_clic.coordinate;
});
```

Bien sÃ»r, si vous ne vous sentez pas encore trop en confiance, inutile de renommer ce genre dâ€™Ã©lÃ©ments pour uniformiser le code. Vous pouvez garder ce que vous voyez dans le code OpenLayers.
:::

AprÃ¨s les coordonnÃ©es, on rÃ©cupÃ¨re la rÃ©solution. On sait quâ€™on lit la rÃ©solution depuis la vue de la carte, donc on peut dâ€™abord rÃ©cupÃ©rer cette vue PUIS lire sa rÃ©solution (toujours dans notre fonction, pas Ã  lâ€™extÃ©rieurÂ !)Â :

``` javascript
const view = map.getView();
const res = view.getResolution();
```

On peut aussi enchaÃ®ner les mÃ©thodes comme ceciÂ :

``` javascript
const res = map.getView().getResolution();
```

::: {.callout-note collapse="true"}
## Pourquoi on ne reprend pas le /\*\* \@type \*/ du code originalÂ ?

Parce quâ€™on nâ€™en est pas Ã  faire du TypeScriptÂ ! Ils ont fait un excÃ¨s de zÃ¨le dans cet exemple. Cette syntaxe Ã©trange signifique que le type de la constante est de type "number", donc un nombre. Mais Ã§a on le sait dÃ©jÃ  de toute faÃ§on, on a lu la documentation.
:::

On est Ã  mi-chemin et le reste est trÃ¨s simple. La projection doit Ãªtre indiquÃ©e par une chaÃ®ne de caractÃ¨resÂ :

``` javascript
const proj = 'EPSG:3857';
```

Et on reprend les paramÃ¨tres de lâ€™exemple pour indiquer quâ€™on veut rÃ©cupÃ©rer notre rÃ©ponse au format HTML. Par dÃ©faut, GeoServer renverra la table attributaire de lâ€™Ã©lÃ©ment sous forme dâ€™un tableau en HTML.

``` javascript
const parametres = {'INFO_FORMAT': 'text/html'};
```

On a tous nos Ã©lÃ©ments, il ne nous reste quâ€™Ã  appeler la mÃ©thode `getFeatureInfoUrl()` sur notre **source** de donnÃ©es (attention, pas la coucheÂ !) pour gÃ©nÃ©rer lâ€™url qui nous permettra de rÃ©cupÃ©rer la rÃ©ponse. La documentation nous indique que les paramÃ¨tres doivent Ãªtre renseignÃ©s dans lâ€™ordre suivantÂ :

-   coordinate

-   resolution

-   projection

-   params

``` javascript
const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);
```

Ou encore, pour ressembler Ã  lâ€™exempleÂ :

``` javascript
const url = sourceDeals.getFeatureInfoUrl(
  coord,
  res,
  proj,
  parametres
);
```

Pour rÃ©capituler, voilÃ  Ã  quoi ressemble ma fonction pour le moment. Jâ€™ai ajoutÃ© un `console.log()` pour voir lâ€™url sâ€™afficher dans ma console et donc bien vÃ©rifier que jâ€™arrive Ã  gÃ©nÃ©rer cette adresse.

``` javascript
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");

  const coord = event.coordinate;
  const res = map.getView().getResolution();
  const proj = 'EPSG:3857';
  const parametres = {'INFO_FORMAT': 'text/html'};

  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);

  console.log(url);
});
```

Attention, voilÃ  la partie plus compliquÃ©eÂ : maintenant quâ€™on a une addresse, on doit utilier la fonction `fetch()` pour rÃ©cupÃ©rer la donnÃ©e. Câ€™est une fonction bien particuliÃ¨re. Elle est dite "asynchrone" car elle ne bloque pas le reste du code lorsquâ€™elle tourne, contrairement aux autres fonctions "synchrones". Si jâ€™Ã©cris une fonction `reboursSynchrone()`, lâ€™exÃ©cution de mon code et donc mon application est bloquÃ©e pendant que la fonction sâ€™exÃ©cute. Si câ€™est une petite fonction rapide Ã§a ne pose pas de problÃ¨me. Si câ€™est quelque chose de plus lent, par exemple qui demande dâ€™attendre la rÃ©ponse dâ€™un serveur dans le cas de notre fetch, notre application est bloquÃ©e et on est bien embÃªtÃ©s. Au contraire, si jâ€™Ã©cris une fonction `reboursAsynchrone()` lâ€™application nâ€™attendra pas que la fonction ait terminÃ© de sâ€™exÃ©cuter pour pouvoir continuer de fonctionner.

Du coup, lâ€™asynchrone, câ€™est trÃ¨s pratiqueÂ ! Par contre, comme câ€™est particulier et quâ€™il est plus difficile de prÃ©voir quand elle va terminer son exÃ©cution et si elle va rencontrer des erreurs ou non, on va devoir lui rÃ©server un traitement particulier. Reprenons le code de lâ€™exemple pour lâ€™expliquer petit Ã  petit.

``` javascript
fetch(url)
  .then((response) => response.text())
  .then((html) => {
    // Jâ€™ai modifiÃ© la ligne suivante pour simplifier, on sâ€™intÃ©ressera Ã  elle un peu plus tard
    console.log("Câ€™est une rÃ©ussiteÂ !");
  });
```

Vous noterez lâ€™utilisation de mÃ©thodes `.then()` qui contiennent des fonctions. Ce sont les fonctions Ã  exÃ©cuter quand le maillon prÃ©cÃ©dent de la chaÃ®ne a fini de se rÃ©soudre. Si on devait Ã©crire en langage courant ce que signifie ce code, voilÃ  ce que Ã§a donneraitÂ :

-   `fetch(url)` â†’ "RÃ©cupÃ¨re les informations qui sont disponibles Ã  cette adresse"

-   `.then((response) => response.text())` â†’ "Ensuite ("*then*"), quand tu as **rÃ©ussi** Ã  rÃ©cupÃ©rer la rÃ©ponse, stocke-la dans une variable que jâ€™appelle "response" puis utilise sa mÃ©thode `.text()` pour rÃ©cupÃ©rer du texte au format HTML"

-   `.then((html) => { console.log("Câ€™est une rÃ©ussiteÂ !"); })` â†’ "Ensuite, quand tu as **rÃ©ussi** lâ€™Ã©tape prÃ©cÃ©dente, stocke le texte au format HTML de lâ€™Ã©tape prÃ©cÃ©dente dans une variable que jâ€™appelle "html" et affiche un message dans ma console"

Vous noterez que jâ€™ai prÃ©cisÃ© que `.then()` sâ€™exÃ©cute si lâ€™Ã©tape prÃ©cÃ©dente a rÃ©ussi. Si ce nâ€™est pas le cas, lâ€™exÃ©cution de notre chaÃ®ne de mÃ©thodes `fetch()` sâ€™arrÃªte et un message dâ€™erreur sâ€™affiche dans la console. Comme on a plutÃ´t confiance en notre GeoServer, on peut se lancer et exÃ©cuter ce `fetch()` mais attention, seulement si on a bien une addresse Ã  interrogerÂ ! Si la variable `url` est `undefined`, notre application risque de pÃ©ter les plombs. On ajoute une condition autour du `fetch()` pour Ã©viter les erreursÂ :

``` javascript
if (url) {
  fetch(url)
    .then((response) => response.text())
    .then((html) => {
      console.log("Câ€™est une rÃ©ussiteÂ !");
      console.log(html);
    });
}
```

Vous pouvez tester les `console.log()`. Le HTML quâ€™on obtient nâ€™est pas trÃ¨s gracieux tel quel, il vaudrait mieux lâ€™afficher dans lâ€™interface de lâ€™applicationÂ !

::: {.callout-note collapse="true"}
## Au secours, je nâ€™ai toujours pas compris fetch()

![](https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExYm5odGpnZTVnY3V4ZGZyNHQ2aDhqZjFqMGVlNnhpZXZ5Yjgxa3gxaiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/9iBIdXITr6LoVf8XgY/giphy.webp){fig-alt="GIF : Kermit qui nâ€™en peut plus" fig-align="center"}

Si votre cerveau est un peu comme Ã§a quand on parle de `fetch()`, nâ€™hÃ©sitez pas Ã  mâ€™appeler pour avoir une nouvelle explication. Jâ€™ai peur de ne pas pouvoir faire mieux par Ã©crit. La notion de fonction asynchrone est complexe et jâ€™ai mis pas mal de temps Ã  la comprendre, donc en deux minutes en plein milieu dâ€™un TP câ€™est encore pire.

Sinon, vous pouvez continuer le TP, on aura dâ€™autres occasion dâ€™utiliser `fetch()`. Peut-Ãªtre que les autres exemples seront plus clairsÂ !
:::

Quand on doit afficher un nouvel Ã©lÃ©ment dans lâ€™interface, il faut toujours penser Ã  crÃ©er une nouvelle balise HTML (souvent une `<div>`) pour le mettre Ã  lâ€™intÃ©rieur. Comme pour lâ€™exemple prÃ©cÃ©dent, on crÃ©e une div dans le HTML. Je place la mienne aprÃ¨s `<div id="layers">` et je remets nâ€™importe quoi dedans juste pour la voir dans mon interface.

``` html
<div id="attributes" class="menu">cthulhu ftaghn</div>
```

Sauvegardez et regardez lâ€™application. Et lÃ , horreurÂ ! Notre menu de couches est remplacÃ© par la nouvelle div quâ€™on vient de crÃ©erÂ ! Câ€™est normal, elles ont le mÃªme style car on a aussi appelÃ© `class="menu"` dans la div. Le problÃ¨me, câ€™est que dans `styles.css`, on voit que tous nos menus sont positionnÃ©s au mÃªme endroitÂ : regardez `top` et `right`.

``` css
.menu {
  /* Positionnement dans le body */
  position: absolute;
  top: 20px;
  right: 20px;

  /* Padding */
  padding: 8px;

  /* Dimensions minimales */
  min-height: 80px;
  min-width: 160px;

  /* Rectangle blanc avec coins arrondis */
  background-color: white;
  border-radius: 8px;
}
```

On va donc devoir positionner nos deux `<div>` indÃ©pendamment lâ€™une de lâ€™autre. Pour les sÃ©lectionner individuellement, on peut utiliser le sÃ©lecteur `#` qui permet de chercher par `id`. VoilÃ  mon codeÂ :

``` css
.menu {
  /* Padding */
  padding: 8px;

  /* Dimensions minimales */
  min-height: 80px;
  min-width: 160px;

  /* Rectangle blanc avec coins arrondis */
  background-color: white;
  border-radius: 8px;
}

#layers {
  /* Positionnement dans le body */
  position: absolute;
  top: 20px;
  right: 20px;
}

#attributes {
  /* Positionnement dans le body */
  position: absolute;
  top: 20px;
  left: 20px;
}
```

VoilÃ , maintenant `.menu` me permet de dÃ©finir un padding, des dimensions minimales, une couleur de background et des coins arrondis pour tous mes Ã©lÃ©ments avec la classe `class="menu"`, mais par contre jâ€™ai bien positionnÃ© indÃ©pendamment mon menu de layers et ma nouvelle div `attributes`.

Maintenant, modifiez le style de `#attributes` pour lâ€™afficher en bas de la carte et sur toute la largeur de lâ€™Ã©cran. Il nous faut beaucoup dâ€™espace pour afficher notre table.

Câ€™est bon, vous avez une `<div id="attributes">` qui vous plaÃ®tÂ ? Vous pouvez supprimer le texte qui Ã©tait dans la div, on nâ€™en aura plus besoin. Maintenant, on cherche Ã  dire Ã  notre applicationÂ : "Prends le texte HTML que je rÃ©cupÃ¨re grÃ¢ce Ã  ma fonction et mets-le dans ma div Attributes". On a formulÃ© notre idÃ©e en langage naturel, on va maintenant pouvoir lâ€™Ã©crire en JavaScript. Dâ€™abord, on se demande Ã  quel endroit dans notre code on rÃ©cupÃ¨re ce HTML. Souvenez-vousÂ :

``` javascript
// Interroger la couche deals et afficher les rÃ©sultats
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");

  const coord = event.coordinate;
  const res = map.getView().getResolution();
  const proj = 'EPSG:3857';
  const parametres = {'INFO_FORMAT': 'text/html'};

  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);

  if (url) {
    fetch(url)
      .then((response) => response.text())
      .then((html) => {
        // Dans cette fonction, on a accÃ¨s Ã  notre "html" !
        console.log("Câ€™est une rÃ©ussiteÂ !");
        console.log(html);
      });
  }
});
```

Vous voyez mon commentaireÂ ? Câ€™est dans cette fonction quâ€™on va Ã©crire notre code. Zoomons sur cette petite partieÂ :

``` javascript
      .then((html) => {
        // Dans cette fonction, on a accÃ¨s Ã  notre "html" !
        console.log("Câ€™est une rÃ©ussiteÂ !");
        console.log(html);
      });
```

Si je traduis le texte prÃ©cÃ©dent en langage naturel, pour rappel, Ã§a faitÂ :

-   Quand tu as **rÃ©ussi** lâ€™Ã©tape prÃ©cÃ©dente (souvenez-vous de *then*), alors stocke le rÃ©sultat dans une variable `html` etÂ :

-   Affiche "Câ€™est une rÃ©ussiteÂ !" dans ma console

-   Affiche le contenu du HTML dans ma console

On aimerait remplacer les deux derniÃ¨res Ã©tapes par "affiche le HTML dans mon interface". Pour cela, on utilise la ligne de code suivante (Ã  ajouter au bon endroit dans la fonction)Â :

``` javascript
document.getElementById('attributes').innerHTML = html;
```

Super, vous savez maintenant requÃªter une couche WMSÂ ! Le rÃ©sultat est un peu moche pour le moment mais vous pourrez revenir plus tard pour lâ€™affiner. Si vous finissez le TP en avance, revenez sur les sections "Pour aller plus loinâ€¦".

::: {.callout-note collapse="true"}
## Pour aller plus loinâ€¦

Si vous avez dÃ©jÃ  fait le tour du TP, vous allez trouver dans cette section des Ã©lÃ©ments supplÃ©mentaires pour aller plus loin.

*En cours de rÃ©daction*
:::

### Filtrer des couches WMS

On a vu dans lâ€™Ã©tape prÃ©cÃ©dente quâ€™il Ã©tait possible de requÃªter une couche WMS. Vous ne serez donc pas surpris dâ€™apprendre quâ€™il est aussi possible de filtrer ces couchesÂ ! Les flux WMS ont beau retourner une image, on constate maintenant quâ€™elles ne manquent pas dâ€™interactivitÃ©.

GeoServer permet dâ€™ajouter des filtres Ã©crits au format cql Ã  la requÃªte pour lui dire "applique ce filtre Ã  ma couche avant de mâ€™envoyer le rÃ©sultat". Le filtrage se fait donc **du cÃ´tÃ© du serveur**. Vous pouvez trouver les spÃ©cifications WMS avec `cql_filter` [ici](https://docs.geoserver.org/main/en/user/services/wms/vendor.html#cql-filter) et le tutoriel de filtrage [lÃ ](https://docs.geoserver.org/2.24.x/en/user/tutorials/cql/cql_tutorial.html) mais comme câ€™est une notion un peu complexe Ã  appliquer seul, on va une fois de plus procÃ©der Ã©tape par Ã©tape ensemble.

Dans votre GeoServer, prÃ©visualisez la couche `deals` et cliquez sur les `...` bleus en haut Ã  gauche de la carte. Vous devriez voir plusieurs nouvelles options apparaÃ®tre dont une qui sâ€™appelle "Filter:". Lâ€™option "CQL" devrait dÃ©jÃ  Ãªtre sÃ©lectionnÃ©e, gardez-la. Câ€™est ce quâ€™on va utiliser pour la suite.

![](media/geoserver_cql_filter.png){fig-alt="Capture dâ€™Ã©cran de la preview de ma couche deals avec les options affichÃ©es" fig-align="center"}

Collez le texte suivant dans le champ CQL et cliquez sur "Appliquer"Â :

``` {.html .cql}
deal_size > 10000
```

Normalement, vous avez vu certains points disparaÃ®tre. Il ne vous reste plus que les deals de plus de 10Â 000 hectares. Si vous avez un doute, vous pouvez vÃ©rifier en cliquant sur les points pour afficher leurs attributs. Câ€™est facile, nonÂ ? Essayez les filtres suivant et essayez de comprendre Ã  quoi ils peuvent servirÂ :

``` html
silver = true
```

``` html
target_country = 'Argentina'
```

``` html
target_country = 'Argentina' OR target_country = 'Philippines'
```

::: callout-important
Quand vous Ã©crivez des chaÃ®nes de caractÃ¨res dans un filtre CQL ("*string*"), il faut **impÃ©rativement** utiliser les guillemets simples `'my_string'` et pas les doubles `"my_string"`.

*Ne me demandez pas pourquoi, ce nâ€™est pas expliquÃ©, il faut juste lâ€™accepter et vivre avec.*
:::

Bien, vous savez maintenant Ã©crire un filtre simple en CQL, mais comment est-ce quâ€™on fait pour filtrer la couche depuis notre application OpenLayersÂ ? Voici mon code pour appliquer Ã  ma couche `deals` un filtre qui va uniquement rÃ©cupÃ©rer les mines qui produisent de lâ€™or (*Gold*) ou de lâ€™argent (*Silver*). Comparez ce snippet avec votre code pour comprendre oÃ¹ mettre ce code et ce quâ€™il faitÂ :

``` javascript
const sourceDeals = new ImageWMS({
  url: geoserverWms,
  params: {
    'LAYERS' : 'land_matrix:deals',
    "CQL_FILTER" : "target_country = 'Argentina' OR target_country = 'Philippines'",
  },
  serverType: 'geoserver',
});
```

::: callout-important
Si vous vous Ãªtes contentÃ© de copier-coller tout Ã§a dans votre code, câ€™est ratÃ©Â ! Il faut regarder mon snippet de code pour comprendre ce que **vous devez ajouter Ã  votre code existant**Â !
:::

Sauvegardez et regardez votre carte. Si vous avez compris ce que fait mon CQL, vous devriez rapidement Ãªtre capables de dire si le filtre a fonctionnÃ© ou non. Vous voyez, filtrer un flux WMS, câ€™est facileÂ !

**Maintenant, modifiez votre code pour afficher uniquement des mines qui produisent de lâ€™or.** Je vous donne deux indicesÂ : regardez la table attributaire de la couche `deals` et souvenez vous que "or" se dit "*Gold*" en anglais. Pour ceux qui ont eu des consoles portables, il y a une licence vidÃ©oludique bien pratique pour retenir des noms de minÃ©raux en anglaisÂ :

![](https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExbXlmbngwNmNlM3FwZWkzank0N3J2YndnMG43em43enp1bW1ta2MwdyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Pn21gQZ3CHzFhL8uep/giphy.webp){fig-alt="GIF : PokÃ©mon Gold" fig-align="center" width="220"}

*(Si vous Ãªtes capable dâ€™entendre ce GIF juste en le regardant, vous commencez Ã  Ãªtre vieux aussi, dÃ©solÃ©e. Quoi quâ€™il en soit, jâ€™espÃ¨re que les interruptions GIFs vous font un peu dÃ©compresser.)*

Maintenant que vous savez filtrer la couche, vous pouvez ajouter un peu plus dâ€™interactivitÃ© Ã  votre carte. On va afficher un menu avec des boutons de type "radio" pour sÃ©lectionner des filtres. Je vous fais un schÃ©ma moche Ã  la main pour vous aider Ã  comprendre.

![](media/map_select_produce.png){fig-alt="SchÃ©ma du menu \"Production\" Ã  ajouter Ã  la carte" fig-align="center"}

Vous voyez oÃ¹ on veut en venirÂ ? Comme on commence Ã  avoir lâ€™habitude de faire des menus, je vous laisse crÃ©er et positionner celui-ci avec un peu de HTML et de CSS et on passe directement Ã  lâ€™ajout des boutons. On va devoir mettre dans notre Ã©lÃ©ment `<div>` plusieurs boutons radio avec la balise `<input type="radio">`. VoilÃ  le code pour les Ã©lÃ©ments "Or" et "Argent"Â :

``` html
    <!-- Radio button menu - production -->
    <div id="production" class="menu">
  
      <div>
        <input type="radio" id="button-gold" name="produce" value="gold" />
        <label for="gold">Or</label>
      </div>
  

      <div>
        <input type="radio" id="button-silver" name="produce" value="silver" />
        <label for="silver">Argent</label>
      </div>

    </div>
```

Vous noterez plusieurs chosesÂ :

-   `<input>` et `<label>` vont par paires

-   la balise `<label>` contient le nom en franÃ§ais de mon Ã©lÃ©ment, câ€™est ce qui sâ€™affiche dans lâ€™application

-   toutes les balises `<input>` on la mÃªme propriÃ©tÃ© `name="produce"`, on dirait donc quâ€™il vaut mieux continuer dans ce sens

-   on a une propriÃ©tÃ© `id` unique Ã  chaque `<input>` qui nous permettra, au besoin, dâ€™aller les chercher avec du JavaScript

-   la propriÃ©tÃ© `value` de mes `<input>` semble correspondre Ã  des colonnes de la table attributaire de ma couche

Avec ces Ã©lÃ©ments, ajoutez les boutons pour Charbon, Lithium et Cobalt comme indiquÃ©s sur mon schÃ©ma plus haut. **Attention Ã  bien mettre Charbon en hautÂ !** Quand câ€™est terminÃ©, allez sur votre carte et cliquez un peu sur ces boutons radio. Normalement, vous ne pouvez pas sÃ©lectionner plus dâ€™un seul Ã©lÃ©ment Ã  la fois au sein du groupe. Votre application sait que tous ces boutons font partie du mÃªme groupe car vous leur avez tous donnÃ© la mÃªme valeur `name="produce"`. Si vous commencez Ã  modifier cette valeur, vous verrez apparaÃ®tre un comportement indÃ©sirable.

Une fois que votre menu est prÃªt, bien positionnÃ© sur la carte et que vos cinq boutons radio fonctionnent, on va pouvoir passer au JavaScript. Comme dâ€™habitude, on va exprimer notre besoin en langage naturelÂ : **"Lorsque je sÃ©lectionne un minÃ©ral, je souhaite modifier le filtre de ma couche `deals` pour rÃ©cupÃ©rer uniquement les deals qui produisent les minÃ©raux sÃ©lectionnÃ©s"**.

Pour rappel, voici les Ã©lÃ©ments dont on disposeÂ :

-   on a des boutons radio avec une valeur `value` qui correspond Ã  une colonne de la table attributaire

-   vous avez dÃ©jÃ  une couche qui filtre les deals qui produisent de lâ€™or avec un filtre CQL

-   le filtre CQL est tout simplement une chaÃ®ne de caractÃ¨res (*string*)

Le rÃ©sultat auquel on voudrait arriver, câ€™est doncÂ : **"Mon CQL dans les `params` de la source de ma couche `deals` change dÃ¨s que je sÃ©lectionne un nouveau minÃ©ral"**.

Ã‡a tombe bienÂ ! La [documentation de la source ImageWMS](https://openlayers.org/en/latest/apidoc/module-ol_source_ImageWMS-ImageWMS.html#updateParams) (celle quâ€™on utilise pour notre couche) nous apprend quâ€™il existe une mÃ©thode `.updateParams()` qui permet de mettre Ã  jour les paramÃ¨tres dâ€™une couche.

Commencez par ajouter ces deux Ã©lÃ©ments en bas de `main.js`. Souvenez-vous de la maniÃ¨re dont on a "Ã©coutÃ©" notre checkbox du premier exercice de ce TP. Le code ressemble beaucoup, nonÂ ?

``` javascript
const buttonGold = document.getElementById('button-gold');

buttonGold.addEventListener('change', () => {
  console.log("Test");
});
```

Voici ce que font les deux Ã©lÃ©ments du codeÂ :

-   la premiÃ¨re ligne rÃ©cupÃ¨re mon bouton radio qui grÃ¢ce Ã  son identifiant en utilisant la mÃ©thode `.getElementById()` que vous avons dÃ©jÃ  vue prÃ©cÃ©demment

-   les trois lignes suivantes nous permettent dâ€™Ã©couter notre bouton radio grÃ¢ce Ã  `.addEventListener()` et dâ€™exÃ©cuter une fonction quand le bouton radio est cochÃ©, et la fonction affiche "Test" dans la console de dÃ©veloppement

On y est presque. On arrive Ã  exÃ©cuter quelque chose quand on sÃ©lectionne "Or" dans notre carte, mais Ã§a ne nous permet pas de filtrer la couche. On va retirer notre `console.log()` et demander Ã  JavaScript de modifier les paramÃ¨tres de la source de notre couche deals grÃ¢ce Ã  la ligne suivanteÂ :

``` javascript
sourceDeals.updateParams({ 'CQL_FILTER' : 'gold=true' });
```

Pour rappel, la source de mes deals est stockÃ©e dans la variable `sourceDeals` mais attention, il est possible que la votre porte un autre nom. Pensez Ã  vÃ©rifierÂ !

Histoire de pouvoir tester au moins avec les boutons "Or" et "Argent", je vous donne un snippet de code plus complet. Inspirez-vous aussi des commentaires que je laisse, je rappelle que jâ€™attends un code commentÃ© pour lâ€™Ã©valuationÂ !

``` javascript
// Or
const buttonGold = document.getElementById('button-gold');
buttonGold.addEventListener('change', () => {
  // Quand lâ€™utilisateur clique sur le bouton "Or", je mets Ã  jour mon filtre CQL
  sourceDeals.updateParams({ 'CQL_FILTER' : 'gold=true' });
});

// Argent
const buttonSilver = document.getElementById('button-silver');
buttonSilver.addEventListener('change', () => {
  sourceDeals.updateParams({ 'CQL_FILTER' : 'silver=true' });
});
```

Testez lâ€™application en cliquant alternativement sur les boutons radio de Or et Argent. Si les deux couches sont diffÃ©rentes, super, Ã§a fonctionneÂ !

Maintenant que vous avez compris comment faire, faites les Ã©tapes suivantes (et souvenez-vous que câ€™est Ã  vous que je demande, pas Ã  Chat-GPT, je vous ai quand mÃªme dÃ©jÃ  bien mÃ¢chÃ© le travail avec lâ€™exemple ci-dessusÂ !).

-   on a crÃ©Ã© un filtre fonctionnel pour Or et Argent, maintenant **faites la mÃªme chose pour toutes les autres options**

-   quand vous avez terminÃ©, rajoutez une option "Tous" avec la valeur `value="all"` et faites en sorte quâ€™il affiche tous les deals (je vous ai mis des indices ci-dessous si vous avez du mal mais essayez dâ€™abord de rÃ©flÃ©chir sans)

::: {.callout-note collapse="true"}
## Indice 1 - ajouter lâ€™option "Tous"

Souvenez vousÂ : si vous voulez ajouter un Ã©lÃ©ment Ã  lâ€™interface, commencez par `index.html`.
:::

::: {.callout-note collapse="true"}
## Indice 2 - filtrer "Tous"

Comme on Ã©crit du code JavaScript, on doit le faire dans `main.js`. Comme pour les autres options, vous pouvez rÃ©cupÃ©rer le bouton radio avec `.getElementById()` puis lâ€™Ã©couter avec `.addEventListener()`.

Pour ce qui est du filtre CQLÂ : si on veut tous les deals, il suffit que notre filtre soit **vide**. Donc vous devriez avoir quelque part une chaÃ®ne de caractÃ¨res (*string*) vide.
:::

Une fois que câ€™est terminÃ© et que vous avez un beau menu fonctionnel pour filtrer vos couches, on peut passer Ã  la suiteÂ !

### Des cercles proportionnels avec un flux WFS

On commence Ã  avoir fait le tour des interactions basiques avec les flux WMS, qui pour rappel nous envoient des images. Mais, si vous vous souvenez bien, on a aussi Ã©voquÃ© dans le premier cours la possibilitÃ© de rÃ©cupÃ©rer non pas une image mais des **vecteurs grÃ¢ce aux flux WFS**. Câ€™est ce qui va nous intÃ©resser maintenantÂ : notre objectif va Ãªtre dâ€™afficher notre couche `deals_by_country_centroid` et de la styliser pour afficher des cercles proportionnels. Et vous allez voir que rÃ©cupÃ©rer une couche WFS avec OpenLayers, câ€™est du gÃ¢teau.

Je vous donne la structure du code Ã  Ã©crire dans `main.js`. Nâ€™oubliez pas que les Ã©lÃ©ments encadrÃ©s par des chevrons `"<un_truc>"` doivent Ãªtre remplacÃ©s par une vraie valeur. Par exemple, si je vous Ã©cris `const formation = "<ma_formation>"`, vous devrez mettre dans votre code `const formation = "geonum"`. FacileÂ ! VoilÃ  donc le snippet de baseÂ :

``` javascript
// Nâ€™oubliez pas de mettre un commentaire pour mâ€™expliquer ce que vous faites
const sourceCentroid = new VectorSource({
  format: new GeoJSON(),
  url: '<mon_flux_wfs>'
});

const layerCentroid = new VectorLayer({
  source: sourceCentroid,
});
```

â€¦ et les imports Ã  ajouter tout en haut du fichierÂ :

``` javascript
import VectorSource from 'ol/source/Vector';
import GeoJSON from 'ol/format/GeoJSON.js';
import VectorLayer from 'ol/layer/Vector';
```

Vous remarquez que vous avons un Ã©lÃ©ment `<mon_flux_wms>` Ã  remplacer. Pour trouver lâ€™URL de ce flux, allez dans votre interface GeoServer, sÃ©lectionnez "PrÃ©visualisation de la couche". Cette fois, au lieu de choisir "OpenLayers" (qui nous donne le flux WMS), allez dans la colonne "Tous les formats" et sÃ©lectionnez GeoJSON. **Je rappelle quâ€™on ne travaille plus sur la couche `deals` mais bien sur la couche `deals_by_country_centroid`.** Il ne vous reste plus quâ€™Ã  copier lâ€™URL dans votre navigateurÂ : câ€™est la valeur de `url` dans votre `VectorSource()`.

::: {.callout-note collapse="true"}
## Oups, jâ€™ai oubliÃ© de retirer les chevrons "\<" en collant mon url

![](https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExbm84eWJjMWNlNnF4d2lxdjFhYnJoYmRkM3RweWZ5M2Q3ZWlya3hidSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/eUrE2DuMKOE0g/giphy.webp){fig-alt="GIF : Justine Timberlake blasÃ©" fig-align="center"}
:::

Il ne reste plus quâ€™une seule Ã©tape pour afficher la couche sur la carte. Je vous laisse trouver laquelleÂ !

::::: {.callout-note collapse="true"}
## Allez, un petit indiceÂ ?

Vous lâ€™avez dÃ©jÃ  fait plusieurs fois dans le TP prÃ©cÃ©dent et celui-ci, et câ€™est souvent une Ã©tape quâ€™on oublie.

![](https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExNmN4NWdqczB6enZtdzJwZW5wazBwbjducTA2aDhnMm1qNWF1dm10eiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/MZ9nZGQn1nqBG/200.webp){fig-alt="GIF : Mr Bean malicieux" fig-align="center"}

:::: {.callout-note collapse="true"}
## Je ne trouve vraiment pasâ€¦

![](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExZHl0dHJvajQ2cm9ldGxhcWtvaXRobmhtZGpmeWZlNjBxM3V3bjBwciZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/w89ak63KNl0nJl80ig/giphy.webp){fig-alt="GIF : The Office, agent sous couverture" fig-align="center" width="240"}

::: {.callout-note collapse="true"}
## Promis, jâ€™ai vraiment cherchÃ©Â !

Bon, dâ€™accord. Dites-moi, comment se porte lâ€™attribut `layers` de votre objet `map`Â ?

![](https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExNTMxd2h6aDBvczhuandzdzRnNTYwYzRhOW14NW53OXo5Y2tqYmk1aiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/i7WbuFkyAZ8HUAIn8E/giphy.webp){fig-alt="GIF : Gollum donne la rÃ©ponse de lâ€™Ã©nigme" fig-align="center" width="200"}
:::
::::
:::::

Une fois cette Ã©tape complÃ©tÃ©e, la couche devrait apparaÃ®tre sur votre carte. SuperÂ ! Par contre, Ã§a ressemble certainement Ã  des cercles blancs, un peu transparents, avec un contour bleu. Et surtout, ce ne sont pas des cercles proportionnelsÂ !

Heureusement, vous avez Ã©tÃ© bien attentifs pendant vos cours de Leaflet et vous avez dÃ©jÃ  stylisÃ© des couches Ã  partir de donnÃ©e GeoJSON, Ã§a devrait Ãªtre super facile pour vous. Comme la documentation GeoServer nâ€™est pas trÃ¨s claire sur ce point, je vous donne un snippet et je vais vous demander de lâ€™ajuster un peu pour vÃ©rifier que vous comprendez bien qui fait quoi.

Dâ€™abord, on importe les Ã©lÃ©ments de style dont on va avoir besoinÂ :

``` javascript
import {Circle, Fill, Stroke, Style} from 'ol/style.js';
```

On commence par crÃ©er un style "pas proportionnel" quâ€™on stocke dans la constante `styleCentroid`.

``` javascript
const styleCentroid = new Style({
  image: new Circle({
    radius: 40,
    fill: new Fill({ color: 'white' }),
    stroke: new Stroke({ color: 'blue', width: 5 }),
  }),
});
```

Nâ€™oubliez pas dâ€™appeler votre style dans la propriÃ©tÃ© `style` de votre `VectorLayer` ou bien la couche ne changera pas.

``` javascript
const layerCentroid = new VectorLayer({
  source: sourceCentroid,
  style: styleCentroid    // On a rajoutÃ© cette ligne
});
```

Attention Ã  lâ€™ordre dans lequel vous ajoutez les Ã©lÃ©ments dans le code. Nâ€™oubliez pas que pour appeler une constante (ou une variable) comme `styleCentroid`, il faut avoir dÃ©fini celle-ci avantÂ !

Regardez Ã  quoi ressemble la couche maintenant quâ€™on lui a donnÃ© un style. Câ€™est moche, heinÂ ? Et bien câ€™est Ã  vous de la rendre belle. Modifiez le code pour obtenir quelque chose qui ressemble Ã  Ã§aÂ :

![](media/ol_styling_circles.png){fig-alt="Couche de cercles oranges sur OpenLayers" fig-align="center"}

Notez que les cercles ne sont pas entiÃ¨rement opaques. Prenez le temps de vous appliquer, cela vous servira de base pour la suite. **Quand vous avez terminÃ©**, vous pourrez utiliser ce snippet pour afficher des cercles proportionnels.

``` javascript
function getStyleCentroid(feature) {
  const nDeals = feature.get('n_deals');
  const rayon = Math.sqrt(nDeals) * 0.01;
  const style = new Style({
    image: new Circle({
      radius: rayon,
      fill: new Fill({ color: 'white' }),
      stroke: new Stroke({ color: 'blue', width: 5 }),
    }),
  });
  return style;
}

const layerCentroid = new VectorLayer({
  source: sourceCentroid,
  style: getStyleCentroid,
});
```

Vous noterez que la diffÃ©rence principale ici est quâ€™on appelle une **fonction** et non une constante, et que cette fonction prend `feature` en argument. En fait, ce quâ€™il se passe, câ€™est que la fonction va regarder chaque objet de ma couche (chaque *feature*) et appliquer les Ã©tapes quâ€™on a dÃ©finies Ã  lâ€™intÃ©rieur.

-   on lit un attribut de notre `feature` avec la mÃ©thode `.get()`

-   on calcule un rayon

-   on dÃ©finit notre style comme prÃ©cÃ©demment, mais au lieu dâ€™Ãªtre une valeur fixe, notre propriÃ©tÃ© `radius` prend la valeur de notre rayon

Je suis restÃ©e volontairement vague dans ce cas pour ne pas vous souffler toutes les rÃ©ponses. Comme prÃ©cÃ©demment, vous allez devoir modifier le snippet de code pour rendre la couche un peu plus Ã©lÃ©gante. Je vous montre mon exemple, essayez de le reproduire le plus fidÃ¨lement possibleÂ :

![](media/ol_styling_proportional.png){fig-alt="Couche de cercles proportionnels dans OpenLayers" fig-align="center"}

Une fois que câ€™est terminÃ©, il reste un dernier exercice Ã  faire avec ces cercles proportionnels. Vous aurez compris quâ€™ici, nos cercles sont proportionnels au nombre de deals qui sont enregistrÃ©s dans le pays. **Maintenant, crÃ©ez une couche de cercles proportionnels en vous basant sur la surface total couverte par les deals dans chaque pays.**

On arrive sur la fin du TP et vous commencez (jâ€™espÃ¨re) Ã  bien comprendre comment fonctionne notre application donc je ne vous donne pas dâ€™indices. Faites juste attention Ã  bien faire varier la taille des cercles petit Ã  petitÂ : si jamais votre navigateur essaie de dessiner des cercles trop grands, vous avez des chances de faire crasher votre ordinateur (Ã§a mâ€™est *peut-Ãªtre* arrivÃ© pendant mes tests et ce serait dommage que Ã§a vous arrive aussi).

## Lâ€™Ã©tape finaleÂ !

Enfin lâ€™Ã©tape finale du TPÂ ! Une fois que votre application fonctionne et quâ€™elle vous convient, nâ€™oubliez **SURTOUT PAS** de la buildÂ ! Pour le moment, vous travaillez dans ce quâ€™on appelle un environnement de dÃ©veloppement mais quand vous Ãªtes prÃªts Ã  pousser une application en production, il faut la build. On lâ€™a dÃ©jÃ  fait au dÃ©but du TP prÃ©cÃ©dent mais je vous remets les instructions ici parce que je suis bien sympa (et que vous avez sÃ»rement le cerveau en compote aprÃ¨s tout Ã§a)Â :

-   ouvrez un terminal Ã  la racine de votre projet

-   utilisez la commande `cd app` pour vous dÃ©placer dans le dossier de votre application

-   utilisez la commande `npm run build` pour build votre application, le rÃ©sultat sera mis dans le dossier `/dist`

-   allez sur <http://localhost/> et vÃ©rifiez que vous voyez bien la derniÃ¨re version de votre application

Et voilÃ , bien jouÃ©Â ! Vous nâ€™avez plus quâ€™Ã  mâ€™appeler pour me montrer le rÃ©sultat.

![](https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExcDJ1Nzd4b2tkbzZicmZ5eXBycG1wOGZ1ZzZncW5obzh2MTcwMDc1ZSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/AQRapWCgC7dThyVEYb/giphy.webp){fig-alt="GIF : Solaire, Praise the Sun" fig-align="center"}

## Jâ€™ai fini en avance, quâ€™est-ce que je faisÂ ?

DÃ©jÃ , bravo, câ€™Ã©tait un gros TP. Sâ€™il reste du temps, je vais rajouter ici petit Ã  petit des tÃ¢ches pendant le TP qui vous permettront dâ€™aller un peu plus loin et de prÃ©parer votre code pour lâ€™Ã©valuation. En attendantÂ :

-   vÃ©rifiez bien lâ€™intendation de votre code

-   vÃ©rifiez aussi quâ€™il soit bien commentÃ©

-   amÃ©liorez le style des couches WMS comme WFS pour avoir une carte harmonieuse et un peu stylÃ©e

-   ajoutez un titre Ã  votre page

-   ajoutez une Ã©chelle (avec OpenLayers)

## RajoutÃ© Ã  la fin MAIS Ã€ FAIRE QUAND MÃŠMEÂ : une table attributaire personnalisÃ©e

On va se rÃ©intÃ©resser Ã  notre couche WMS "deals" et Ã  sa table attributaire (souvenez-vousÂ : [Interroger une couche WMS et afficher les rÃ©sultats]). Je vous remets notre code ici pour vous rappeler quels Ã©lÃ©ments permettent de rÃ©cupÃ©rer la table attributaire. Attention au nom de vos couches et de vos sources, ce ne sont peut-Ãªtre pas les mÃªmes que les miensÂ !

``` javascript
map.on('singleclick', (event) => {
  const coord = event.coordinate;
  const res = map.getView().getResolution();
  const proj = 'EPSG:3857';
  const parametres = {'INFO_FORMAT': 'text/html'};

  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);

  if (url) {
    fetch(url)
      .then((response) => response.text())
      .then((html) => {
        document.getElementById('attributes').innerHTML = html;
       });
  }
});
```

Faites attention Ã  cet Ã©lÃ©mentÂ :

``` javascript
const parametres = {'INFO_FORMAT': 'text/html'};
```

Notez quâ€™on demande en fait Ã  notre GeoServer de nous donner la **rÃ©ponse** de notre **requÃªte** au format **text/html**. Câ€™est sympathique, mais difficile Ã  customiser et surtout pas super pratique quand la table attribuaire est LONGUE. Heureusement, on peut rÃ©cupÃ©rer le rÃ©sultat au format JSON qui sera bien pratique pour customiser notre table.

Comme toujours, quand on souhaite ajouter un nouvel Ã©lÃ©ment Ã  notre carte, il faut quâ€™on commence par Ã©crire du HTML. On va modifier notre div `id="attributes"` pour y ajouter une table. RÃ©cupÃ©rez le code ci-dessous et regardez la diffÃ©rence, vous allez comprendre.

``` javascript
<div id="attributes" class="menu">
  <!-- Je crÃ©e une table -->
  <table>
    <!-- On utilise lâ€™Ã©lÃ©ment tr pour crÃ©er une ligne : tr = table row -->
    <tr>
      <!-- On utilise les Ã©lÃ©ments th (table header) pour crÃ©er les headers de nos trois colonnes -->
      <th>Deal ID</th>
      <th>Creation date</th>
      <th>Country</th>
    </tr>
    <!-- On utilise lâ€™Ã©lÃ©ment tr pour crÃ©er une AUTRE ligne : tr = table row -->
    <tr>
      <!-- On crÃ©e trois colonnes vides avec td -->
      <td>â€¦</td>
      <td>â€¦</td>
      <td>â€¦</td>
    </tr>
  </table>
</div>
```

Vous devriez maintenant voir apparaÃ®tre une table dans votre `div`. Elle est austÃ¨re, dâ€™accord, mais vous pourrez la styliser aprÃ¨s. Pour le moment, on va faire avec. Regardez bien mes commentaires pour comprendre comment est structurÃ© le code. Regardez bien ces trois Ã©lÃ©mentsÂ :

``` html
      <td>â€¦</td>
      <td>â€¦</td>
      <td>â€¦</td>
```

Vous comprenez sÃ»rement quâ€™on souhaite remplacer ces "â€¦" par des valeurs lorsquâ€™on clique sur un point de la couche. Il va donc falloir modifier cet Ã©lÃ©ment HTML avec nos fonctions JavaScript. Souvenez-vous quâ€™on utilise les identifiants pour retrouver les Ã©lÃ©ments HTML avec `.getElementById()`. DoncÂ :

``` html
      <td id="table-deal-id">â€¦</td>
      <td id="table-creation-date">â€¦</td>
      <td id="table-country">â€¦</td>
```

Maintenant quâ€™on a nos Ã©lÃ©ments, il va falloir les remplir. Retournez chercher votre mÃ©thode `map.on()` dans votre code, on va devoir lâ€™amÃ©liorer un peu.

``` javscript
map.on('singleclick', (event) => {
  const coord = event.coordinate;
  const res = map.getView().getResolution();
  const proj = 'EPSG:3857';

  const parametres = { 'INFO_FORMAT': 'application/json' } // On a changÃ© un truc ici

  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);

  if (url) {
    fetch(url)
      .then((response) => response.text())
      .then((json) => { // On a aussi changÃ© un truc ici et dans la fonction
        const obj = JSON.parse(json);
        console.log(obj);
      });
  }
});
```

Testez votre couche et regardez le rÃ©sultat dans la console. Si tout a fonctionnÃ©, vous devriez voir un objet JavaScriptÂ ! DÃ©pliez-le et prenez le temps de lâ€™explorer dans votre console pour comprendre ce que vous regardez. Lâ€˜information qui nous intÃ©resse est quelque part dans `features`. VoilÃ  ce quâ€™on doit faire avec la donnÃ©eÂ :

-   vÃ©rifier quâ€™on a bien cliquÃ© sur une feature sur la carte (en JavaScript, Ã§a demande de vÃ©rifier quâ€™on a bien de la donnÃ©e dans `features`)

-   rÃ©cupÃ©rer la `feature` sur laquelle jâ€™ai cliquÃ© pour pouvoir accÃ©der Ã  ses `properties`

-   rÃ©cupÃ©rer mes cellules pour remplacer leur contenu

-   remplacer le contenu des cellules de ma table avec les `properties`

On va procÃ©der petit Ã  petit. Dâ€™abord, on **vÃ©rifie quâ€™on a bien une feature dans `feature`**Â :

``` javascript
  if (url) {
    fetch(url)
      .then((response) => response.text())
      .then((json) => { // On a aussi changÃ© un truc ici et dans la fonction
        const obj = JSON.parse(json);
        if (obj.features[0]) {
          console.log("Jâ€™ai cliquÃ© sur une featureÂ !");
        } else {
          console.log("Jâ€™ai cliquÃ© Ã  cÃ´tÃ©â€¦");
        }
      });
  }
```

On utilise une condition `if` pour tester la prÃ©sence dâ€™une feature dans `obj`. `obj.features[0]` peut se traduire parÂ : "RÃ©cupÃ¨re mon tableau `feature` de mon `obj` et prends le premier Ã©lÃ©ment". La condition regarde simplement si `feature[0]` est vide ou non. Si ce nâ€™est pas vide, on a reÃ§u quelque chose, on a donc cliquÃ© sur une feature. Au contraire, si câ€™est vide, câ€™est quâ€™on a cliquÃ© Ã  cÃ´tÃ©. Testez la fonction avant de passer Ã  la suite.

Si on a bien rÃ©cupÃ©rÃ© une `feature`, cela veut dire quâ€™on peut rÃ©cupÃ©rer ses `properties`. Il suffit dâ€™ajouter au bon endroit de la fonction les deux lignes suivantesÂ :

``` javascript
const properties = obj.features[0].properties;
console.log(properties);
```

Vous commencez Ã  comprendre comment on accÃ¨de Ã  un Ã©lÃ©ment dans un objet JavaScript. Il suffit dâ€™appeler la propriÃ©tÃ© quâ€™on veut avec `.<propriÃ©tÃ©>`. Regardez comment est structurÃ© votre objet `properties` dans la console du navigateur. Maintenant, modifiez la ligne `console.log(properties);` pour afficher la propriÃ©tÃ© `target_country`. Quand câ€™est rÃ©ussi, passez Ã  la suiteÂ !

TrÃ¨s bien, on sait maintenant rÃ©cupÃ©rer des propriÃ©tÃ©s. Il ne nous reste plus quâ€™Ã  modifier le HTML de notre document en consÃ©quence en utilisant `.innerHTML`Â ! Je vous donne le code pour la colonne `deal_id` et je vous laisse complÃ©ter le code pour les deux autres colonnes.

``` javascript
  if (url) {
    fetch(url)
      .then((response) => response.text())
      .then((json) => {
        const obj = JSON.parse(json);
        if (obj.features[0]) {
          console.log("Jâ€™ai cliquÃ© sur une featureÂ !");
          const properties = obj.features[0].properties;
          console.log(properties);
          // On affiche deal_id dans notre table
          document.getElementById('table-deal-id').innerHTML = properties.deal_id;
        } else {
          console.log("Jâ€™ai cliquÃ© Ã  cÃ´tÃ©â€¦");
          // On a cliquÃ© "nulle part" donc on remet des â€¦ dans la colonne "deal_id"
          document.getElementById('table-deal-id').innerHTML = "";
        }
      });
  }
```

Testez votre application. Normalement, Ã§a marcheÂ ! Quand vous cliquez sur une feature, vous devriez rÃ©cupÃ©rer son ID. VoilÃ  comment on crÃ©e une table customisÃ©e pour interroger une coucheÂ ! **Maintenant, Ã  vous de complÃ©ter les deux autres colonnes.** Une fois que vous avez rÃ©ussi, ajoutez une colonne qui montre la valeur de `mineral_resources` pour le deal sur lequel vous cliquez. Et quand Ã§a aussi Ã§a fonctionne, prenez quelques minutes pour styliser votre tableÂ ! Google est votre ami (et ok, pourquoi pas ChatGPT si vous y tenez vraiiiiment, Ã§a ne me dÃ©range pas si câ€™est pour du CSS comme `<table>` commence Ã  Ãªtre complexe, mais on utilise lâ€™IA intelligemment svp).

## Jâ€™ai fini Ã§a aussiÂ !

FantastiqueÂ ! Eh bien maintenant, dÃ©brouillez-vous pour [ajouter une Ã©chelle Ã  votre carte](https://openlayers.org/en/latest/examples/scale-line.html). Ã‡a devrait vous occuper un moment, jâ€™espÃ¨re. Je vous donne Ã§a, Ã  vous de le mettre au bon endroitÂ :

``` javascript
import ScaleLine from 'ol/control/ScaleLine.js';
```

Un autre morceau, pour crÃ©er lâ€™objet "Ã©chelle"Â :

``` javascript
const scaleline = new ScaleLine();
```

Et enfin, trouvez comment ajouter Ã§a Ã  votre code existantÂ :

``` javascript
const map = new Map({
  controls: [scaleline],
});
```

Et voilÃ Â !

## Bon, ben jâ€™ai AUSSI une Ã©chelle sur ma carteâ€¦

BravoÂ ! Vous pouvez rÃ©pÃ©ter [Lâ€™Ã©tape finaleÂ !] pour build votre application. Ensuite, je vous conseille de commencer Ã  ajouter Ã  votre carte des Ã©lÃ©ments dont vous avez besoin pour vos projets GeoNum. Vous pourriez vouloir par exemple un curseur temporel, des tooltips, etc. Commencez par faire des recherches parmi les [exemples dâ€™OpenLayers](https://openlayers.org/en/latest/examples/) mais aussi dans les extensions disponibles sur [ol-ext](https://viglino.github.io/ol-ext/) histoire de faire un tour des possibilitÃ©s.

Et suivant le temps quâ€™on a, on peut Ã©ventuellement commencez Ã  regardez QGIS Server ensemble pendant le TP, sinon je vous ajouterai une petite notre sur le site si jamais vous prÃ©fÃ©rez lâ€™utiliser pour vos projets. Quoi quâ€™il en soit, vous ne serez pas notÃ©s dessusÂ !

## Cette fois, câ€™est vraiment finiÂ !

Merci pour votre attentionÂ !

![](https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExMjlteWxjN3JjYzU4aXBmY3huODRxYmk4ZGg5MWdza216MDdhNzlyNyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/ZfK4cXKJTTay1Ava29/giphy.webp){fig-alt="GIF : The Office Thank You" fig-align="center"}
