---
title: "Enrichir ma carte en fonctionnalitÃ©s"
subtitle: "Enrichir ma carte OpenLayers en fonctionnalitÃ©s en utilisant les capabilities de GeoServer et plus de fonctions et objets OpenLayers."
---

## Objectifs

-   CrÃ©er un menu dâ€™affichage des couches

<!-- -->

-   Interroger une couche WMS et afficher les rÃ©sultats

-   Filtrer une couche WMS

-   Lire un flux WFS et afficher la gÃ©omÃ©trie

-   CrÃ©er un curseur dâ€™Ã©volution temporelle

-   Ajouter une Ã©chelle Ã  la carte

-   Polir un peu lâ€™interface de lâ€™application avec du CSS

-   Pour aller plus loin, apprendre Ã  utiliser des plugins OpenLayers

## Cours

Aujourdâ€™hui, câ€™est de la pratique. Mâ€™entendre parler pendant des heures, câ€™est finiÂ !

![](https://kaamelott-gifboard.fr/gifs/on-en-a-gros.gif){fig-alt="GIF : Kaamelott on en a gros" fig-align="center" width="427"}

## TP - Faire une carte interactive sur le thÃ¨me de lâ€™exploitation miniÃ¨re et ses impacts nÃ©gatifs sur les populations locales

::: callout-important
Ce TP se base sur lâ€™architecture dÃ©ployÃ©e et le code Ã©crit au cours du TP "OpenLayers & GeoServer".
:::

Câ€™est un titre Ã  rallonge, mais voici en gros dans quelle direction la donnÃ©e de la Land Matrix va nous permettre de partir. Nous allons nous baser sur tout ce qui a Ã©tÃ© crÃ©Ã© lors du TD "OpenLayers & GeoServer". Si vous nâ€™avez pas pu suivre le TD ou que vous avez Ã©garÃ© vos fichiers, merci de le signaler maintenant.

### CrÃ©er un menu dâ€™affichage des couches

Si jamais vous nâ€™aviez pas eu le temps dâ€™afficher plus dâ€™une couche, voici le code avec lequel jâ€™ai commencÃ© ce TP. **Nâ€™oubliez pas de remplacer les Ã©lÃ©ments comme lâ€™adresse de votre GeoServerÂ !** Et si votre application affiche dÃ©jÃ  la couche "deals" et "deals_by_country", inutile de copier mon code, câ€™est plus intÃ©ressant de repartir du votre.

**index.html**

``` html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="https://openlayers.org/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Transition Minerals</title>
  </head>
  <body>
    <div id="map"></div>
    <script type="module" src="./main.js"></script>
  </body>
</html>
```

**style.css**

``` css
@import "node_modules/ol/ol.css";

html, body {
  margin: 0;
  height: 100%;
}
#map {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 100%;
}
```

**main.js**

``` javascript
import './style.css';
import {Map, View} from 'ol';
import { ImageWMS } from 'ol/source';
import TileLayer from 'ol/layer/Tile';
import ImageLayer from 'ol/layer/Image';
import OSM from 'ol/source/OSM';

// WMS de mon GeoServer
const geoserverWms = 'http://localhost:8080/geoserver/land_matrix/wms'

// Layer: Fond de carte OSM
const layerOsm = new TileLayer({ source: new OSM() });

// Layer: deals by country
const layerDealsByCountry = new ImageLayer({
  source: new ImageWMS({
    url: geoserverWms,
    params: { 'LAYERS' : 'land_matrix:deals_by_country' },
    serverType: 'geoserver',
  })
});

// Layer: deals
const sourceDeals = new ImageWMS({
  url: geoserverWms,
  params: { 'LAYERS' : 'land_matrix:deals' },
  serverType: 'geoserver',
});

const layerDeals = new ImageLayer({
  source: sourceDeals
});

// Map
const map = new Map({
  target: 'map',
  layers: [ layerOsm, layerDealsByCountry, layerDeals ],
  view: new View({
    center: [0, 0],
    zoom: 2
  })
});
```

On souhaite maintenant crÃ©er un menu avec des cases de type "checkbox" qui vont nous permettre de choisir si on veut afficher ou masquer une couche. On doit commencer par crÃ©er cet Ã©lÃ©ment dans lâ€™interface en modifiant `index.html`.

-   DÃ©finissez une `<div>` dans laquelle on souhaite afficher notre menu de couches et positionnez-la avec du CSS

-   Ajoutez Ã  lâ€™intÃ©rieur un input de type checkbox avec la balise `<input type="checkbox"/>` et donnez lui un label avec le nom de la couche

Comme câ€™est la premiÃ¨re fois quâ€™on doit Ã©crire du HTML ensemble, je vous guide pas Ã  pas. Commencez par ouvrir `index.html` et ajouter sous la `div` de votre carte (la div `map`) une autre div, comme ceciÂ :

``` html
<div id="layers" class="menu"></div>
```

On crÃ©e une nouvelle `div` dont lâ€™identifiant est `layers`, ce qui nous permettra de la retrouver par la suite. On lui a aussi ajoutÃ© une classe quâ€™on appelle `menu` et qui nous permettra dâ€™appliquer un seul style Ã  tous nos Ã©lÃ©ments de menu. Si câ€™est un peu flou maintenant, vous comprendrez plus tard en ajoutant dâ€™autres menus.

Comme notre `div` est vide, on ne la voit pas. Ã‡a va Ãªtre difficile de la positionner ailleurs sur la carte. Jâ€™ai lâ€™habitude de mettre un peu nâ€™importe quoi Ã  lâ€™intÃ©rieur, juste le temps de rÃ©gler mon CSS correctement. Ma div ressemble donc Ã Â :

``` html
<div id="layers" class="menu">cthulhu fhtagn</div>
```

On pourra retirer le texte aprÃ¨s. Vous remarquerez quâ€™on ne voit toujours pas notre texte. Essayez de rafraÃ®chir la page - vous devriez le voir tout en haut Ã  gauche de lâ€™Ã©cran avant que la carte ne le recouvreÂ ! Câ€™est normal, nous nâ€™avons pas "positionnÃ©" notre Ã©lÃ©ment. Ce nâ€™est pas un cours de CSS donc on ne rentrera pas dans les dÃ©tails. Ouvrez `styles.css` et ajoutez le code suivantÂ :

``` css
.menu {
  position: absolute;
}
```

On sÃ©lectionne toutes les balises html avec la classe `menu` et on leur applique un positionnement absolu. Sauvegardez et vous devriez voir apparaÃ®tre le texte. SuperÂ ! Maisâ€¦ câ€™est moche et Ã§a ne ressemble pas DU TOUT Ã  un menu. Pas de souci, on y arrive. Ajoutez les Ã©lÃ©ments suivants (jâ€™ai commentÃ© le code pour vous aider Ã  comprendre)Â :

``` css
.menu {
  /* Positionnement dans le body */
  position: absolute;
  top: 20px;
  right: 20px;

  /* Padding */
  padding: 8px;

  /* Dimensions minimales */
  min-height: 80px;
  min-width: 160px;

  /* Rectangle blanc avec coins arrondis */
  background-color: white;
  border-radius: 8px;
}
```

Ah, câ€™est dÃ©jÃ  plus sympaÂ ! On va mÃªme pouvoir supprimer le texte de notre balise HTML dans `index.html`. En gros, voilÃ  ce que je fais avec ce code CSSÂ :

-   Jâ€™indique que lâ€™Ã©lÃ©ment a une position absolue dans le body (donc pas relative Ã  un Ã©lÃ©ment) et quâ€™il doit se trouver Ã  20 pixels du haut (`top`) et 20 pixels de la droite (`right`) de lâ€™Ã©cran.

-   Je donne un *padding*, une marge intÃ©rieur, Ã  mon Ã©lÃ©ment de menu. Pour mieux comprendre, essayez de supprimer cette ligne et regardez ce qui change.

-   Je donne une hauteur et une largeur minimales Ã  mon Ã©lÃ©ment pour Ã©viter quâ€™il ne disparaÃ®sse quand il est vide. Par dÃ©faut, mon Ã©lÃ©ment aurait grandi et rÃ©trÃ©ci avec son contenu.

-   Jâ€™ai donnÃ© un peu de style Ã  mon menu en lui donnant un fond blanc et des coins arrondis.

VoilÃ  globalement le niveau maximum de difficultÃ© du CSS que je vais vous demander pour styliser votre application, mais vous pouvez Ã©videmment allez plus loinÂ !

Maintenant quâ€™on a un menu, il va falloir ajouter la checkbox qui permettra dâ€™afficher ou masquer ma couche. Retournez dans `index.html` et ajoutez la balise `<input>` et son `<label>` dans notre `<div id="layers>`, comme ceciÂ :

``` html
<div id="layers" class="menu">
  <input type="checkbox" id="checkbox-countries" name="checkbox-countries" checked />
  <label for="checkbox-countries">Deals by countries</label>
</div>
```

VÃ©rifiez que vous pouvez cliquer sur la checkbox pour la cocher/dÃ©cocher. Lâ€™interface est prÃªteÂ ! Il faut maintenant quâ€™on parvienne Ã  dire Ã  notre application quâ€™il faut afficher ou masquer la couche deals_by_country en fonction.

ğŸ¤” **On doit dâ€™abord se demander comment sâ€™y prendre pour masquer une couche dans OpenLayers.**

On va se servir des mÃ©thodes qui sont disponibles pour tous les objets `Layer` de OpenLayers. La [documentation](https://openlayers.org/en/latest/apidoc/module-ol_layer_Base-BaseLayer.html#setVisible) nous apprend lâ€™existence de la mÃ©thode `setVisible()`. VoilÃ  ce quâ€™on nous en ditÂ :

![](media/set_visible_ol.png){fig-alt="Documentation de la mÃ©thode setVisible() OpenLayers" fig-align="center"}

La mÃ©thode `setVisible()` prend un argument `visible`. Cet argument est de type "boolean", il peut donc prendre la valeur `true` ou `false`. On va faire le test et utiliser cette fonction pour faire disparaÃ®tre notre couche. Allez dans `main.js` et ajouter cette ligne Ã  la fin de votre scriptÂ :

``` javascript
layer_deals_by_country.setVisible(false);
```

**AttentionÂ !** `layer_deals_by_country` est le nom de la variable dans laquelle jâ€™ai crÃ©Ã© ma couche "deals_by_country". Si vous avez nommÃ© votre couche diffÃ©remment, nâ€™oubliez pas de changer le nomÂ !

Normalement, la couche ne devrait plus Ãªtre visible sur la carte. Super, la mÃ©thode a fonctionnÃ©Â ! Il ne nous reste plus quâ€™Ã  "connecter" cette mÃ©thode Ã  notre Ã©lÃ©ment checkbox.

On lâ€™a dÃ©jÃ  vu dans le TP Serveurs cartographiques (lorsquâ€™on affichait la lÃ©gende des couches), il est possible de trouver un Ã©lÃ©ment HTML et de le modifier en utilisant du JavaScript. Pour trouver un Ã©lÃ©ment, le plus facile est de rechercher son identifiant `id`. Ajoutez en bas de `main.js`Â :

``` javascript
const checkbox_countries = document.getElementById('checkbox-countries');
console.log(checkbox_countries);
```

Sauvegardez et allez dans la console de votre navigateur. Vous devriez voir apparaÃ®tre votre tag `<input>` dans la console. Si vous le survolez avec la souris, la checkbox devrait Ãªtre passÃ©e en surbrillance. Si Ã§a fonctionne, parfait ! Ã‡a veut dire quâ€™on arrive bien Ã  rÃ©cupÃ©rer notre Ã©lÃ©ment de checkbox. Maintenant, on souhaite exÃ©cuter du code lorsque son statut "checked" change. Pour cela, on doit "Ã©couter" la checkbox pour savoir si lâ€™Ã©vÃ¨nement "change" a eu lieu.

``` javascript
const checkboxCountries = document.getElementById('checkbox-countries');

checkboxCountries.addEventListener('change', (event) => {
  if (event.currentTarget.checked) {
    // On fait des trucs quand la checkbox est checkÃ©e
    console.log("Checked");
  } else {
    // On fait des trucs quand la checkbox nâ€™est PAS checkÃ©e
    console.log("Pas checked");
  }
});
```

-   `addEventListener` indique quâ€™on souhaite "Ã©couter" les Ã©vÃ¨nements de notre checkbox. On prÃ©cise le type dâ€™Ã©vÃ¨nement avec le premier paramÃ¨tre, `'change'`.

-   La condition `if` vÃ©rifie si notre checkbox est checkÃ©e ou non. On rÃ©cupÃ¨re cette information grÃ¢ce Ã  `event.current.checked`. Si cette condition est `true`, on affiche "Checked" dans la console. Si cette condition est `false`, on affiche "Pas checked".

EssayezÂ ! Cliquez sur la checkbox et surveillez votre console. On voit bien sâ€™afficher les messages. On y est presqueÂ ! Maintenant, au lieu dâ€™afficher du texte, on souhaite afficher la couche quand la condition est `true` et la masquer quand la condition est `false`.

``` javascript
const checkboxCountries = document.getElementById('checkbox-countries');

checkboxCountries.addEventListener('change', (event) => {
  if (event.currentTarget.checked) {
    // On fait des trucs quand la checkbox est checkÃ©e
    layer_deals_by_country.setVisible(true);
  } else {
    // On fait des trucs quand la checkbox nâ€™est PAS checkÃ©e
    layer_deals_by_country.setVisible(false);
  }
});
```

::: callout-caution
## Pensez bien Ã â€¦

-   Changer le nom de la couche `layer_deals_by_country` si vous nâ€™avez pas appelÃ© votre couche comme Ã§a.

-   Supprimer la ligne `layer_deals_by_country.setVisible(false);` toute seule au dessus ou votre couche sera masquÃ©e par dÃ©faut au moment de charger la carte.
:::

VoilÃ , on peut dÃ©sormais afficher et masquer la couche Ã  volontÃ©Â !

![](https://media1.tenor.com/m/wn2_Qq6flogAAAAC/magical-magic.gif){fig-alt="GIF : Magic" fig-align="center" width="435"}

Ã€ vousÂ ! CrÃ©ez une autre checkbox qui permet dâ€™afficher ou masquer la couche deals. Jâ€™aimerais que cette checkbox soit **au-dessus** de la premiÃ¨reÂ !

::: callout-tip
Sauf indication contraire (via du CSS), les Ã©lÃ©ments HTML sont affichÃ©s dans lâ€™ordre dans lequel ils sont dÃ©clarÃ©s.

``` html
<div id="2"></div>
<div id="1"></div>
```

Dans cet exemple, ma div 1 sera plus bas que ma div 2. Ã‡a devrait vous aider !
:::

### Interroger une couche WMS et afficher les rÃ©sultats

On souhaite maintenant interroger la couche deals en cliquant dessus. Cette Ã©tape est plus compliquÃ©e que la prÃ©cÃ©dente car elle va nous demander dâ€™utiliser `fetch()`, on va donc lÃ -aussi procÃ©der petit Ã  petit pour bien comprendre ce quâ€™on fait. Ouvrez lâ€™exemple OpenLayers [WMS GetFeatureInfo (Image Layer)](https://openlayers.org/en/latest/examples/getfeatureinfo-image.html).

CommenÃ§ons par sâ€™intÃ©resser Ã  cette partie du codeÂ :

``` javascript
map.on('singleclick', function (evt) {
  document.getElementById('info').innerHTML = '';
  const viewResolution = /** @type {number} */ (view.getResolution());
  const url = wmsSource.getFeatureInfoUrl(
    evt.coordinate,
    viewResolution,
    'EPSG:3857',
    {'INFO_FORMAT': 'text/html'},
  );
  if (url) {
    fetch(url)
      .then((response) => response.text())
      .then((html) => {
        document.getElementById('info').innerHTML = html;
      });
  }
});
```

-   `.on('singleclick')` permet dâ€™exÃ©cuter une fonction lorsquâ€™on clique sur la carte.

-   `document.getElementById()` rÃ©cupÃ¨re lâ€™Ã©lÃ©ment 'info' dans lequel ils affichent leurs rÃ©sultats.

-   On rÃ©cupÃ¨re la rÃ©solution de la vue de la carte grÃ¢ce Ã  la mÃ©thode dans `viewResolution`. On a besoin de passer cette rÃ©solution dans la fonction suivante.

-   On rÃ©cupÃ¨re lâ€™url qui contient les informations de lâ€™Ã©lÃ©ment cliquÃ© avec la mÃ©thode `getFeatureInfoUrl()` de la source de donnÃ©es.

-   Si notre url est dÃ©finie, alors on utilise la fonction `fetch()` pour rÃ©cupÃ©rer la donnÃ©e Ã  partir de cette adresse.

-   `document.getElementById()` rÃ©cupÃ¨re Ã  nouveau lâ€™Ã©lÃ©ment 'info' et dÃ©finir la valeur de son `innerHTML` pour pouvoir afficher les rÃ©sultats.

CompliquÃ©Â ? Non, Ã§a va allerÂ ! On va tranquillement rÃ©Ã©crire cette fonction pour la couche `deals`. Pour rappel, voici comment jâ€™appelle la couche `deals` dans mon codeÂ :

``` javascript
const sourceDeals = new ImageWMS({
  url: geoserverWms,
  params: { 'LAYERS' : 'land_matrix:deals' },
  serverType: 'geoserver',
});

const layerDeals = new ImageLayer({
  source: sourceDeals
});
```

Je commence donc par exÃ©cuter une fonction lorsque je clique sur la carteÂ :

``` javascript
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");
});
```

Sauvegardez, gardez la console de votre navigateur ouverte et cliquez sur la carte pour vÃ©rifier que le message apparaÃ®t bien. Si câ€™est bon, on vient dâ€™apprendre comment exÃ©cuter des fonctions en cliquant sur la carteÂ ! On sait ensuite que dans lâ€™exemple ils utilisent la mÃ©thode `getFeatureInfoUrl()` de leur source de donnÃ©es pour rÃ©cupÃ©rer les informations des features. Ouvrez la [documentation de ImageWMS](https://openlayers.org/en/latest/apidoc/module-ol_source_ImageWMS-ImageWMS.html#getFeatureInfoUrl) on va en avoir besoin. VoilÃ  ce quâ€™elle nous dit au sujet de la mÃ©thode `fetFeatureInfoUrl()`Â :

![](media/get_feature_info_url_ol.png){fig-alt="Documentation getFeatureInfoUrl() dâ€™OpenLayers" fig-align="center"}

La mÃ©thode prend plusieurs paramÃ¨tresÂ :

-   `coordinate`, les coordonnÃ©es visÃ©es par le clic de lâ€™utilisateur

-   `resolution`, la rÃ©solution de la carte (liÃ©e Ã  la `view` de ma carte)

-   `projection`, le systÃ¨me de projection de la carteÂ : "EPSG:3857'"

-   `params`, un objet contenant plusieurs paramÃ¨tres comme le format dÃ©sirÃ© du rÃ©sultat ou encore les couches quâ€™on souhaite interroger

RÃ©cupÃ©rons ces Ã©lÃ©ments dans lâ€™ordre en commenÃ§ant par les coordonnÃ©es. Dans lâ€™exemple, ils rÃ©fÃ©rencent directement la source de coordonnÃ©es `evt.coordinate` dans la fonction mais Ã§a va un peu vite. Pour mieux comprendre, on va stocker les coordonnÃ©es de notre Ã©vÃ¨nement (= notre clic) dans une constante.

``` javascript
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");
  
  const coord = event.coordinate;
});
```

En fait, lâ€™Ã©vÃ¨nement 'singleclick' de la carte `map` permet de rÃ©cupÃ©rer les coordonnÃ©es du clic en accÃ©dant Ã  sa propriÃ©tÃ© `coordinate`. On Ã©crit donc `event.coordinate`.

::: {.callout-note collapse="true"}
## Pourquoi on a "event" et pas "evt"Â ?

Jâ€™ai fait exprÃ¨s de changer le nom du paramÃ¨tre pour appeler tous les Ã©vÃ¨nements "event" dans notre code et pour ajouter cette petite note. En fait, quand on crÃ©e une fonction, on peut nommer notre paramÃ¨tre comme on veut. Par exemple, dans le code suivantÂ :

``` javascript
map.on('singleclick', (event) => {
  const coord = event.coordinate;
});
```

â€¦ la variable `coordinates` a la mÃªme valeur que si jâ€™Ã©crisÂ :

``` javascript
map.on('singleclick', (evt) => {
  const coord = evt.coordinate;
});
```

â€¦ ou encoreÂ :

``` javascript
map.on('singleclick', (mon_evenement_qui_vient_de_ma_carte_avec_mon_clic) => {
  const coord = mon_evenement_qui_vient_de_ma_carte_avec_mon_clic.coordinate;
});
```

Bien sÃ»r, si vous ne vous sentez pas encore trop en confiance, inutile de renommer ce genre dâ€™Ã©lÃ©ments pour uniformiser le code. Vous pouvez garder ce que vous voyez dans le code OpenLayers.
:::

AprÃ¨s les coordonnÃ©es, on rÃ©cupÃ¨re la rÃ©solution. On sait quâ€™on lit la rÃ©solution depuis la vue de la carte, donc on peut dâ€™abord rÃ©cupÃ©rer cette vue PUIS lire sa rÃ©solution (toujours dans notre fonction, pas Ã  lâ€™extÃ©rieurÂ !)Â :

``` javascript
const view = map.getView();
const res = view.getResolution();
```

On peut aussi enchaÃ®ner les mÃ©thodes comme ceciÂ :

``` javascript
const res = map.getView().getResolution();
```

::: {.callout-note collapse="true"}
## Pourquoi on ne reprend pas le /\*\* \@type \*/ du code originalÂ ?

Parce quâ€™on nâ€™en est pas Ã  faire du TypeScriptÂ ! Ils ont fait un excÃ¨s de zÃ¨le dans cet exemple. Cette syntaxe Ã©trange signifique que le type de la constante est de type "number", donc un nombre. Mais Ã§a on le sait dÃ©jÃ  de toute faÃ§on, on a lu la documentation.
:::

On est Ã  mi-chemin et le reste est trÃ¨s simple. La projection doit Ãªtre indiquÃ©e par une chaÃ®ne de caractÃ¨resÂ :

``` javascript
const proj = 'EPSG:3857';
```

Et on reprend les paramÃ¨tres de lâ€™exemple pour indiquer quâ€™on veut rÃ©cupÃ©rer notre rÃ©ponse au format HTML. Par dÃ©faut, GeoServer renverra la table attributaire de lâ€™Ã©lÃ©ment sous forme dâ€™un tableau en HTML.

``` javascript
const parametres = {'INFO_FORMAT': 'text/html'};
```

On a tous nos Ã©lÃ©ments, il ne nous reste quâ€™Ã  appeler la mÃ©thode `getFeatureInfoUrl()` sur notre **source** de donnÃ©es (attention, pas la coucheÂ !) pour gÃ©nÃ©rer lâ€™url qui nous permettra de rÃ©cupÃ©rer la rÃ©ponse. La documentation nous indique que les paramÃ¨tres doivent Ãªtre renseignÃ©s dans lâ€™ordre suivantÂ :

-   coordinate

-   resolution

-   projection

-   params

``` javascript
const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);
```

Ou encore, pour ressembler Ã  lâ€™exempleÂ :

``` javascript
const url = sourceDeals.getFeatureInfoUrl(
  coord,
  res,
  proj,
  parametres
);
```

Pour rÃ©capituler, voilÃ  Ã  quoi ressemble ma fonction pour le moment. Jâ€™ai ajoutÃ© un `console.log()` pour voir lâ€™url sâ€™afficher dans ma console et donc bien vÃ©rifier que jâ€™arrive Ã  gÃ©nÃ©rer cette adresse.

``` javascript
map.on('singleclick', (event) => {
  console.log("Jâ€™ai cliquÃ© sur la carteÂ !");

  const coord = event.coordinate;
  const res = map.getView().getResolution();
  const proj = 'EPSG:3857';
  const parametres = {'INFO_FORMAT': 'text/html'};

  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);

  console.log(url);
});
```

Attention, voilÃ  la partie plus compliquÃ©eÂ : maintenant quâ€™on a une addresse, on doit utilier la fonction `fetch()` pour rÃ©cupÃ©rer la donnÃ©e. Câ€™est une fonction bien particuliÃ¨re. Elle est dite "asynchrone" car elle ne bloque pas le reste du code lorsquâ€™elle tourne, contrairement aux autres fonctions "synchrones". Si jâ€™Ã©cris une fonction `reboursSynchrone()`, lâ€™exÃ©cution de mon code et donc mon application est bloquÃ©e pendant que la fonction sâ€™exÃ©cute. Si câ€™est une petite fonction rapide Ã§a ne pose pas de problÃ¨me. Si câ€™est quelque chose de plus lent, par exemple qui demande dâ€™attendre la rÃ©ponse dâ€™un serveur dans le cas de notre fetch, notre application est bloquÃ©e et on est bien embÃªtÃ©s. Au contraire, si jâ€™Ã©cris une fonction `reboursAsynchrone()` lâ€™application nâ€™attendra pas que la fonction ait terminÃ© de sâ€™exÃ©cuter pour pouvoir continuer de fonctionner.

Du coup, lâ€™asynchrone, câ€™est trÃ¨s pratiqueÂ ! Par contre, comme câ€™est particulier et quâ€™il est plus difficile de prÃ©voir quand elle va terminer son exÃ©cution et si elle va rencontrer des erreurs ou non, on va devoir lui rÃ©server un traitement particulier. Reprenons le code de lâ€™exemple pour lâ€™expliquer petit Ã  petit.

``` javascript
fetch(url)
  .then((response) => response.text())
  .then((html) => {
    // Jâ€™ai modifiÃ© la ligne suivante pour simplifier, on sâ€™intÃ©ressera Ã  elle un peu plus tard
    console.log("Câ€™est une rÃ©ussiteÂ !");
  });
```

Vous noterez lâ€™utilisation de mÃ©thodes `.then()` qui contiennent des fonctions. Ce sont les fonctions Ã  exÃ©cuter quand le maillon prÃ©cÃ©dent de la chaÃ®ne a fini de se rÃ©soudre. Si on devait Ã©crire en langage courant ce que signifie ce code, voilÃ  ce que Ã§a donneraitÂ :

-   `fetch(url)` â†’ "RÃ©cupÃ¨re les informations qui sont disponibles Ã  cette adresse"

-   `.then((response) => response.text())` â†’ "Ensuite ("*then*"), quand tu as **rÃ©ussi** Ã  rÃ©cupÃ©rer la rÃ©ponse, stocke-la dans une variable que jâ€™appelle "response" puis utilise sa mÃ©thode `.text()` pour rÃ©cupÃ©rer du texte au format HTML"

-   `.then((html) => { console.log("Câ€™est une rÃ©ussiteÂ !"); })` â†’ "Ensuite, quand tu as **rÃ©ussi** lâ€™Ã©tape prÃ©cÃ©dente, stocke le texte au format HTML de lâ€™Ã©tape prÃ©cÃ©dente dans une variable que jâ€™appelle "html" et affiche un message dans ma console"

Vous noterez que jâ€™ai prÃ©cisÃ© que `.then()` sâ€™exÃ©cute si lâ€™Ã©tape prÃ©cÃ©dente a rÃ©ussi. Si ce nâ€™est pas le cas, lâ€™exÃ©cution de notre chaÃ®ne de mÃ©thodes `fetch()` sâ€™arrÃªte et un message dâ€™erreur sâ€™affiche dans la console. Comme on a plutÃ´t confiance en notre GeoServer, on peut se lancer et exÃ©cuter ce `fecth()` mais attention, seulement si on a bien une addresse Ã  interrogerÂ ! Si la variable `url` est `undefined`, notre application risque de pÃ©ter les plombs. On ajoute une condition autour du `fetch()` pour Ã©viter les erreursÂ :

``` javascript
if (url) {
  fetch(url)
    .then((response) => response.text())
    .then((html) => {
      console.log("Câ€™est une rÃ©ussiteÂ !");
      console.log(html);
    });
}
```

Vous pouvez tester les `console.log()`. Le HTML quâ€™on obtient nâ€™est pas trÃ¨s gracieux tel quel, il vaudrait mieux lâ€™afficher dans lâ€™interface de lâ€™applicationÂ !

### Filtrer des couches WMS

â€¦

### Des cercles proportionnels avec un flux WFS

â€¦

### Des boutons pour afficher des cartes thÃ©matiques

â€¦

### Un curseur dâ€™Ã©volution temporelle

â€¦

### Mince, jâ€™ai oubliÃ© lâ€™Ã©chelleÂ !

â€¦

### Il est temps de polir un peu lâ€™interface

â€¦

### Pour aller plus loinÂ : utiliser des plugins

â€¦
