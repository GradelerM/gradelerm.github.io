[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Dummy blog post TWO\n\n\n\n\n\nSome dummy blog post for pages config\n\n\n\n\n\n1 min\n\n\n\n\n\n\n\nFigures layout\n\n\n\n\n\n\nR\n\n\ntmap\n\n\n\nLayout des figures dans les articles avec Quarto.\n\n\n\n\n\nMar 10, 2025\n\n\nMarie Gradeler\n\n\n1 min\n\n\n\n\n\n\n\nDummy blog post\n\n\n\n\n\n\nR\n\n\ndataviz\n\n\n\nSome dummy blog post for pages config\n\n\n\n\n\nOct 10, 2024\n\n\nMarie Gradeler\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/maps_package.html",
    "href": "posts/maps_package.html",
    "title": "Figures layout",
    "section": "",
    "text": "Classique, on nâ€™ajoute rien.\n\n\n\n\n\n\n\n\n\nOn utilise plus dâ€™espace pour afficher une figure en plus large.\n\n\n\n\n\n\n\n\n\nOn peut aussi afficher les figures dans la marge, il semblerait."
  },
  {
    "objectID": "posts/maps_package.html#test-des-layouts",
    "href": "posts/maps_package.html#test-des-layouts",
    "title": "Figures layout",
    "section": "",
    "text": "Classique, on nâ€™ajoute rien.\n\n\n\n\n\n\n\n\n\nOn utilise plus dâ€™espace pour afficher une figure en plus large.\n\n\n\n\n\n\n\n\n\nOn peut aussi afficher les figures dans la marge, il semblerait."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#sommaire",
    "href": "cours/geonum/slides_serveurs_carto.html#sommaire",
    "title": "Serveurs Cartographiques",
    "section": "Sommaire",
    "text": "Sommaire\n\nQuâ€™est-ce quâ€™un serveur cartoÂ ?\nLes standards OGC\nPourquoi utiliser un serveur cartoÂ ?\nExemples de serveurs carto\nGeoServer\nTP - Mise en pratique"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto",
    "title": "Serveurs Cartographiques",
    "section": "Quâ€™est-ce quâ€™un serveur cartoÂ ?",
    "text": "Quâ€™est-ce quâ€™un serveur cartoÂ ?\nRappels sur ce quâ€™est un serveur\nLe serveur matÃ©riel (hardware) : Une ou plusieurs machines physiques reliÃ©es entre elles et et sur lesquelles fonctionnent un ou plusieurs logiciels.\nSourceÂ : Ionos\nDans ce TP, notre serveur physique sera notre ordinateur. En pratique, cela ressemble plus souvent Ã  Ã§a (serveurs WikiMedia foundation)Â :"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-1",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-1",
    "title": "Serveurs Cartographiques",
    "section": "Quâ€™est-ce quâ€™un serveur cartoÂ ?",
    "text": "Quâ€™est-ce quâ€™un serveur cartoÂ ?\nRappels sur ce quâ€™est un serveur\nLe serveur (software) : Un programme effectuant des interactions en rÃ©seau avec dâ€™autres programmes appelÃ©s logiciels clients. Le service apportÃ© dÃ©pend du logiciel serveur.\nSourceÂ : Ionos\nUn logiciel serveur peut-Ãªtre un serveur Web (Apache, Nginx), un serveur email, un serveur de bases de donnÃ©es (PostgreSQL), un serveur cartographique (GeoServer), etc. Un logiciel client est par exemple un navigateur internet pour afficher un site web (Firefox, Google Chrome), un client mail (Thunderbird), et plus gÃ©nÃ©ralement une machine cliente."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-2",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-2",
    "title": "Serveurs Cartographiques",
    "section": "Quâ€™est-ce quâ€™un serveur cartoÂ ?",
    "text": "Quâ€™est-ce quâ€™un serveur cartoÂ ?\nComment le serveur communique-t-il avec les clientsÂ ?\nDans le cas des serveurs web et cartographiques, le client (par exemple notre Firefox) va envoyer des requÃªtes au serveur (par exemple GeoServer). Le serveur va lire la requÃªte et renvoyer une rÃ©ponse. Cette rÃ©ponse peut-Ãªtre une page web, un JSON, un flux cartographique, mais aussi un message dâ€™erreur comme le fameux 404 not found.\n\nSource : codegym.cc"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-3",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-3",
    "title": "Serveurs Cartographiques",
    "section": "Quâ€™est-ce quâ€™un serveur cartoÂ ?",
    "text": "Quâ€™est-ce quâ€™un serveur cartoÂ ?\nComment le serveur communique-t-il avec la source de donnÃ©eÂ ?\nEn rÃ©alitÃ©, la plupart des applications fonctionnent de la maniÃ¨re suivanteÂ : le client envoie des requÃªtes au serveur. Le serveur va communiquer avec la base de donnÃ©es, traiter le rÃ©sultat et renvoyer une rÃ©ponse au client.\nExempleÂ :\n- Client = mon application Firefox\n- Serveur = les serveurs de Google\n- Database = la base de donnÃ©es de Google\n- RequÃªte = cherche les sites qui correspondent Ã  la requÃªte â€œapprendre le JavaScriptâ€\n- RÃ©ponse = liste des sites qui correspondent Ã  la requÃªte â€œapprendre le JavaScriptâ€\n\nSourceÂ : codegym.cc"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-4",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-4",
    "title": "Serveurs Cartographiques",
    "section": "Quâ€™est-ce quâ€™un serveur cartoÂ ?",
    "text": "Quâ€™est-ce quâ€™un serveur cartoÂ ?\nLa spÃ©cificitÃ© du serveur carto\nUn serveur cartographique va servir - sans surprise - de la donnÃ©e cartographique sous forme de vecteur ou de raster, tuilÃ©e ou non. Il le fait selon des standards OGC bien dÃ©finis comme le WMS (Web Map Service) et le WFS (Web Feature Service) qui vont dÃ©finir la structure de la donnÃ©e rÃ©cupÃ©rÃ©e et les interactions possibles avec cette couche de dâ€˜information.\n\n\n\nSource : hansongis.com/blog/"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nLes spÃ©cifications OGC suivantes dÃ©finissent ce quâ€™on appelle des interfaces (ou API) pour requÃªter des cartes gÃ©orÃ©fÃ©rencÃ©es dâ€™un serveur.\nPas de panique - â€œinterfaceâ€ est un joli mot pour expliquer comment on doit structurer notre requÃªte et ce quâ€™on recevra en rÃ©ponse. Par exemple, quand on commande une glace, on sait quâ€™il faut indiquer pot ou cornet, le nombre de boules et le parfum de chacune. En Ã©change, on obtiendra une glace bien structurÃ©e, prÃªte Ã  Ãªtre dÃ©gustÃ©e. Si on veut beaucoup simplifier, lâ€™interface fait le lien entre ce que le client aimerait et ce que le cuisinier peut lui donner en encadrant la question posÃ©e par le client et les rÃ©ponses possibles du cuisinier.\nSource : Documentation GeoServer"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-1",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-1",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Map Service (WMS)\n\nLa spÃ©cification WMS fournit une interface standard pour requÃªter une image gÃ©orÃ©fÃ©rencÃ©e et sa lÃ©gende. Le client reÃ§oit une image gÃ©orÃ©fÃ©rencÃ©e.\nCâ€™est le plus couramment utilisÃ© car il est plus rapide que le WFS lorsquâ€™il sâ€™agit de reprÃ©senter beaucoup dâ€™Ã©lÃ©ments.\nLa requÃªte GetMap permet de rÃ©cupÃ©rer une carte.\nLa requÃªte GetFeatureInfo permet de rÃ©cupÃ©rer la gÃ©omÃ©trie et les valeurs dâ€™un pixel.\nLa requÃªte GetLegendGraphic permet de rÃ©cupÃ©rer la lÃ©gende.\n\nSource : GeoServer WMS reference - Source : QGISserver WMS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-2",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-2",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Feature Service (WFS)\n\nLa spÃ©cification WFS fournit une interface standard pour crÃ©er, modifier et requÃªter de lâ€™information gÃ©ographique au format vecteur. Le client reÃ§oit de la donnÃ©e au format GML.\nCâ€™est celui quâ€™il faut utiliser dans le cas de la manipulation de vecteurs (pour les requÃªtes attributaires, le WMS suffit).\nLa requÃªte GetFeature retourne une sÃ©lection de features avec leur gÃ©omÃ©trie et la valeur de leurs attributs.\nLa requÃªte Transaction permet dâ€™Ã©diter une feature existante en utilisant â€œcreateâ€, â€œupdateâ€ ou â€œdeleteâ€.\n\nSource : GeoServer WFS reference - Source : QGISserver WFS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-3",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-3",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Coverage Service (WCS)\n\nLa spÃ©cification WCS fournit une interface pour accÃ©der Ã  de la donnÃ©e raster. On peut le voir comme le WMS pour du raster.\nLa requÃªte DescribeCoverage retourne un document XML qui dÃ©crit la couverture du pixel sÃ©lectionnÃ©.\nLa requÃªte GetCoverage retourne un rÃ©sultat similaire Ã  la requÃªte GetMap du flux WMS mais avec des extensions additionnelles pour supporter la rÃ©cupÃ©ration de donnÃ©es raster.\n\nSource : GeoServer WCS reference - Source : QGISserver WCS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-4",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-4",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Map Tile Service (WMTS)\n\nLa spÃ©cification WMTS fournit une interface pour requÃªter des images tuilÃ©es. Il sâ€™agit plus ou moins de la mÃªme chose que WMS mais qui permet dâ€™utiliser des couches tuilÃ©es.\nLa requÃªte GetTile retourne une tuile.\nLa requÃªte GetFeatureInfo permet de rÃ©cupÃ©rer la gÃ©omÃ©trie et les valeurs dâ€™un pixel (comme dans le cas du flux WMS).\n\nSource : QGISserver WMTS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-5",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-5",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nDans ce TP, nous allons utiliser les flux les plus communs, WMS puis WFS."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto",
    "href": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto",
    "title": "Serveurs Cartographiques",
    "section": "Pourquoi utiliser un serveur carto",
    "text": "Pourquoi utiliser un serveur carto\n\nPermet de rester Ã  jour - quand la donnÃ©e est mise Ã  jour sur le serveur, toutes les applications clientes (comme une application Leaflet ou OpenLayers (OL)) rÃ©cupÃ¨rent aussi la donnÃ©e Ã  jour. Câ€™est pratique quand on a une IDG.\nPermet de servir de la donnÃ©e depuis une base de donnÃ©es PostgreSQL. Au lieu de requÃªter la donnÃ©e en SQL, de lâ€™exporter en JSON et de lâ€™importer dans lâ€™application Leaflet/OL, et de refaire Ã§a Ã  chaque fois que la donnÃ©e change, on peut simplement utiliser GeoServer pour gÃ©nÃ©rer une couche Ã  partir de SQL.\nPermet de gÃ©rer et communiquer les mÃ©tadonnÃ©es. GeoServer permet par exemple dâ€™uploader des fiches de mÃ©tadonnÃ©es pour chaque couche quâ€™il Ã©met.\nLes serveurs cartographiques sont au cÅ“ur des IDG, il faut donc savoir les utiliser. Par exemple, geOrchestra propose GeoServer comme module de serveur cartographique."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto-1",
    "href": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto-1",
    "title": "Serveurs Cartographiques",
    "section": "Pourquoi utiliser un serveur carto",
    "text": "Pourquoi utiliser un serveur carto\nEn rÃ©sumÃ©\nOn peut se passer dâ€™un serveur cartographique quand on a â€œjusteâ€ quelques features en JSON Ã  afficher. DÃ¨s quâ€™on commence Ã  avoir des couches souvent mises Ã  jour, besoin dâ€™accÃ©der aux mÃ©tadonnÃ©es, de plus nombreuses couches, dâ€™importer des couches stylisÃ©es dans QGIS, de crÃ©er des couches Ã  partir dâ€™une base de donnÃ©es PostgreSQLâ€¦ dans ce cas lâ€™utilisation dâ€™un serveur cartographique nous facilite grandement la vie.\n\nExemple 1 : data.grandlyon.com qui permet de lire directement ses couches de donnÃ©es en passant par son API.\nExemple 2 : les fonds de carte OMS (WMS)"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques",
    "href": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques",
    "title": "Serveurs Cartographiques",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nMapServer\nLien vers MapServer\nPlateforme Open Source pour la publication de donnÃ©e gÃ©ospatiale. (Jâ€™ai peu de choses Ã  dire dessus, je ne lâ€™ai jamais utilisÃ©e).\nMapServer continue Ã  exister dans les organisations qui sâ€™en servent dÃ©jÃ  mais ce nâ€™est plus forcÃ©ment la solution la plus populaire lorsquâ€™il faut partir de zÃ©ro."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-1",
    "href": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-1",
    "title": "Serveurs Cartographiques",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nGeoServer\nLien vers GeoServer\nServeur Java gratuit et Open Source qui permet aux utilisateurs de visualiser et Ã©diter de la donnÃ©e gÃ©ospatiale. La librairie OpenLayers est intÃ©grÃ©e Ã  GeoServer pour gÃ©nÃ©rer rapidement des cartes. Les capacitÃ©s du serveur peuvent Ãªtre Ã©tendues via lâ€™installation dâ€™extensions divserses.\nGeoServer est le plus simple Ã  dÃ©ployer. Il peut aussi directement se connecter avec des bases de donnÃ©es comme PostgreSQL - lâ€™Ã©quipe le dÃ©crit comme Ã©tant â€œdesignÃ© pour lâ€™interopÃ©rabilitÃ©â€. GeoServer est assez complexe Ã  configurer mais le plus adaptable aux besoins utilisateur, notamment grÃ¢ce Ã  la gestion fine des droits utilisateurs et lâ€™utilisation de plugins pour enrichir les possibilitÃ©s."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-2",
    "href": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-2",
    "title": "Serveurs Cartographiques",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nQGIS Server\nLien vers QGIS Server Guide Manual\nAPI gratuite et Open Source qui permet aussi dâ€™implanter des Ã©lÃ©ments cartographiques avancÃ©s pour crÃ©er des cartes thÃ©matiques. Elle fonctionne avec un serveur web (Apache ou Nginx).\nQGIS Server est plus difficile Ã  mettre en place (on utilisera une application tierce comme LizMap) mais est le plus compatible avec la publication de projets via QGIS. Câ€™est la meilleure solution pour publier rapidement un projet QGIS. On le prÃ©sentera rapidement dans un des TP."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - Introduction",
    "text": "GeoServer - Introduction\n\nGeoServer est un serveur Open Source Ã©crit en Java qui permet aux utilisateurs de partager et Ã©diter de la donnÃ©e gÃ©ospatiale.\nIl a Ã©tÃ© designÃ© pour maximisÃ© son interopÃ©rabilitÃ©, permettant de publier de la donnÃ©e des sources de donnÃ©es les plus courantes en utilisant des standards ouverts.\nGeoServer est un projet dÃ©veloppÃ©, testÃ© et soutenu par sa communautÃ© - comme dans le cas de QGIS.\nGeoServer est une rÃ©fÃ©rence dans lâ€™implementation des standards WFS, WMS et WCS de lâ€™OGC.\n\n\nSource : hansongis.com/blog/Source : GeoServer Overview"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction-1",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction-1",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - Introduction",
    "text": "GeoServer - Introduction\n\nLe projet a dÃ©butÃ© en 2001 avec le Open Planning Project (TOPP), un organisme Ã  but non lucratif basÃ© Ã  New York et qui a crÃ©Ã© une suite dâ€™outils pour promouvoir la transparence de la donnÃ©e. Leur premier outil, GeoServer, avait pour objectif de permettre aux citoyens dâ€™accÃ©der aux documents de planification urbaine du gouvernement en partageant la donnÃ©e spatiale.\nAvec le temps, le projet GeoTools a Ã©tÃ© ajoutÃ© avec la possibilitÃ© de supporter les Shapefiles, les bases de donnÃ©es Oracle, etc.\nDâ€™autres projets ouverts ont continuÃ© Ã  enrichir GeoServer et ses fonctionnalitÃ©s comme le dÃ©veloppement de PostGIS (par Refractions Reseach) qui a permis de connecter GeoServer Ã  une base de donnÃ©es gratuite (PostgreSQL).\nLicence : la GNU General Public License, mais contient aussi des logiciels Apache donc dÃ©pend de la Apache Software Foundation ainsi que le la Eclipse Public License, qui sont toutes trÃ¨s permissives.\n\nSource : GeoServer Overview"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvÃ©nients",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvÃ©nients",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - avantages et inconvÃ©nients",
    "text": "GeoServer - avantages et inconvÃ©nients\nAvantages\n\nSolution trÃ¨s bien documentÃ©e\nNombreux plugins qui sont bien maintenus\nPeut lire de multiple sources de donnÃ©es (shapefile, geopackage, connexion Ã  une base PostgreSQL)\nOutil activement maintenu et communautÃ© rÃ©active\nPas difficile Ã  dÃ©ployer (comparÃ© Ã  dâ€™autres)\nDocumentation riche\nUn outil en tout bien solide sur le long terme"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvÃ©nients-1",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvÃ©nients-1",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - avantages et inconvÃ©nients",
    "text": "GeoServer - avantages et inconvÃ©nients\nInconvÃ©nients\n\nDifficile Ã  prendre en main au dÃ©but (gestion des droits, diffÃ©rencier les couches et les dÃ©pÃ´ts, etc.)\nLâ€™interface est un peu vieille et pas super intuitive\nLa grande majoritÃ© des ressources est uniquement disponible en anglais (mais Ã§a ne devrait pas vous faire trop peur !)\nVous allez parfois vous arracher les cheveux sur des fichiers de style complexes"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---comment-utiliser-la-documentation",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---comment-utiliser-la-documentation",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - Comment utiliser la documentation",
    "text": "GeoServer - Comment utiliser la documentation\nhttps://geoserver.org/"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#mise-en-pratique",
    "href": "cours/geonum/slides_serveurs_carto.html#mise-en-pratique",
    "title": "Serveurs Cartographiques",
    "section": "Mise en pratique",
    "text": "Mise en pratique\nPage du TP\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html",
    "href": "cours/geonum/enrichir_ma_carte.html",
    "title": "Enrichir ma carte en fonctionnalitÃ©s",
    "section": "",
    "text": "CrÃ©er un menu dâ€™affichage des couches\nInterroger une couche WMS et afficher les rÃ©sultats\nFiltrer une couche WMS\nLire un flux WFS et afficher la gÃ©omÃ©trie\nCrÃ©er un curseur dâ€™Ã©volution temporelle\nAjouter une Ã©chelle Ã  la carte\nPolir un peu lâ€™interface de lâ€™application avec du CSS\nPour aller plus loin, apprendre Ã  utiliser des plugins OpenLayers",
    "crumbs": [
      "Enrichir ma carte en fonctionnalitÃ©s"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#objectifs",
    "href": "cours/geonum/enrichir_ma_carte.html#objectifs",
    "title": "Enrichir ma carte en fonctionnalitÃ©s",
    "section": "",
    "text": "CrÃ©er un menu dâ€™affichage des couches\nInterroger une couche WMS et afficher les rÃ©sultats\nFiltrer une couche WMS\nLire un flux WFS et afficher la gÃ©omÃ©trie\nCrÃ©er un curseur dâ€™Ã©volution temporelle\nAjouter une Ã©chelle Ã  la carte\nPolir un peu lâ€™interface de lâ€™application avec du CSS\nPour aller plus loin, apprendre Ã  utiliser des plugins OpenLayers",
    "crumbs": [
      "Enrichir ma carte en fonctionnalitÃ©s"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#cours",
    "href": "cours/geonum/enrichir_ma_carte.html#cours",
    "title": "Enrichir ma carte en fonctionnalitÃ©s",
    "section": "Cours",
    "text": "Cours\nAujourdâ€™hui, câ€™est de la pratique. Mâ€™entendre parler pendant des heures, câ€™est finiÂ !",
    "crumbs": [
      "Enrichir ma carte en fonctionnalitÃ©s"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#tp---faire-une-carte-interactive-sur-le-thÃ¨me-de-lexploitation-miniÃ¨re-et-ses-impacts-nÃ©gatifs-sur-les-populations-locales",
    "href": "cours/geonum/enrichir_ma_carte.html#tp---faire-une-carte-interactive-sur-le-thÃ¨me-de-lexploitation-miniÃ¨re-et-ses-impacts-nÃ©gatifs-sur-les-populations-locales",
    "title": "Enrichir ma carte en fonctionnalitÃ©s",
    "section": "TP - Faire une carte interactive sur le thÃ¨me de lâ€™exploitation miniÃ¨re et ses impacts nÃ©gatifs sur les populations locales",
    "text": "TP - Faire une carte interactive sur le thÃ¨me de lâ€™exploitation miniÃ¨re et ses impacts nÃ©gatifs sur les populations locales\n\n\n\n\n\n\nImportant\n\n\n\nCe TP se base sur lâ€™architecture dÃ©ployÃ©e et le code Ã©crit au cours du TP â€œOpenLayers & GeoServerâ€.\n\n\nCâ€™est un titre Ã  rallonge, mais voici en gros dans quelle direction la donnÃ©e de la Land Matrix va nous permettre de partir. Nous allons nous baser sur tout ce qui a Ã©tÃ© crÃ©Ã© lors du TD â€œOpenLayers & GeoServerâ€. Si vous nâ€™avez pas pu suivre le TD ou que vous avez Ã©garÃ© vos fichiers, merci de le signaler maintenant.\n\nCrÃ©er un menu dâ€™affichage des couches\nSi jamais vous nâ€™aviez pas eu le temps dâ€™afficher plus dâ€™une couche, voici le code avec lequel jâ€™ai commencÃ© ce TP. Nâ€™oubliez pas de remplacer les Ã©lÃ©ments comme lâ€™adresse de votre GeoServerÂ ! Et si votre application affiche dÃ©jÃ  la couche â€œdealsâ€ et â€œdeals_by_countryâ€, inutile de copier mon code, câ€™est plus intÃ©ressant de repartir du votre.\nindex.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"https://openlayers.org/favicon.ico\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Transition Minerals&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\nstyle.css\n@import \"node_modules/ol/ol.css\";\n\nhtml, body {\n  margin: 0;\n  height: 100%;\n}\n#map {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n}\nmain.js\nimport './style.css';\nimport {Map, View} from 'ol';\nimport { ImageWMS } from 'ol/source';\nimport TileLayer from 'ol/layer/Tile';\nimport ImageLayer from 'ol/layer/Image';\nimport OSM from 'ol/source/OSM';\n\n// WMS de mon GeoServer\nconst geoserverWms = 'http://localhost:8080/geoserver/land_matrix/wms'\n\n// Layer: Fond de carte OSM\nconst layerOsm = new TileLayer({ source: new OSM() });\n\n// Layer: deals by country\nconst layerDealsByCountry = new ImageLayer({\n  source: new ImageWMS({\n    url: geoserverWms,\n    params: { 'LAYERS' : 'land_matrix:deals_by_country' },\n    serverType: 'geoserver',\n  })\n});\n\n// Layer: deals\nconst sourceDeals = new ImageWMS({\n  url: geoserverWms,\n  params: { 'LAYERS' : 'land_matrix:deals' },\n  serverType: 'geoserver',\n});\n\nconst layerDeals = new ImageLayer({\n  source: sourceDeals\n});\n\n// Map\nconst map = new Map({\n  target: 'map',\n  layers: [ layerOsm, layerDealsByCountry, layerDeals ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\nOn souhaite maintenant crÃ©er un menu avec des cases de type â€œcheckboxâ€ qui vont nous permettre de choisir si on veut afficher ou masquer une couche. On doit commencer par crÃ©er cet Ã©lÃ©ment dans lâ€™interface en modifiant index.html.\n\nDÃ©finissez une &lt;div&gt; dans laquelle on souhaite afficher notre menu de couches et positionnez-la avec du CSS\nAjoutez Ã  lâ€™intÃ©rieur un input de type checkbox avec la balise &lt;input type=\"checkbox\"/&gt; et donnez lui un label avec le nom de la couche\n\nComme câ€™est la premiÃ¨re fois quâ€™on doit Ã©crire du HTML ensemble, je vous guide pas Ã  pas. Commencez par ouvrir index.html et ajouter sous la div de votre carte (la div map) une autre div, comme ceciÂ :\n&lt;div id=\"layers\" class=\"menu\"&gt;&lt;/div&gt;\nOn crÃ©e une nouvelle div dont lâ€™identifiant est layers, ce qui nous permettra de la retrouver par la suite. On lui a aussi ajoutÃ© une classe quâ€™on appelle menu et qui nous permettra dâ€™appliquer un seul style Ã  tous nos Ã©lÃ©ments de menu. Si câ€™est un peu flou maintenant, vous comprendrez plus tard en ajoutant dâ€™autres menus.\nComme notre div est vide, on ne la voit pas. Ã‡a va Ãªtre difficile de la positionner ailleurs sur la carte. Jâ€™ai lâ€™habitude de mettre un peu nâ€™importe quoi Ã  lâ€™intÃ©rieur, juste le temps de rÃ©gler mon CSS correctement. Ma div ressemble donc Ã Â :\n&lt;div id=\"layers\" class=\"menu\"&gt;cthulhu fhtagn&lt;/div&gt;\nOn pourra retirer le texte aprÃ¨s. Vous remarquerez quâ€™on ne voit toujours pas notre texte. Essayez de rafraÃ®chir la page - vous devriez le voir tout en haut Ã  gauche de lâ€™Ã©cran avant que la carte ne le recouvreÂ ! Câ€™est normal, nous nâ€™avons pas â€œpositionnÃ©â€ notre Ã©lÃ©ment. Ce nâ€™est pas un cours de CSS donc on ne rentrera pas dans les dÃ©tails. Ouvrez styles.css et ajoutez le code suivantÂ :\n.menu {\n  position: absolute;\n}\nOn sÃ©lectionne toutes les balises html avec la classe menu et on leur applique un positionnement absolu. Sauvegardez et vous devriez voir apparaÃ®tre le texte. SuperÂ ! Maisâ€¦ câ€™est moche et Ã§a ne ressemble pas DU TOUT Ã  un menu. Pas de souci, on y arrive. Ajoutez les Ã©lÃ©ments suivants (jâ€™ai commentÃ© le code pour vous aider Ã  comprendre)Â :\n.menu {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  right: 20px;\n\n  /* Padding */\n  padding: 8px;\n\n  /* Dimensions minimales */\n  min-height: 80px;\n  min-width: 160px;\n\n  /* Rectangle blanc avec coins arrondis */\n  background-color: white;\n  border-radius: 8px;\n}\nAh, câ€™est dÃ©jÃ  plus sympaÂ ! On va mÃªme pouvoir supprimer le texte de notre balise HTML dans index.html. En gros, voilÃ  ce que je fais avec ce code CSSÂ :\n\nJâ€™indique que lâ€™Ã©lÃ©ment a une position absolue dans le body (donc pas relative Ã  un Ã©lÃ©ment) et quâ€™il doit se trouver Ã  20 pixels du haut (top) et 20 pixels de la droite (right) de lâ€™Ã©cran.\nJe donne un padding, une marge intÃ©rieur, Ã  mon Ã©lÃ©ment de menu. Pour mieux comprendre, essayez de supprimer cette ligne et regardez ce qui change.\nJe donne une hauteur et une largeur minimales Ã  mon Ã©lÃ©ment pour Ã©viter quâ€™il ne disparaÃ®sse quand il est vide. Par dÃ©faut, mon Ã©lÃ©ment aurait grandi et rÃ©trÃ©ci avec son contenu.\nJâ€™ai donnÃ© un peu de style Ã  mon menu en lui donnant un fond blanc et des coins arrondis.\n\nVoilÃ  globalement le niveau maximum de difficultÃ© du CSS que je vais vous demander pour styliser votre application, mais vous pouvez Ã©videmment allez plus loinÂ !\nMaintenant quâ€™on a un menu, il va falloir ajouter la checkbox qui permettra dâ€™afficher ou masquer ma couche. Retournez dans index.html et ajoutez la balise &lt;input&gt; et son &lt;label&gt; dans notre &lt;div id=\"layers&gt;, comme ceciÂ :\n&lt;div id=\"layers\" class=\"menu\"&gt;\n  &lt;input type=\"checkbox\" id=\"checkbox-countries\" name=\"checkbox-countries\" checked /&gt;\n  &lt;label for=\"checkbox-countries\"&gt;Deals by countries&lt;/label&gt;\n&lt;/div&gt;\nVÃ©rifiez que vous pouvez cliquer sur la checkbox pour la cocher/dÃ©cocher. Lâ€™interface est prÃªteÂ ! Il faut maintenant quâ€™on parvienne Ã  dire Ã  notre application quâ€™il faut afficher ou masquer la couche deals_by_country en fonction.\nğŸ¤” On doit dâ€™abord se demander comment sâ€™y prendre pour masquer une couche dans OpenLayers.\nOn va se servir des mÃ©thodes qui sont disponibles pour tous les objets Layer de OpenLayers. La documentation nous apprend lâ€™existence de la mÃ©thode setVisible(). VoilÃ  ce quâ€™on nous en ditÂ :\n\n\n\n\n\nLa mÃ©thode setVisible() prend un argument visible. Cet argument est de type â€œbooleanâ€, il peut donc prendre la valeur true ou false. On va faire le test et utiliser cette fonction pour faire disparaÃ®tre notre couche. Allez dans main.js et ajouter cette ligne Ã  la fin de votre scriptÂ :\nlayer_deals_by_country.setVisible(false);\nAttentionÂ ! layer_deals_by_country est le nom de la variable dans laquelle jâ€™ai crÃ©Ã© ma couche â€œdeals_by_countryâ€. Si vous avez nommÃ© votre couche diffÃ©remment, nâ€™oubliez pas de changer le nomÂ !\nNormalement, la couche ne devrait plus Ãªtre visible sur la carte. Super, la mÃ©thode a fonctionnÃ©Â ! Il ne nous reste plus quâ€™Ã  â€œconnecterâ€ cette mÃ©thode Ã  notre Ã©lÃ©ment checkbox.\nOn lâ€™a dÃ©jÃ  vu dans le TP Serveurs cartographiques (lorsquâ€™on affichait la lÃ©gende des couches), il est possible de trouver un Ã©lÃ©ment HTML et de le modifier en utilisant du JavaScript. Pour trouver un Ã©lÃ©ment, le plus facile est de rechercher son identifiant id. Ajoutez en bas de main.jsÂ :\nconst checkbox_countries = document.getElementById('checkbox-countries');\nconsole.log(checkbox_countries);\nSauvegardez et allez dans la console de votre navigateur. Vous devriez voir apparaÃ®tre votre tag &lt;input&gt; dans la console. Si vous le survolez avec la souris, la checkbox devrait Ãªtre passÃ©e en surbrillance. Si Ã§a fonctionne, parfait ! Ã‡a veut dire quâ€™on arrive bien Ã  rÃ©cupÃ©rer notre Ã©lÃ©ment de checkbox. Maintenant, on souhaite exÃ©cuter du code lorsque son statut â€œcheckedâ€ change. Pour cela, on doit â€œÃ©couterâ€ la checkbox pour savoir si lâ€™Ã©vÃ¨nement â€œchangeâ€ a eu lieu.\nconst checkboxCountries = document.getElementById('checkbox-countries');\n\ncheckboxCountries.addEventListener('change', (event) =&gt; {\n  if (event.currentTarget.checked) {\n    // On fait des trucs quand la checkbox est checkÃ©e\n    console.log(\"Checked\");\n  } else {\n    // On fait des trucs quand la checkbox nâ€™est PAS checkÃ©e\n    console.log(\"Pas checked\");\n  }\n});\n\naddEventListener indique quâ€™on souhaite â€œÃ©couterâ€ les Ã©vÃ¨nements de notre checkbox. On prÃ©cise le type dâ€™Ã©vÃ¨nement avec le premier paramÃ¨tre, 'change'.\nLa condition if vÃ©rifie si notre checkbox est checkÃ©e ou non. On rÃ©cupÃ¨re cette information grÃ¢ce Ã  event.current.checked. Si cette condition est true, on affiche â€œCheckedâ€ dans la console. Si cette condition est false, on affiche â€œPas checkedâ€.\n\nEssayezÂ ! Cliquez sur la checkbox et surveillez votre console. On voit bien sâ€™afficher les messages. On y est presqueÂ ! Maintenant, au lieu dâ€™afficher du texte, on souhaite afficher la couche quand la condition est true et la masquer quand la condition est false.\nconst checkboxCountries = document.getElementById('checkbox-countries');\n\ncheckboxCountries.addEventListener('change', (event) =&gt; {\n  if (event.currentTarget.checked) {\n    // On fait des trucs quand la checkbox est checkÃ©e\n    layer_deals_by_country.setVisible(true);\n  } else {\n    // On fait des trucs quand la checkbox nâ€™est PAS checkÃ©e\n    layer_deals_by_country.setVisible(false);\n  }\n});\n\n\n\n\n\n\nPensez bien Ã â€¦\n\n\n\n\nChanger le nom de la couche layer_deals_by_country si vous nâ€™avez pas appelÃ© votre couche comme Ã§a.\nSupprimer la ligne layer_deals_by_country.setVisible(false); toute seule au dessus ou votre couche sera masquÃ©e par dÃ©faut au moment de charger la carte.\n\n\n\nVoilÃ , on peut dÃ©sormais afficher et masquer la couche Ã  volontÃ©Â !\n\n\n\n\n\nÃ€ vousÂ ! CrÃ©ez une autre checkbox qui permet dâ€™afficher ou masquer la couche deals. Jâ€™aimerais que cette checkbox soit au-dessus de la premiÃ¨reÂ !\n\n\n\n\n\n\nTip\n\n\n\nSauf indication contraire (via du CSS), les Ã©lÃ©ments HTML sont affichÃ©s dans lâ€™ordre dans lequel ils sont dÃ©clarÃ©s.\n&lt;div id=\"2\"&gt;&lt;/div&gt;\n&lt;div id=\"1\"&gt;&lt;/div&gt;\nDans cet exemple, ma div 1 sera plus bas que ma div 2. Ã‡a devrait vous aider !\n\n\n\n\nInterroger une couche WMS et afficher les rÃ©sultats\nOn souhaite maintenant interroger la couche deals en cliquant dessus. Cette Ã©tape est plus compliquÃ©e que la prÃ©cÃ©dente car elle va nous demander dâ€™utiliser fetch(), on va donc lÃ -aussi procÃ©der petit Ã  petit pour bien comprendre ce quâ€™on fait. Ouvrez lâ€™exemple OpenLayers WMS GetFeatureInfo (Image Layer).\nCommenÃ§ons par sâ€™intÃ©resser Ã  cette partie du codeÂ :\nmap.on('singleclick', function (evt) {\n  document.getElementById('info').innerHTML = '';\n  const viewResolution = /** @type {number} */ (view.getResolution());\n  const url = wmsSource.getFeatureInfoUrl(\n    evt.coordinate,\n    viewResolution,\n    'EPSG:3857',\n    {'INFO_FORMAT': 'text/html'},\n  );\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((html) =&gt; {\n        document.getElementById('info').innerHTML = html;\n      });\n  }\n});\n\n.on('singleclick') permet dâ€™exÃ©cuter une fonction lorsquâ€™on clique sur la carte.\ndocument.getElementById() rÃ©cupÃ¨re lâ€™Ã©lÃ©ment â€˜infoâ€™ dans lequel ils affichent leurs rÃ©sultats.\nOn rÃ©cupÃ¨re la rÃ©solution de la vue de la carte grÃ¢ce Ã  la mÃ©thode dans viewResolution. On a besoin de passer cette rÃ©solution dans la fonction suivante.\nOn rÃ©cupÃ¨re lâ€™url qui contient les informations de lâ€™Ã©lÃ©ment cliquÃ© avec la mÃ©thode getFeatureInfoUrl() de la source de donnÃ©es.\nSi notre url est dÃ©finie, alors on utilise la fonction fetch() pour rÃ©cupÃ©rer la donnÃ©e Ã  partir de cette adresse.\ndocument.getElementById() rÃ©cupÃ¨re Ã  nouveau lâ€™Ã©lÃ©ment â€˜infoâ€™ et dÃ©finir la valeur de son innerHTML pour pouvoir afficher les rÃ©sultats.\n\nCompliquÃ©Â ? Non, Ã§a va allerÂ ! On va tranquillement rÃ©Ã©crire cette fonction pour la couche deals. Pour rappel, voici comment jâ€™appelle la couche deals dans mon codeÂ :\nconst sourceDeals = new ImageWMS({\n  url: geoserverWms,\n  params: { 'LAYERS' : 'land_matrix:deals' },\n  serverType: 'geoserver',\n});\n\nconst layerDeals = new ImageLayer({\n  source: sourceDeals\n});\nJe commence donc par exÃ©cuter une fonction lorsque je clique sur la carteÂ :\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"Jâ€™ai cliquÃ© sur la carteÂ !\");\n});\nSauvegardez, gardez la console de votre navigateur ouverte et cliquez sur la carte pour vÃ©rifier que le message apparaÃ®t bien. Si câ€™est bon, on vient dâ€™apprendre comment exÃ©cuter des fonctions en cliquant sur la carteÂ ! On sait ensuite que dans lâ€™exemple ils utilisent la mÃ©thode getFeatureInfoUrl() de leur source de donnÃ©es pour rÃ©cupÃ©rer les informations des features. Ouvrez la documentation de ImageWMS on va en avoir besoin. VoilÃ  ce quâ€™elle nous dit au sujet de la mÃ©thode fetFeatureInfoUrl()Â :\n\n\n\n\n\nLa mÃ©thode prend plusieurs paramÃ¨tresÂ :\n\ncoordinate, les coordonnÃ©es visÃ©es par le clic de lâ€™utilisateur\nresolution, la rÃ©solution de la carte (liÃ©e Ã  la view de ma carte)\nprojection, le systÃ¨me de projection de la carteÂ : â€œEPSG:3857â€™â€\nparams, un objet contenant plusieurs paramÃ¨tres comme le format dÃ©sirÃ© du rÃ©sultat ou encore les couches quâ€™on souhaite interroger\n\nRÃ©cupÃ©rons ces Ã©lÃ©ments dans lâ€™ordre en commenÃ§ant par les coordonnÃ©es. Dans lâ€™exemple, ils rÃ©fÃ©rencent directement la source de coordonnÃ©es evt.coordinate dans la fonction mais Ã§a va un peu vite. Pour mieux comprendre, on va stocker les coordonnÃ©es de notre Ã©vÃ¨nement (= notre clic) dans une constante.\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"Jâ€™ai cliquÃ© sur la carteÂ !\");\n  \n  const coord = event.coordinate;\n});\nEn fait, lâ€™Ã©vÃ¨nement â€˜singleclickâ€™ de la carte map permet de rÃ©cupÃ©rer les coordonnÃ©es du clic en accÃ©dant Ã  sa propriÃ©tÃ© coordinate. On Ã©crit donc event.coordinate.\n\n\n\n\n\n\nPourquoi on a â€œeventâ€ et pas â€œevtâ€Â ?\n\n\n\n\n\nJâ€™ai fait exprÃ¨s de changer le nom du paramÃ¨tre pour appeler tous les Ã©vÃ¨nements â€œeventâ€ dans notre code et pour ajouter cette petite note. En fait, quand on crÃ©e une fonction, on peut nommer notre paramÃ¨tre comme on veut. Par exemple, dans le code suivantÂ :\nmap.on('singleclick', (event) =&gt; {\n  const coord = event.coordinate;\n});\nâ€¦ la variable coordinates a la mÃªme valeur que si jâ€™Ã©crisÂ :\nmap.on('singleclick', (evt) =&gt; {\n  const coord = evt.coordinate;\n});\nâ€¦ ou encoreÂ :\nmap.on('singleclick', (mon_evenement_qui_vient_de_ma_carte_avec_mon_clic) =&gt; {\n  const coord = mon_evenement_qui_vient_de_ma_carte_avec_mon_clic.coordinate;\n});\nBien sÃ»r, si vous ne vous sentez pas encore trop en confiance, inutile de renommer ce genre dâ€™Ã©lÃ©ments pour uniformiser le code. Vous pouvez garder ce que vous voyez dans le code OpenLayers.\n\n\n\nAprÃ¨s les coordonnÃ©es, on rÃ©cupÃ¨re la rÃ©solution. On sait quâ€™on lit la rÃ©solution depuis la vue de la carte, donc on peut dâ€™abord rÃ©cupÃ©rer cette vue PUIS lire sa rÃ©solution (toujours dans notre fonction, pas Ã  lâ€™extÃ©rieurÂ !)Â :\nconst view = map.getView();\nconst res = view.getResolution();\nOn peut aussi enchaÃ®ner les mÃ©thodes comme ceciÂ :\nconst res = map.getView().getResolution();\n\n\n\n\n\n\nPourquoi on ne reprend pas le /** @type */ du code originalÂ ?\n\n\n\n\n\nParce quâ€™on nâ€™en est pas Ã  faire du TypeScriptÂ ! Ils ont fait un excÃ¨s de zÃ¨le dans cet exemple. Cette syntaxe Ã©trange signifique que le type de la constante est de type â€œnumberâ€, donc un nombre. Mais Ã§a on le sait dÃ©jÃ  de toute faÃ§on, on a lu la documentation.\n\n\n\nOn est Ã  mi-chemin et le reste est trÃ¨s simple. La projection doit Ãªtre indiquÃ©e par une chaÃ®ne de caractÃ¨resÂ :\nconst proj = 'EPSG:3857';\nEt on reprend les paramÃ¨tres de lâ€™exemple pour indiquer quâ€™on veut rÃ©cupÃ©rer notre rÃ©ponse au format HTML. Par dÃ©faut, GeoServer renverra la table attributaire de lâ€™Ã©lÃ©ment sous forme dâ€™un tableau en HTML.\nconst parametres = {'INFO_FORMAT': 'text/html'};\nOn a tous nos Ã©lÃ©ments, il ne nous reste quâ€™Ã  appeler la mÃ©thode getFeatureInfoUrl() sur notre source de donnÃ©es (attention, pas la coucheÂ !) pour gÃ©nÃ©rer lâ€™url qui nous permettra de rÃ©cupÃ©rer la rÃ©ponse. La documentation nous indique que les paramÃ¨tres doivent Ãªtre renseignÃ©s dans lâ€™ordre suivantÂ :\n\ncoordinate\nresolution\nprojection\nparams\n\nconst url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\nOu encore, pour ressembler Ã  lâ€™exempleÂ :\nconst url = sourceDeals.getFeatureInfoUrl(\n  coord,\n  res,\n  proj,\n  parametres\n);\nPour rÃ©capituler, voilÃ  Ã  quoi ressemble ma fonction pour le moment. Jâ€™ai ajoutÃ© un console.log() pour voir lâ€™url sâ€™afficher dans ma console et donc bien vÃ©rifier que jâ€™arrive Ã  gÃ©nÃ©rer cette adresse.\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"Jâ€™ai cliquÃ© sur la carteÂ !\");\n\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n  const parametres = {'INFO_FORMAT': 'text/html'};\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  console.log(url);\n});\nAttention, voilÃ  la partie plus compliquÃ©eÂ : maintenant quâ€™on a une addresse, on doit utilier la fonction fetch() pour rÃ©cupÃ©rer la donnÃ©e. Câ€™est une fonction bien particuliÃ¨re. Elle est dite â€œasynchroneâ€ car elle ne bloque pas le reste du code lorsquâ€™elle tourne, contrairement aux autres fonctions â€œsynchronesâ€. Si jâ€™Ã©cris une fonction reboursSynchrone(), lâ€™exÃ©cution de mon code et donc mon application est bloquÃ©e pendant que la fonction sâ€™exÃ©cute. Si câ€™est une petite fonction rapide Ã§a ne pose pas de problÃ¨me. Si câ€™est quelque chose de plus lent, par exemple qui demande dâ€™attendre la rÃ©ponse dâ€™un serveur dans le cas de notre fetch, notre application est bloquÃ©e et on est bien embÃªtÃ©s. Au contraire, si jâ€™Ã©cris une fonction reboursAsynchrone() lâ€™application nâ€™attendra pas que la fonction ait terminÃ© de sâ€™exÃ©cuter pour pouvoir continuer de fonctionner.\nDu coup, lâ€™asynchrone, câ€™est trÃ¨s pratiqueÂ ! Par contre, comme câ€™est particulier et quâ€™il est plus difficile de prÃ©voir quand elle va terminer son exÃ©cution et si elle va rencontrer des erreurs ou non, on va devoir lui rÃ©server un traitement particulier. Reprenons le code de lâ€™exemple pour lâ€™expliquer petit Ã  petit.\nfetch(url)\n  .then((response) =&gt; response.text())\n  .then((html) =&gt; {\n    // Jâ€™ai modifiÃ© la ligne suivante pour simplifier, on sâ€™intÃ©ressera Ã  elle un peu plus tard\n    console.log(\"Câ€™est une rÃ©ussiteÂ !\");\n  });\nVous noterez lâ€™utilisation de mÃ©thodes .then() qui contiennent des fonctions. Ce sont les fonctions Ã  exÃ©cuter quand le maillon prÃ©cÃ©dent de la chaÃ®ne a fini de se rÃ©soudre. Si on devait Ã©crire en langage courant ce que signifie ce code, voilÃ  ce que Ã§a donneraitÂ :\n\nfetch(url) â†’ â€œRÃ©cupÃ¨re les informations qui sont disponibles Ã  cette adresseâ€\n.then((response) =&gt; response.text()) â†’ â€œEnsuite (â€thenâ€), quand tu as rÃ©ussi Ã  rÃ©cupÃ©rer la rÃ©ponse, stocke-la dans une variable que jâ€™appelle â€œresponseâ€ puis utilise sa mÃ©thode .text() pour rÃ©cupÃ©rer du texte au format HTMLâ€\n.then((html) =&gt; { console.log(\"Câ€™est une rÃ©ussiteÂ !\"); }) â†’ â€œEnsuite, quand tu as rÃ©ussi lâ€™Ã©tape prÃ©cÃ©dente, stocke le texte au format HTML de lâ€™Ã©tape prÃ©cÃ©dente dans une variable que jâ€™appelleâ€htmlâ€ et affiche un message dans ma consoleâ€\n\nVous noterez que jâ€™ai prÃ©cisÃ© que .then() sâ€™exÃ©cute si lâ€™Ã©tape prÃ©cÃ©dente a rÃ©ussi. Si ce nâ€™est pas le cas, lâ€™exÃ©cution de notre chaÃ®ne de mÃ©thodes fetch() sâ€™arrÃªte et un message dâ€™erreur sâ€™affiche dans la console. Comme on a plutÃ´t confiance en notre GeoServer, on peut se lancer et exÃ©cuter ce fetch() mais attention, seulement si on a bien une addresse Ã  interrogerÂ ! Si la variable url est undefined, notre application risque de pÃ©ter les plombs. On ajoute une condition autour du fetch() pour Ã©viter les erreursÂ :\nif (url) {\n  fetch(url)\n    .then((response) =&gt; response.text())\n    .then((html) =&gt; {\n      console.log(\"Câ€™est une rÃ©ussiteÂ !\");\n      console.log(html);\n    });\n}\nVous pouvez tester les console.log(). Le HTML quâ€™on obtient nâ€™est pas trÃ¨s gracieux tel quel, il vaudrait mieux lâ€™afficher dans lâ€™interface de lâ€™applicationÂ !\n\n\n\n\n\n\nAu secours, je nâ€™ai toujours pas compris fetch()\n\n\n\n\n\n\n\n\n\n\nSi votre cerveau est un peu comme Ã§a quand on parle de fetch(), nâ€™hÃ©sitez pas Ã  mâ€™appeler pour avoir une nouvelle explication. Jâ€™ai peur de ne pas pouvoir faire mieux par Ã©crit. La notion de fonction asynchrone est complexe et jâ€™ai mis pas mal de temps Ã  la comprendre, donc en deux minutes en plein milieu dâ€™un TP câ€™est encore pire.\nSinon, vous pouvez continuer le TP, on aura dâ€™autres occasion dâ€™utiliser fetch(). Peut-Ãªtre que les autres exemples seront plus clairsÂ !\n\n\n\nQuand on doit afficher un nouvel Ã©lÃ©ment dans lâ€™interface, il faut toujours penser Ã  crÃ©er une nouvelle balise HTML (souvent une &lt;div&gt;) pour le mettre Ã  lâ€™intÃ©rieur. Comme pour lâ€™exemple prÃ©cÃ©dent, on crÃ©e une div dans le HTML. Je place la mienne aprÃ¨s &lt;div id=\"layers\"&gt; et je remets nâ€™importe quoi dedans juste pour la voir dans mon interface.\n&lt;div id=\"attributes\" class=\"menu\"&gt;cthulhu ftaghn&lt;/div&gt;\nSauvegardez et regardez lâ€™application. Et lÃ , horreurÂ ! Notre menu de couches est remplacÃ© par la nouvelle div quâ€™on vient de crÃ©erÂ ! Câ€™est normal, elles ont le mÃªme style car on a aussi appelÃ© class=\"menu\" dans la div. Le problÃ¨me, câ€™est que dans styles.css, on voit que tous nos menus sont positionnÃ©s au mÃªme endroitÂ : regardez top et right.\n.menu {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  right: 20px;\n\n  /* Padding */\n  padding: 8px;\n\n  /* Dimensions minimales */\n  min-height: 80px;\n  min-width: 160px;\n\n  /* Rectangle blanc avec coins arrondis */\n  background-color: white;\n  border-radius: 8px;\n}\nOn va donc devoir positionner nos deux &lt;div&gt; indÃ©pendamment lâ€™une de lâ€™autre. Pour les sÃ©lectionner individuellement, on peut utiliser le sÃ©lecteur # qui permet de chercher par id. VoilÃ  mon codeÂ :\n.menu {\n  /* Padding */\n  padding: 8px;\n\n  /* Dimensions minimales */\n  min-height: 80px;\n  min-width: 160px;\n\n  /* Rectangle blanc avec coins arrondis */\n  background-color: white;\n  border-radius: 8px;\n}\n\n#layers {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  right: 20px;\n}\n\n#attributes {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  left: 20px;\n}\nVoilÃ , maintenant .menu me permet de dÃ©finir un padding, des dimensions minimales, une couleur de background et des coins arrondis pour tous mes Ã©lÃ©ments avec la classe class=\"menu\", mais par contre jâ€™ai bien positionnÃ© indÃ©pendamment mon menu de layers et ma nouvelle div attributes.\nMaintenant, modifiez le style de #attributes pour lâ€™afficher en bas de la carte et sur toute la largeur de lâ€™Ã©cran. Il nous faut beaucoup dâ€™espace pour afficher notre table.\nCâ€™est bon, vous avez une &lt;div id=\"attributes\"&gt; qui vous plaÃ®tÂ ? Vous pouvez supprimer le texte qui Ã©tait dans la div, on nâ€™en aura plus besoin. Maintenant, on cherche Ã  dire Ã  notre applicationÂ : â€œPrends le texte HTML que je rÃ©cupÃ¨re grÃ¢ce Ã  ma fonction et mets-le dans ma div Attributesâ€. On a formulÃ© notre idÃ©e en langage naturel, on va maintenant pouvoir lâ€™Ã©crire en JavaScript. Dâ€™abord, on se demande Ã  quel endroit dans notre code on rÃ©cupÃ¨re ce HTML. Souvenez-vousÂ :\n// Interroger la couche deals et afficher les rÃ©sultats\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"Jâ€™ai cliquÃ© sur la carteÂ !\");\n\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n  const parametres = {'INFO_FORMAT': 'text/html'};\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((html) =&gt; {\n        // Dans cette fonction, on a accÃ¨s Ã  notre \"html\" !\n        console.log(\"Câ€™est une rÃ©ussiteÂ !\");\n        console.log(html);\n      });\n  }\n});\nVous voyez mon commentaireÂ ? Câ€™est dans cette fonction quâ€™on va Ã©crire notre code. Zoomons sur cette petite partieÂ :\n      .then((html) =&gt; {\n        // Dans cette fonction, on a accÃ¨s Ã  notre \"html\" !\n        console.log(\"Câ€™est une rÃ©ussiteÂ !\");\n        console.log(html);\n      });\nSi je traduis le texte prÃ©cÃ©dent en langage naturel, pour rappel, Ã§a faitÂ :\n\nQuand tu as rÃ©ussi lâ€™Ã©tape prÃ©cÃ©dente (souvenez-vous de then), alors stocke le rÃ©sultat dans une variable html etÂ :\nAffiche â€œCâ€™est une rÃ©ussiteÂ !â€ dans ma console\nAffiche le contenu du HTML dans ma console\n\nOn aimerait remplacer les deux derniÃ¨res Ã©tapes par â€œaffiche le HTML dans mon interfaceâ€. Pour cela, on utilise la ligne de code suivante (Ã  ajouter au bon endroit dans la fonction)Â :\ndocument.getElementById('attributes').innerHTML = html;\nSuper, vous savez maintenant requÃªter une couche WMSÂ ! Le rÃ©sultat est un peu moche pour le moment mais vous pourrez revenir plus tard pour lâ€™affiner. Si vous finissez le TP en avance, revenez sur les sections â€œPour aller plus loinâ€¦â€.\n\n\n\n\n\n\nPour aller plus loinâ€¦\n\n\n\n\n\nSi vous avez dÃ©jÃ  fait le tour du TP, vous allez trouver dans cette section des Ã©lÃ©ments supplÃ©mentaires pour aller plus loin.\nEn cours de rÃ©daction\n\n\n\n\n\nFiltrer des couches WMS\nOn a vu dans lâ€™Ã©tape prÃ©cÃ©dente quâ€™il Ã©tait possible de requÃªter une couche WMS. Vous ne serez donc pas surpris dâ€™apprendre quâ€™il est aussi possible de filtrer ces couchesÂ ! Les flux WMS ont beau retourner une image, on constate maintenant quâ€™elles ne manquent pas dâ€™interactivitÃ©.\nGeoServer permet dâ€™ajouter des filtres Ã©crits au format cql Ã  la requÃªte pour lui dire â€œapplique ce filtre Ã  ma couche avant de mâ€™envoyer le rÃ©sultatâ€. Le filtrage se fait donc du cÃ´tÃ© du serveur. Vous pouvez trouver les spÃ©cifications WMS avec cql_filter ici et le tutoriel de filtrage lÃ  mais comme câ€™est une notion un peu complexe Ã  appliquer seul, on va une fois de plus procÃ©der Ã©tape par Ã©tape ensemble.\nDans votre GeoServer, prÃ©visualisez la couche deals et cliquez sur les ... bleus en haut Ã  gauche de la carte. Vous devriez voir plusieurs nouvelles options apparaÃ®tre dont une qui sâ€™appelle â€œFilter:â€. Lâ€™option â€œCQLâ€ devrait dÃ©jÃ  Ãªtre sÃ©lectionnÃ©e, gardez-la. Câ€™est ce quâ€™on va utiliser pour la suite.\n\n\n\n\n\nCollez le texte suivant dans le champ CQL et cliquez sur â€œAppliquerâ€Â :\ndeal_size &gt; 10000\nNormalement, vous avez vu certains points disparaÃ®tre. Il ne vous reste plus que les deals de plus de 10Â 000 hectares. Si vous avez un doute, vous pouvez vÃ©rifier en cliquant sur les points pour afficher leurs attributs. Câ€™est facile, nonÂ ? Essayez les filtres suivant et essayez de comprendre Ã  quoi ils peuvent servirÂ :\nsilver = true\ntarget_country = 'Argentina'\ntarget_country = 'Argentina' OR target_country = 'Philippines'\n\n\n\n\n\n\nImportant\n\n\n\nQuand vous Ã©crivez des chaÃ®nes de caractÃ¨res dans un filtre CQL (â€œstringâ€), il faut impÃ©rativement utiliser les guillemets simples 'my_string' et pas les doubles \"my_string\".\nNe me demandez pas pourquoi, ce nâ€™est pas expliquÃ©, il faut juste lâ€™accepter et vivre avec.\n\n\nBien, vous savez maintenant Ã©crire un filtre simple en CQL, mais comment est-ce quâ€™on fait pour filtrer la couche depuis notre application OpenLayersÂ ? Voici mon code pour appliquer Ã  ma couche deals un filtre qui va uniquement rÃ©cupÃ©rer les mines qui produisent de lâ€™or (Gold) ou de lâ€™argent (Silver). Comparez ce snippet avec votre code pour comprendre oÃ¹ mettre ce code et ce quâ€™il faitÂ :\nconst sourceDeals = new ImageWMS({\n  url: geoserverWms,\n  params: {\n    'LAYERS' : 'land_matrix:deals',\n    \"CQL_FILTER\" : \"target_country = 'Argentina' OR target_country = 'Philippines'\",\n  },\n  serverType: 'geoserver',\n});\n\n\n\n\n\n\nImportant\n\n\n\nSi vous vous Ãªtes contentÃ© de copier-coller tout Ã§a dans votre code, câ€™est ratÃ©Â ! Il faut regarder mon snippet de code pour comprendre ce que vous devez ajouter Ã  votre code existantÂ !\n\n\nSauvegardez et regardez votre carte. Si vous avez compris ce que fait mon CQL, vous devriez rapidement Ãªtre capables de dire si le filtre a fonctionnÃ© ou non. Vous voyez, filtrer un flux WMS, câ€™est facileÂ !\nMaintenant, modifiez votre code pour afficher uniquement des mines qui produisent de lâ€™or. Je vous donne deux indicesÂ : regardez la table attributaire de la couche deals et souvenez vous que â€œorâ€ se dit â€œGoldâ€ en anglais. Pour ceux qui ont eu des consoles portables, il y a une licence vidÃ©oludique bien pratique pour retenir des noms de minÃ©raux en anglaisÂ :\n\n\n\n\n\n(Si vous Ãªtes capable dâ€™entendre ce GIF juste en le regardant, vous commencez Ã  Ãªtre vieux aussi, dÃ©solÃ©e. Quoi quâ€™il en soit, jâ€™espÃ¨re que les interruptions GIFs vous font un peu dÃ©compresser.)\nMaintenant que vous savez filtrer la couche, vous pouvez ajouter un peu plus dâ€™interactivitÃ© Ã  votre carte. On va afficher un menu avec des boutons de type â€œradioâ€ pour sÃ©lectionner des filtres. Je vous fais un schÃ©ma moche Ã  la main pour vous aider Ã  comprendre.\n\n\n\n\n\nVous voyez oÃ¹ on veut en venirÂ ? Comme on commence Ã  avoir lâ€™habitude de faire des menus, je vous laisse crÃ©er et positionner celui-ci avec un peu de HTML et de CSS et on passe directement Ã  lâ€™ajout des boutons. On va devoir mettre dans notre Ã©lÃ©ment &lt;div&gt; plusieurs boutons radio avec la balise &lt;input type=\"radio\"&gt;. VoilÃ  le code pour les Ã©lÃ©ments â€œOrâ€ et â€œArgentâ€Â :\n    &lt;!-- Radio button menu - production --&gt;\n    &lt;div id=\"production\" class=\"menu\"&gt;\n  \n      &lt;div&gt;\n        &lt;input type=\"radio\" id=\"button-gold\" name=\"produce\" value=\"gold\" /&gt;\n        &lt;label for=\"gold\"&gt;Or&lt;/label&gt;\n      &lt;/div&gt;\n  \n\n      &lt;div&gt;\n        &lt;input type=\"radio\" id=\"button-silver\" name=\"produce\" value=\"silver\" /&gt;\n        &lt;label for=\"silver\"&gt;Argent&lt;/label&gt;\n      &lt;/div&gt;\n\n    &lt;/div&gt;\nVous noterez plusieurs chosesÂ :\n\n&lt;input&gt; et &lt;label&gt; vont par paires\nla balise &lt;label&gt; contient le nom en franÃ§ais de mon Ã©lÃ©ment, câ€™est ce qui sâ€™affiche dans lâ€™application\ntoutes les balises &lt;input&gt; on la mÃªme propriÃ©tÃ© name=\"produce\", on dirait donc quâ€™il vaut mieux continuer dans ce sens\non a une propriÃ©tÃ© id unique Ã  chaque &lt;input&gt; qui nous permettra, au besoin, dâ€™aller les chercher avec du JavaScript\nla propriÃ©tÃ© value de mes &lt;input&gt; semble correspondre Ã  des colonnes de la table attributaire de ma couche\n\nAvec ces Ã©lÃ©ments, ajoutez les boutons pour Charbon, Lithium et Cobalt comme indiquÃ©s sur mon schÃ©ma plus haut. Attention Ã  bien mettre Charbon en hautÂ ! Quand câ€™est terminÃ©, allez sur votre carte et cliquez un peu sur ces boutons radio. Normalement, vous ne pouvez pas sÃ©lectionner plus dâ€™un seul Ã©lÃ©ment Ã  la fois au sein du groupe. Votre application sait que tous ces boutons font partie du mÃªme groupe car vous leur avez tous donnÃ© la mÃªme valeur name=\"produce\". Si vous commencez Ã  modifier cette valeur, vous verrez apparaÃ®tre un comportement indÃ©sirable.\nUne fois que votre menu est prÃªt, bien positionnÃ© sur la carte et que vos cinq boutons radio fonctionnent, on va pouvoir passer au JavaScript. Comme dâ€™habitude, on va exprimer notre besoin en langage naturelÂ : â€œLorsque je sÃ©lectionne un minÃ©ral, je souhaite modifier le filtre de ma couche deals pour rÃ©cupÃ©rer uniquement les deals qui produisent les minÃ©raux sÃ©lectionnÃ©sâ€.\nPour rappel, voici les Ã©lÃ©ments dont on disposeÂ :\n\non a des boutons radio avec une valeur value qui correspond Ã  une colonne de la table attributaire\nvous avez dÃ©jÃ  une couche qui filtre les deals qui produisent de lâ€™or avec un filtre CQL\nle filtre CQL est tout simplement une chaÃ®ne de caractÃ¨res (string)\n\nLe rÃ©sultat auquel on voudrait arriver, câ€™est doncÂ : â€œMon CQL dans les params de la source de ma couche deals change dÃ¨s que je sÃ©lectionne un nouveau minÃ©ralâ€.\nÃ‡a tombe bienÂ ! La documentation de la source ImageWMS (celle quâ€™on utilise pour notre couche) nous apprend quâ€™il existe une mÃ©thode .updateParams() qui permet de mettre Ã  jour les paramÃ¨tres dâ€™une couche.\nCommencez par ajouter ces deux Ã©lÃ©ments en bas de main.js. Souvenez-vous de la maniÃ¨re dont on a â€œÃ©coutÃ©â€ notre checkbox du premier exercice de ce TP. Le code ressemble beaucoup, nonÂ ?\nconst buttonGold = document.getElementById('button-gold');\n\nbuttonGold.addEventListener('change', () =&gt; {\n  console.log(\"Test\");\n});\nVoici ce que font les deux Ã©lÃ©ments du codeÂ :\n\nla premiÃ¨re ligne rÃ©cupÃ¨re mon bouton radio qui grÃ¢ce Ã  son identifiant en utilisant la mÃ©thode .getElementById() que vous avons dÃ©jÃ  vue prÃ©cÃ©demment\nles trois lignes suivantes nous permettent dâ€™Ã©couter notre bouton radio grÃ¢ce Ã  .addEventListener() et dâ€™exÃ©cuter une fonction quand le bouton radio est cochÃ©, et la fonction affiche â€œTestâ€ dans la console de dÃ©veloppement\n\nOn y est presque. On arrive Ã  exÃ©cuter quelque chose quand on sÃ©lectionne â€œOrâ€ dans notre carte, mais Ã§a ne nous permet pas de filtrer la couche. On va retirer notre console.log() et demander Ã  JavaScript de modifier les paramÃ¨tres de la source de notre couche deals grÃ¢ce Ã  la ligne suivanteÂ :\nsourceDeals.updateParams({ 'CQL_FILTER' : 'gold=true' });\nPour rappel, la source de mes deals est stockÃ©e dans la variable sourceDeals mais attention, il est possible que la votre porte un autre nom. Pensez Ã  vÃ©rifierÂ !\nHistoire de pouvoir tester au moins avec les boutons â€œOrâ€ et â€œArgentâ€, je vous donne un snippet de code plus complet. Inspirez-vous aussi des commentaires que je laisse, je rappelle que jâ€™attends un code commentÃ© pour lâ€™Ã©valuationÂ !\n// Or\nconst buttonGold = document.getElementById('button-gold');\nbuttonGold.addEventListener('change', () =&gt; {\n  // Quand lâ€™utilisateur clique sur le bouton \"Or\", je mets Ã  jour mon filtre CQL\n  sourceDeals.updateParams({ 'CQL_FILTER' : 'gold=true' });\n});\n\n// Argent\nconst buttonSilver = document.getElementById('button-silver');\nbuttonSilver.addEventListener('change', () =&gt; {\n  sourceDeals.updateParams({ 'CQL_FILTER' : 'silver=true' });\n});\nTestez lâ€™application en cliquant alternativement sur les boutons radio de Or et Argent. Si les deux couches sont diffÃ©rentes, super, Ã§a fonctionneÂ !\nMaintenant que vous avez compris comment faire, faites les Ã©tapes suivantes (et souvenez-vous que câ€™est Ã  vous que je demande, pas Ã  Chat-GPT, je vous ai quand mÃªme dÃ©jÃ  bien mÃ¢chÃ© le travail avec lâ€™exemple ci-dessusÂ !).\n\non a crÃ©Ã© un filtre fonctionnel pour Or et Argent, maintenant faites la mÃªme chose pour toutes les autres options\nquand vous avez terminÃ©, rajoutez une option â€œTousâ€ avec la valeur value=\"all\" et faites en sorte quâ€™il affiche tous les deals (je vous ai mis des indices ci-dessous si vous avez du mal mais essayez dâ€™abord de rÃ©flÃ©chir sans)\n\n\n\n\n\n\n\nIndice 1 - ajouter lâ€™option â€œTousâ€\n\n\n\n\n\nSouvenez vousÂ : si vous voulez ajouter un Ã©lÃ©ment Ã  lâ€™interface, commencez par index.html.\n\n\n\n\n\n\n\n\n\nIndice 2 - filtrer â€œTousâ€\n\n\n\n\n\nComme on Ã©crit du code JavaScript, on doit le faire dans main.js. Comme pour les autres options, vous pouvez rÃ©cupÃ©rer le bouton radio avec .getElementById() puis lâ€™Ã©couter avec .addEventListener().\nPour ce qui est du filtre CQLÂ : si on veut tous les deals, il suffit que notre filtre soit vide. Donc vous devriez avoir quelque part une chaÃ®ne de caractÃ¨res (string) vide.\n\n\n\nUne fois que câ€™est terminÃ© et que vous avez un beau menu fonctionnel pour filtrer vos couches, on peut passer Ã  la suiteÂ !\n\n\nDes cercles proportionnels avec un flux WFS\nOn commence Ã  avoir fait le tour des interactions basiques avec les flux WMS, qui pour rappel nous envoient des images. Mais, si vous vous souvenez bien, on a aussi Ã©voquÃ© dans le premier cours la possibilitÃ© de rÃ©cupÃ©rer non pas une image mais des vecteurs grÃ¢ce aux flux WFS. Câ€™est ce qui va nous intÃ©resser maintenantÂ : notre objectif va Ãªtre dâ€™afficher notre couche deals_by_country_centroid et de la styliser pour afficher des cercles proportionnels. Et vous allez voir que rÃ©cupÃ©rer une couche WFS avec OpenLayers, câ€™est du gÃ¢teau.\nJe vous donne la structure du code Ã  Ã©crire dans main.js. Nâ€™oubliez pas que les Ã©lÃ©ments encadrÃ©s par des chevrons \"&lt;un_truc&gt;\" doivent Ãªtre remplacÃ©s par une vraie valeur. Par exemple, si je vous Ã©cris const formation = \"&lt;ma_formation&gt;\", vous devrez mettre dans votre code const formation = \"geonum\". FacileÂ ! VoilÃ  donc le snippet de baseÂ :\n// Nâ€™oubliez pas de mettre un commentaire pour mâ€™expliquer ce que vous faites\nconst sourceCentroid = new VectorSource({\n  format: new GeoJSON(),\n  url: '&lt;mon_flux_wfs&gt;'\n});\n\nconst layerCentroid = new VectorLayer({\n  source: sourceCentroid,\n});\nâ€¦ et les imports Ã  ajouter tout en haut du fichierÂ :\nimport VectorSource from 'ol/source/Vector';\nimport GeoJSON from 'ol/format/GeoJSON.js';\nimport VectorLayer from 'ol/layer/Vector';\nVous remarquez que vous avons un Ã©lÃ©ment &lt;mon_flux_wms&gt; Ã  remplacer. Pour trouver lâ€™URL de ce flux, allez dans votre interface GeoServer, sÃ©lectionnez â€œPrÃ©visualisation de la coucheâ€. Cette fois, au lieu de choisir â€œOpenLayersâ€ (qui nous donne le flux WMS), allez dans la colonne â€œTous les formatsâ€ et sÃ©lectionnez GeoJSON. Je rappelle quâ€™on ne travaille plus sur la couche deals mais bien sur la couche deals_by_country_centroid. Il ne vous reste plus quâ€™Ã  copier lâ€™URL dans votre navigateurÂ : câ€™est la valeur de url dans votre VectorSource().\n\n\n\n\n\n\nOups, jâ€™ai oubliÃ© de retirer les chevrons â€œ&lt;â€ en collant mon url\n\n\n\n\n\n\n\n\n\n\n\n\n\nIl ne reste plus quâ€™une seule Ã©tape pour afficher la couche sur la carte. Je vous laisse trouver laquelleÂ !\n\n\n\n\n\n\nAllez, un petit indiceÂ ?\n\n\n\n\n\nVous lâ€™avez dÃ©jÃ  fait plusieurs fois dans le TP prÃ©cÃ©dent et celui-ci, et câ€™est souvent une Ã©tape quâ€™on oublie.\n\n\n\n\n\n\n\n\n\n\n\nJe ne trouve vraiment pasâ€¦\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPromis, jâ€™ai vraiment cherchÃ©Â !\n\n\n\n\n\nBon, dâ€™accord. Dites-moi, comment se porte lâ€™attribut layers de votre objet mapÂ ?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUne fois cette Ã©tape complÃ©tÃ©e, la couche devrait apparaÃ®tre sur votre carte. SuperÂ ! Par contre, Ã§a ressemble certainement Ã  des cercles blancs, un peu transparents, avec un contour bleu. Et surtout, ce ne sont pas des cercles proportionnelsÂ !\nHeureusement, vous avez Ã©tÃ© bien attentifs pendant vos cours de Leaflet et vous avez dÃ©jÃ  stylisÃ© des couches Ã  partir de donnÃ©e GeoJSON, Ã§a devrait Ãªtre super facile pour vous. Comme la documentation GeoServer nâ€™est pas trÃ¨s claire sur ce point, je vous donne un snippet et je vais vous demander de lâ€™ajuster un peu pour vÃ©rifier que vous comprendez bien qui fait quoi.\nDâ€™abord, on importe les Ã©lÃ©ments de style dont on va avoir besoinÂ :\nimport {Circle, Fill, Stroke, Style} from 'ol/style.js';\nOn commence par crÃ©er un style â€œpas proportionnelâ€ quâ€™on stocke dans la constante styleCentroid.\nconst styleCentroid = new Style({\n  image: new Circle({\n    radius: 40,\n    fill: new Fill({ color: 'white' }),\n    stroke: new Stroke({ color: 'blue', width: 5 }),\n  }),\n});\nNâ€™oubliez pas dâ€™appeler votre style dans la propriÃ©tÃ© style de votre VectorLayer ou bien la couche ne changera pas.\nconst layerCentroid = new VectorLayer({\n  source: sourceCentroid,\n  style: styleCentroid    // On a rajoutÃ© cette ligne\n});\nAttention Ã  lâ€™ordre dans lequel vous ajoutez les Ã©lÃ©ments dans le code. Nâ€™oubliez pas que pour appeler une constante (ou une variable) comme styleCentroid, il faut avoir dÃ©fini celle-ci avantÂ !\nRegardez Ã  quoi ressemble la couche maintenant quâ€™on lui a donnÃ© un style. Câ€™est moche, heinÂ ? Et bien câ€™est Ã  vous de la rendre belle. Modifiez le code pour obtenir quelque chose qui ressemble Ã  Ã§aÂ :\n\n\n\n\n\nNotez que les cercles ne sont pas entiÃ¨rement opaques. Prenez le temps de vous appliquer, cela vous servira de base pour la suite. Quand vous avez terminÃ©, vous pourrez utiliser ce snippet pour afficher des cercles proportionnels.\nfunction getStyleCentroid(feature) {\n  const nDeals = feature.get('n_deals');\n  const rayon = Math.sqrt(nDeals) * 0.01;\n  const style = new Style({\n    image: new Circle({\n      radius: rayon,\n      fill: new Fill({ color: 'white' }),\n      stroke: new Stroke({ color: 'blue', width: 5 }),\n    }),\n  });\n  return style;\n}\n\nconst layerCentroid = new VectorLayer({\n  source: sourceCentroid,\n  style: getStyleCentroid,\n});\nVous noterez que la diffÃ©rence principale ici est quâ€™on appelle une fonction et non une constante, et que cette fonction prend feature en argument. En fait, ce quâ€™il se passe, câ€™est que la fonction va regarder chaque objet de ma couche (chaque feature) et appliquer les Ã©tapes quâ€™on a dÃ©finies Ã  lâ€™intÃ©rieur.\n\non lit un attribut de notre feature avec la mÃ©thode .get()\non calcule un rayon\non dÃ©finit notre style comme prÃ©cÃ©demment, mais au lieu dâ€™Ãªtre une valeur fixe, notre propriÃ©tÃ© radius prend la valeur de notre rayon\n\nJe suis restÃ©e volontairement vague dans ce cas pour ne pas vous souffler toutes les rÃ©ponses. Comme prÃ©cÃ©demment, vous allez devoir modifier le snippet de code pour rendre la couche un peu plus Ã©lÃ©gante. Je vous montre mon exemple, essayez de le reproduire le plus fidÃ¨lement possibleÂ :\n\n\n\n\n\nUne fois que câ€™est terminÃ©, il reste un dernier exercice Ã  faire avec ces cercles proportionnels. Vous aurez compris quâ€™ici, nos cercles sont proportionnels au nombre de deals qui sont enregistrÃ©s dans le pays. Maintenant, crÃ©ez une couche de cercles proportionnels en vous basant sur la surface total couverte par les deals dans chaque pays.\nOn arrive sur la fin du TP et vous commencez (jâ€™espÃ¨re) Ã  bien comprendre comment fonctionne notre application donc je ne vous donne pas dâ€™indices. Faites juste attention Ã  bien faire varier la taille des cercles petit Ã  petitÂ : si jamais votre navigateur essaie de dessiner des cercles trop grands, vous avez des chances de faire crasher votre ordinateur (Ã§a mâ€™est peut-Ãªtre arrivÃ© pendant mes tests et ce serait dommage que Ã§a vous arrive aussi).",
    "crumbs": [
      "Enrichir ma carte en fonctionnalitÃ©s"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#lÃ©tape-finale",
    "href": "cours/geonum/enrichir_ma_carte.html#lÃ©tape-finale",
    "title": "Enrichir ma carte en fonctionnalitÃ©s",
    "section": "Lâ€™Ã©tape finaleÂ !",
    "text": "Lâ€™Ã©tape finaleÂ !\nEnfin lâ€™Ã©tape finale du TPÂ ! Une fois que votre application fonctionne et quâ€™elle vous convient, nâ€™oubliez SURTOUT PAS de la buildÂ ! Pour le moment, vous travaillez dans ce quâ€™on appelle un environnement de dÃ©veloppement mais quand vous Ãªtes prÃªts Ã  pousser une application en production, il faut la build. On lâ€™a dÃ©jÃ  fait au dÃ©but du TP prÃ©cÃ©dent mais je vous remets les instructions ici parce que je suis bien sympa (et que vous avez sÃ»rement le cerveau en compote aprÃ¨s tout Ã§a)Â :\n\nouvrez un terminal Ã  la racine de votre projet\nutilisez la commande cd app pour vous dÃ©placer dans le dossier de votre application\nutilisez la commande npm run build pour build votre application, le rÃ©sultat sera mis dans le dossier /dist\nallez sur http://localhost/ et vÃ©rifiez que vous voyez bien la derniÃ¨re version de votre application\n\nEt voilÃ , bien jouÃ©Â ! Vous nâ€™avez plus quâ€™Ã  mâ€™appeler pour me montrer le rÃ©sultat.",
    "crumbs": [
      "Enrichir ma carte en fonctionnalitÃ©s"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#jai-fini-en-avance-quest-ce-que-je-fais",
    "href": "cours/geonum/enrichir_ma_carte.html#jai-fini-en-avance-quest-ce-que-je-fais",
    "title": "Enrichir ma carte en fonctionnalitÃ©s",
    "section": "Jâ€™ai fini en avance, quâ€™est-ce que je faisÂ ?",
    "text": "Jâ€™ai fini en avance, quâ€™est-ce que je faisÂ ?\nDÃ©jÃ , bravo, câ€™Ã©tait un gros TP. Sâ€™il reste du temps, je vais rajouter ici petit Ã  petit des tÃ¢ches pendant le TP qui vous permettront dâ€™aller un peu plus loin et de prÃ©parer votre code pour lâ€™Ã©valuation. En attendantÂ :\n\nvÃ©rifiez bien lâ€™intendation de votre code\nvÃ©rifiez aussi quâ€™il soit bien commentÃ©\namÃ©liorez le style des couches WMS comme WFS pour avoir une carte harmonieuse et un peu stylÃ©e\najoutez un titre Ã  votre page\najoutez une Ã©chelle (avec OpenLayers)",
    "crumbs": [
      "Enrichir ma carte en fonctionnalitÃ©s"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#rajoutÃ©-Ã -la-fin-mais-Ã -faire-quand-mÃªme-une-table-attributaire-personnalisÃ©e",
    "href": "cours/geonum/enrichir_ma_carte.html#rajoutÃ©-Ã -la-fin-mais-Ã -faire-quand-mÃªme-une-table-attributaire-personnalisÃ©e",
    "title": "Enrichir ma carte en fonctionnalitÃ©s",
    "section": "RajoutÃ© Ã  la fin MAIS Ã€ FAIRE QUAND MÃŠMEÂ : une table attributaire personnalisÃ©e",
    "text": "RajoutÃ© Ã  la fin MAIS Ã€ FAIRE QUAND MÃŠMEÂ : une table attributaire personnalisÃ©e\nOn va se rÃ©intÃ©resser Ã  notre couche WMS â€œdealsâ€ et Ã  sa table attributaire (souvenez-vousÂ : Interroger une couche WMS et afficher les rÃ©sultats). Je vous remets notre code ici pour vous rappeler quels Ã©lÃ©ments permettent de rÃ©cupÃ©rer la table attributaire. Attention au nom de vos couches et de vos sources, ce ne sont peut-Ãªtre pas les mÃªmes que les miensÂ !\nmap.on('singleclick', (event) =&gt; {\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n  const parametres = {'INFO_FORMAT': 'text/html'};\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((html) =&gt; {\n        document.getElementById('attributes').innerHTML = html;\n       });\n  }\n});\nFaites attention Ã  cet Ã©lÃ©mentÂ :\nconst parametres = {'INFO_FORMAT': 'text/html'};\nNotez quâ€™on demande en fait Ã  notre GeoServer de nous donner la rÃ©ponse de notre requÃªte au format text/html. Câ€™est sympathique, mais difficile Ã  customiser et surtout pas super pratique quand la table attribuaire est LONGUE. Heureusement, on peut rÃ©cupÃ©rer le rÃ©sultat au format JSON qui sera bien pratique pour customiser notre table.\nComme toujours, quand on souhaite ajouter un nouvel Ã©lÃ©ment Ã  notre carte, il faut quâ€™on commence par Ã©crire du HTML. On va modifier notre div id=\"attributes\" pour y ajouter une table. RÃ©cupÃ©rez le code ci-dessous et regardez la diffÃ©rence, vous allez comprendre.\n&lt;div id=\"attributes\" class=\"menu\"&gt;\n  &lt;!-- Je crÃ©e une table --&gt;\n  &lt;table&gt;\n    &lt;!-- On utilise lâ€™Ã©lÃ©ment tr pour crÃ©er une ligne : tr = table row --&gt;\n    &lt;tr&gt;\n      &lt;!-- On utilise les Ã©lÃ©ments th (table header) pour crÃ©er les headers de nos trois colonnes --&gt;\n      &lt;th&gt;Deal ID&lt;/th&gt;\n      &lt;th&gt;Creation date&lt;/th&gt;\n      &lt;th&gt;Country&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;!-- On utilise lâ€™Ã©lÃ©ment tr pour crÃ©er une AUTRE ligne : tr = table row --&gt;\n    &lt;tr&gt;\n      &lt;!-- On crÃ©e trois colonnes vides avec td --&gt;\n      &lt;td&gt;â€¦&lt;/td&gt;\n      &lt;td&gt;â€¦&lt;/td&gt;\n      &lt;td&gt;â€¦&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/table&gt;\n&lt;/div&gt;\nVous devriez maintenant voir apparaÃ®tre une table dans votre div. Elle est austÃ¨re, dâ€™accord, mais vous pourrez la styliser aprÃ¨s. Pour le moment, on va faire avec. Regardez bien mes commentaires pour comprendre comment est structurÃ© le code. Regardez bien ces trois Ã©lÃ©mentsÂ :\n      &lt;td&gt;â€¦&lt;/td&gt;\n      &lt;td&gt;â€¦&lt;/td&gt;\n      &lt;td&gt;â€¦&lt;/td&gt;\nVous comprenez sÃ»rement quâ€™on souhaite remplacer ces â€œâ€¦â€ par des valeurs lorsquâ€™on clique sur un point de la couche. Il va donc falloir modifier cet Ã©lÃ©ment HTML avec nos fonctions JavaScript. Souvenez-vous quâ€™on utilise les identifiants pour retrouver les Ã©lÃ©ments HTML avec .getElementById(). DoncÂ :\n      &lt;td id=\"table-deal-id\"&gt;â€¦&lt;/td&gt;\n      &lt;td id=\"table-creation-date\"&gt;â€¦&lt;/td&gt;\n      &lt;td id=\"table-country\"&gt;â€¦&lt;/td&gt;\nMaintenant quâ€™on a nos Ã©lÃ©ments, il va falloir les remplir. Retournez chercher votre mÃ©thode map.on() dans votre code, on va devoir lâ€™amÃ©liorer un peu.\nmap.on('singleclick', (event) =&gt; {\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n\n  const parametres = { 'INFO_FORMAT': 'application/json' } // On a changÃ© un truc ici\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((json) =&gt; { // On a aussi changÃ© un truc ici et dans la fonction\n        const obj = JSON.parse(json);\n        console.log(obj);\n      });\n  }\n});\nTestez votre couche et regardez le rÃ©sultat dans la console. Si tout a fonctionnÃ©, vous devriez voir un objet JavaScriptÂ ! DÃ©pliez-le et prenez le temps de lâ€™explorer dans votre console pour comprendre ce que vous regardez. Lâ€˜information qui nous intÃ©resse est quelque part dans features. VoilÃ  ce quâ€™on doit faire avec la donnÃ©eÂ :\n\nvÃ©rifier quâ€™on a bien cliquÃ© sur une feature sur la carte (en JavaScript, Ã§a demande de vÃ©rifier quâ€™on a bien de la donnÃ©e dans features)\nrÃ©cupÃ©rer la feature sur laquelle jâ€™ai cliquÃ© pour pouvoir accÃ©der Ã  ses properties\nrÃ©cupÃ©rer mes cellules pour remplacer leur contenu\nremplacer le contenu des cellules de ma table avec les properties\n\nOn va procÃ©der petit Ã  petit. Dâ€™abord, on vÃ©rifie quâ€™on a bien une feature dans featureÂ :\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((json) =&gt; { // On a aussi changÃ© un truc ici et dans la fonction\n        const obj = JSON.parse(json);\n        if (obj.features[0]) {\n          console.log(\"Jâ€™ai cliquÃ© sur une featureÂ !\");\n        } else {\n          console.log(\"Jâ€™ai cliquÃ© Ã  cÃ´tÃ©â€¦\");\n        }\n      });\n  }\nOn utilise une condition if pour tester la prÃ©sence dâ€™une feature dans obj. obj.features[0] peut se traduire parÂ : â€œRÃ©cupÃ¨re mon tableau feature de mon obj et prends le premier Ã©lÃ©mentâ€. La condition regarde simplement si feature[0] est vide ou non. Si ce nâ€™est pas vide, on a reÃ§u quelque chose, on a donc cliquÃ© sur une feature. Au contraire, si câ€™est vide, câ€™est quâ€™on a cliquÃ© Ã  cÃ´tÃ©. Testez la fonction avant de passer Ã  la suite.\nSi on a bien rÃ©cupÃ©rÃ© une feature, cela veut dire quâ€™on peut rÃ©cupÃ©rer ses properties. Il suffit dâ€™ajouter au bon endroit de la fonction les deux lignes suivantesÂ :\nconst properties = obj.features[0].properties;\nconsole.log(properties);\nVous commencez Ã  comprendre comment on accÃ¨de Ã  un Ã©lÃ©ment dans un objet JavaScript. Il suffit dâ€™appeler la propriÃ©tÃ© quâ€™on veut avec .&lt;propriÃ©tÃ©&gt;. Regardez comment est structurÃ© votre objet properties dans la console du navigateur. Maintenant, modifiez la ligne console.log(properties); pour afficher la propriÃ©tÃ© target_country. Quand câ€™est rÃ©ussi, passez Ã  la suiteÂ !\nTrÃ¨s bien, on sait maintenant rÃ©cupÃ©rer des propriÃ©tÃ©s. Il ne nous reste plus quâ€™Ã  modifier le HTML de notre document en consÃ©quence en utilisant .innerHTMLÂ ! Je vous donne le code pour la colonne deal_id et je vous laisse complÃ©ter le code pour les deux autres colonnes.\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((json) =&gt; {\n        const obj = JSON.parse(json);\n        if (obj.features[0]) {\n          console.log(\"Jâ€™ai cliquÃ© sur une featureÂ !\");\n          const properties = obj.features[0].properties;\n          console.log(properties);\n          // On affiche deal_id dans notre table\n          document.getElementById('table-deal-id').innerHTML = properties.deal_id;\n        } else {\n          console.log(\"Jâ€™ai cliquÃ© Ã  cÃ´tÃ©â€¦\");\n          // On a cliquÃ© \"nulle part\" donc on remet des â€¦ dans la colonne \"deal_id\"\n          document.getElementById('table-deal-id').innerHTML = \"\";\n        }\n      });\n  }\nTestez votre application. Normalement, Ã§a marcheÂ ! Quand vous cliquez sur une feature, vous devriez rÃ©cupÃ©rer son ID. VoilÃ  comment on crÃ©e une table customisÃ©e pour interroger une coucheÂ ! Maintenant, Ã  vous de complÃ©ter les deux autres colonnes. Une fois que vous avez rÃ©ussi, ajoutez une colonne qui montre la valeur de mineral_resources pour le deal sur lequel vous cliquez. Et quand Ã§a aussi Ã§a fonctionne, prenez quelques minutes pour styliser votre tableÂ ! Google est votre ami (et ok, pourquoi pas ChatGPT si vous y tenez vraiiiiment, Ã§a ne me dÃ©range pas si câ€™est pour du CSS comme &lt;table&gt; commence Ã  Ãªtre complexe, mais on utilise lâ€™IA intelligemment svp).",
    "crumbs": [
      "Enrichir ma carte en fonctionnalitÃ©s"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#jai-fini-Ã§a-aussi",
    "href": "cours/geonum/enrichir_ma_carte.html#jai-fini-Ã§a-aussi",
    "title": "Enrichir ma carte en fonctionnalitÃ©s",
    "section": "Jâ€™ai fini Ã§a aussiÂ !",
    "text": "Jâ€™ai fini Ã§a aussiÂ !\nFantastiqueÂ ! Eh bien maintenant, dÃ©brouillez-vous pour ajouter une Ã©chelle Ã  votre carte. Ã‡a devrait vous occuper un moment, jâ€™espÃ¨re. Je vous donne Ã§a, Ã  vous de le mettre au bon endroitÂ :\nimport ScaleLine from 'ol/control/ScaleLine.js';\nUn autre morceau, pour crÃ©er lâ€™objet â€œÃ©chelleâ€Â :\nconst scaleline = new ScaleLine();\nEt enfin, trouvez comment ajouter Ã§a Ã  votre code existantÂ :\nconst map = new Map({\n  controls: [scaleline],\n});\nEt voilÃ Â !",
    "crumbs": [
      "Enrichir ma carte en fonctionnalitÃ©s"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#bon-ben-jai-aussi-une-Ã©chelle-sur-ma-carte",
    "href": "cours/geonum/enrichir_ma_carte.html#bon-ben-jai-aussi-une-Ã©chelle-sur-ma-carte",
    "title": "Enrichir ma carte en fonctionnalitÃ©s",
    "section": "Bon, ben jâ€™ai AUSSI une Ã©chelle sur ma carteâ€¦",
    "text": "Bon, ben jâ€™ai AUSSI une Ã©chelle sur ma carteâ€¦\nBravoÂ ! Vous pouvez rÃ©pÃ©ter Lâ€™Ã©tape finaleÂ ! pour build votre application. Ensuite, je vous conseille de commencer Ã  ajouter Ã  votre carte des Ã©lÃ©ments dont vous avez besoin pour vos projets GeoNum. Vous pourriez vouloir par exemple un curseur temporel, des tooltips, etc. Commencez par faire des recherches parmi les exemples dâ€™OpenLayers mais aussi dans les extensions disponibles sur ol-ext histoire de faire un tour des possibilitÃ©s.\nEt suivant le temps quâ€™on a, on peut Ã©ventuellement commencez Ã  regardez QGIS Server ensemble pendant le TP, sinon je vous ajouterai une petite notre sur le site si jamais vous prÃ©fÃ©rez lâ€™utiliser pour vos projets. Quoi quâ€™il en soit, vous ne serez pas notÃ©s dessusÂ !",
    "crumbs": [
      "Enrichir ma carte en fonctionnalitÃ©s"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#cette-fois-cest-vraiment-fini",
    "href": "cours/geonum/enrichir_ma_carte.html#cette-fois-cest-vraiment-fini",
    "title": "Enrichir ma carte en fonctionnalitÃ©s",
    "section": "Cette fois, câ€™est vraiment finiÂ !",
    "text": "Cette fois, câ€™est vraiment finiÂ !\nMerci pour votre attentionÂ !",
    "crumbs": [
      "Enrichir ma carte en fonctionnalitÃ©s"
    ]
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#sommaire",
    "href": "cours/geonum/slides_openlayers_td1.html#sommaire",
    "title": "Introduction Ã  OpenLayers",
    "section": "Sommaire",
    "text": "Sommaire\n\nSe familiariser avec le code de lâ€™application\nLes ressources OpenLayers\nConseils pour coder\nOn ajoute notre premiÃ¨re couche ensemble"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication",
    "title": "Introduction Ã  OpenLayers",
    "section": "Se familiariser avec le code de lâ€™application",
    "text": "Se familiariser avec le code de lâ€™application\nNode JS crÃ©e beaucoup dâ€™Ã©lÃ©ments mais voici ceux quâ€™on utiliseraÂ :\n\nindex.html\nstyle.css\nmain.js\n\nDeux autres explications Ã  titre dâ€™informationÂ :\n\nnode_modules/ contient notamment le code des librairies installÃ©es, câ€™est ici que vit le code source dâ€™OpenLayers\ndist/ contient lâ€™output du build du site, câ€™est les fichiers qui sont prÃªts Ã  Ãªtre servis par le serveur (pour nous, Caddy) pour mettre notre site en production"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-1",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-1",
    "title": "Introduction Ã  OpenLayers",
    "section": "Se familiariser avec le code de lâ€™application",
    "text": "Se familiariser avec le code de lâ€™application\nindex.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"https://openlayers.org/favicon.ico\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Using OpenLayers with Vite&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-2",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-2",
    "title": "Introduction Ã  OpenLayers",
    "section": "Se familiariser avec le code de lâ€™application",
    "text": "Se familiariser avec le code de lâ€™application\nindex.html\nUne rÃ©fÃ©rence pratique pour les balises htmlÂ : W3schools.com"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-3",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-3",
    "title": "Introduction Ã  OpenLayers",
    "section": "Se familiariser avec le code de lâ€™application",
    "text": "Se familiariser avec le code de lâ€™application\nstyle.css\n@import \"node_modules/ol/ol.css\";\n\nhtml, body {\n  margin: 0;\n  height: 100%;\n}\n#map {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n}"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-4",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-4",
    "title": "Introduction Ã  OpenLayers",
    "section": "Se familiariser avec le code de lâ€™application",
    "text": "Se familiariser avec le code de lâ€™application\nstyle.css\nDes rÃ©fÃ©rences pratiques pour Ã©crire du CSSÂ :\n\ncssreference.io pour la plupart des propriÃ©tÃ©s CSS\nW3schools.com pour les sÃ©lÃ©cteurs\ndâ€™excellents guides sur css-tricks.com pour utiliser grid ou flexbox"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-5",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-5",
    "title": "Introduction Ã  OpenLayers",
    "section": "Se familiariser avec le code de lâ€™application",
    "text": "Se familiariser avec le code de lâ€™application\nmain.js\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers",
    "href": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers",
    "title": "Introduction Ã  OpenLayers",
    "section": "Les ressources OpenLayers",
    "text": "Les ressources OpenLayers\nDâ€™abord, la documentation. Câ€™est la bible dâ€™OpenLayers et vous allez devoir apprendre Ã  la comprendre, au moins en partie, ou vous allez avoir beaucoup de mal Ã  comprendre ce que vous faites quand vous codez. Elle peut Ãªtre trouvÃ©e Ã  cette addresseÂ : https://openlayers.org/en/latest/apidoc/\n\nExemple dâ€™utilisation de la documentation pour lâ€™objet Map qui est crÃ©Ã© dans main.jsÂ :\nTapez â€œMapâ€ et cliquez sur le premier rÃ©sultat (lien ici). On voit en haut de la pageÂ :\n\nComment importer cet objet Map\nUne description de ce quâ€™est cet objet Map\nUn exemple (â€œsnippetâ€, petit morceau de code) qui montre comment utiliser Map\n\n\n\nQuand on continue Ã  dÃ©filer vers le bas, on voit plusieurs autres sectionsÂ :\n\nLa dÃ©finition de la fonction pour crÃ©er lâ€™objet Map et les options quâ€™il prend (new Map(options))\nLes Ã©vÃ¨nements qui peuvent Ãªtre dÃ©clenchÃ©s (â€œfiredâ€) par notre objet Map dans la section Fires:\nLes MÃ©thodes de lâ€™objet Map, donc les fonctions qui peuvent Ãªtre dÃ©clenchÃ©es avec cet objet Map pour gÃ©nÃ©ralement le lire ou le modifier"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-1",
    "href": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-1",
    "title": "Introduction Ã  OpenLayers",
    "section": "Les ressources OpenLayers",
    "text": "Les ressources OpenLayers\nPetit point UML pour mieux comprendre (jâ€™espÃ¨re)\n\n\n\n\n\nclassDiagram\n    class Map{\n        controls\n        pixelRatio\n        interactions\n        keyboardEventTarget\n        layers\n        maxTilesLoading\n        moveTolerance\n        overlays\n        target\n        view\n        +methodsâ€¦()\n    }\n\n\n\n\n\n\nOK câ€™est un peu compliquÃ©. Pour simplifier, on va prendre les Ã©lÃ©ments qui nous intÃ©ressent le plus."
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-2",
    "href": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-2",
    "title": "Introduction Ã  OpenLayers",
    "section": "Les ressources OpenLayers",
    "text": "Les ressources OpenLayers\nPetit point UML pour mieux comprendre (jâ€™espÃ¨re)\n\n\n\n\n\n\n\nclassDiagram\n    class Map{\n        target\n        layers\n        view\n        +addLayer()\n        +getlayers()\n        +getView()\n    }\n\n\n\n\n\n\n\nClasseÂ : Map\nAttributsÂ :\n\n\ntarget = lâ€™id de ma &lt;div&gt; qui va contenir ma carte\nlayers = les couches crÃ©Ã©es avec OpenLayers qui doivent Ãªtre ajoutÃ©es Ã  ma carte\nview = les paramÃ¨tres de la vue (centre, niveau de zoom) de ma carte lorsquâ€™elle est initialisÃ©e\n\n\nMÃ©thodesÂ :\n\n\naddLayer() = ajouter une couche crÃ©Ã©e avec OpenLayers Ã  ma carte\ngetLayers() = rÃ©cupÃ©rer les couches qui sont attachÃ©es Ã  ma carte\ngetView() = rÃ©cupÃ©rer les paramÃ¨tres de la vue actuelle (centre, niveau de zoom)"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-3",
    "href": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-3",
    "title": "Introduction Ã  OpenLayers",
    "section": "Les ressources OpenLayers",
    "text": "Les ressources OpenLayers\nLa galerie dâ€™exemples\nPour crÃ©er une carte sous OpenLayers, le point dâ€™entrÃ©e principal est la galerie dâ€™exemples. Je vous conseille vivement de toujours commencer par lÃ  avant dâ€™aller voir dâ€™autres ressources comme StackOverflow, etc. comme ce sont les exemples officiels qui sont maintenus Ã  jour et respectent les bonnes pratiques dâ€™utilisation du code OpenLayers.\nPar exemple, si vous souhaitez ajouter un flux WMS Ã  votre carte, basez-vous sur le code de lâ€™exemple Single Image WMS."
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#conseils-pour-coder",
    "href": "cours/geonum/slides_openlayers_td1.html#conseils-pour-coder",
    "title": "Introduction Ã  OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\n\n\nUtilisez des console.log() Ã  outrance pour vÃ©rifier quâ€™une fonction a bien Ã©tÃ© appelÃ©e, quâ€™une variable a bien Ã©tÃ© lue, etc.\nCopiez le code des exemples OpenLayers et essayez de le changer petit Ã  petit pour lâ€™adapter Ã  votre code.\nQuand vous voulez ajouter de nouveaux Ã©lÃ©ments, allez-y petit Ã  petit et vÃ©rifiez Ã  chaque Ã©tape que tout fonctionne, Ã§a permettra plus facilement de retrouver les bugs.\nUne des premiÃ¨res choses Ã  vÃ©rifier quand le code ne fonctionne pas est le nom des variables. Parfois on oublie un â€œsâ€, parfois on a ajoutÃ© une majusculeâ€¦\nCOMMENTEZ VOTRE CODEÂ ! Non seulement ce sera pris en compte dans lâ€™Ã©valuation, mais surtout vous allez galÃ©rer Ã  comprendre votre code en revenant dessus dans quelques mois et/ou les personnes avec qui vous allez travailler vont aussi mettre du temps Ã  vous comprendre."
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\nMaintenant, on va ajouter notre premiÃ¨re couche WMS ensemble.\n\nOuvrez votre projet dans VSCode (ou votre Ã©diteur prÃ©fÃ©rÃ©) si ce nâ€™est pas dÃ©jÃ  fait\nSi vous aviez arrÃªtÃ© votre serveur node, ouvrez un terminal dans votre dossier app et tapez npm start puis allez sur le lien localhost qu vous est donnÃ© pour rouvrir votre carte\n\n\nOpenLayers câ€™est comme toutÂ : avant de pouvoir partir en vrille et crÃ©er vos meilleures applications, il faut bien comprendre les bases.\nDonc au lieu de connecter notre couche WMS Ã  lâ€™aveugle, on va chercher Ã  comprendre comment câ€™est fait. Ci-dessous, un exemple dâ€™Ã©tudiants qui ont bien Ã©tudiÃ© les bases pour comprendre ce quâ€™ils font."
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-1",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-1",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\nğŸ¤” Quâ€™est-ce qui est diffÃ©rent dans index.htmlÂ ?\n\n\nle style nâ€™est pas dans style.css mais dans une balise de &lt;style&gt;. Nous on a dÃ©jÃ  un fichier de style qui fonctionne trÃ¨s bien et la carte en plein Ã©cran nous plait, on ne change rien.\n\n\n\n\nla balise &lt;div id=\"map\"&gt; a aussi une classe de style class = \"map\". Cela permet dâ€™appliquer le mÃªme style Ã  toutes les cartes avec la classe map. Nous on a une seule carte dans notre application, donc on sâ€™en moque.\n\n\n\nEn gros, on nâ€™a rien Ã  modifier dans index.html ni dans le fichier de style style.css. On peut passer au gros morceauÂ : le fichier de script main.js."
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-2",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-2",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\nğŸ¤” Quâ€™est-ce qui est diffÃ©rent dans main.jsÂ ?\n\nğŸ‘† Mon conseilÂ : au dÃ©but, ignorez toute la section import qui peut sembler un peu floue et concentrer vous sur les variables qui sont dÃ©finies dans le code, puis sur les objets OpenLayers.\n\n\n\n\nNotre codeÂ :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de lâ€™exempleÂ :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-3",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-3",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\n\n\nNotre codeÂ :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de lâ€™exempleÂ :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-4",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-4",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\n\n\nNotre codeÂ :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de lâ€™exempleÂ :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-5",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-5",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\n\n\nNotre codeÂ :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de lâ€™exempleÂ :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-6",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-6",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\n\n\nNotre codeÂ :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de lâ€™exempleÂ :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-7",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-7",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\nLe code de lâ€™exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-8",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-8",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\nDe quoi jâ€™ai besoin pour ajouter une couche WMS Ã  ma carteÂ ?\n\n\nIl nous faut une source pour le flux WMS quâ€™on crÃ©e avec lâ€™objet ImageWMS (documentation)\nIl nous faut un objet ImageLayer pour crÃ©er notre couche Ã  partir de notre source\nIl nous faut un objet Map (dÃ©jÃ  crÃ©Ã© dans notre cas) auquel ajouter la couche\n\n\n\nMa proposition de code pour crÃ©er une couche (en retirant les Ã©lÃ©ments superflus pour simplifier)Â :\nconst ma_source = new ImageWMS({\n  url: '&lt;lien_vers_mon_serveur&gt;',\n  params: {'LAYERS': '&lt;espace&gt;:&lt;couche&gt;'},\n  serverType: 'geoserver',\n});\n\nconst ma_couche = new ImageLayer({\n  source: ma_source,\n});\n\n\nOn pourrait aussi lâ€™Ã©crire en imbriquant tout comme dans lâ€™exemple, mais je prÃ©fÃ¨re sÃ©parer les Ã©lÃ©ments, je trouve Ã§a moins confus (surtout quand on apprend).\nconst ma_couche = new ImageLayer({\n  source: new ImageWMS({\n    url: '&lt;lien_vers_mon_serveur&gt;',\n    params: {'LAYERS': '&lt;espace&gt;:&lt;couche&gt;'},\n    serverType: 'geoserver',\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-9",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-9",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\nIl nous manque un dernier dÃ©tailÂ : les imports. Si vous utilisez le code tel quel, vous allez avoir des messages dâ€™erreur indiquant que les fonctions ne sont pas trouvÃ©es. Vous pouvez trouver les imports de trois maniÃ¨resÂ :\n\nvous regardez les imports dans lâ€™exemple OpenLayers et vous rÃ©cupÃ©rez ceux dont vous avez besoin (lien)\nvous allez voir la documentation de ImageWMS par exemple et la premiÃ¨re ligne vous indique comment importer le module dans votre code (lien)\nsi votre Ã©diteur de code est bien fichu, il peut lui-mÃªme ajouter un import quand vous appelez un constructeur ou une mÃ©thode dans votre code\n\nğŸ‘† Dâ€™ailleurs, nâ€™oubliez pas que les import doivent toujours Ãªtre dÃ©clarÃ©s tout en haut du documentÂ !"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-10",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-premiÃ¨re-couche-ensemble-10",
    "title": "Introduction Ã  OpenLayers",
    "section": "On ajoute notre premiÃ¨re couche ensemble",
    "text": "On ajoute notre premiÃ¨re couche ensemble\nVoici mon rÃ©sultat pour importer la couche de lâ€™exemple dâ€™OpenLayersÂ :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport { ImageWMS } from 'ol/source';\nimport TileLayer from 'ol/layer/Tile';\nimport ImageLayer from 'ol/layer/Image';\nimport OSM from 'ol/source/OSM';\n\nconst couche_osm = new TileLayer({ source: new OSM() });\n\nconst ma_source = new ImageWMS({\n  url: 'https://ahocevar.com/geoserver/wms',\n  params: { 'LAYERS' : 'topp:states' },\n  serverType: 'geoserver',\n});\n\nconst ma_couche = new ImageLayer({\n  source: ma_source,\n});\n\nconst map = new Map({\n  target: 'map',\n  layers: [ couche_osm, ma_couche ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#Ã -vous",
    "href": "cours/geonum/slides_openlayers_td1.html#Ã -vous",
    "title": "Introduction Ã  OpenLayers",
    "section": "Ã€ vousÂ !",
    "text": "Ã€ vousÂ !\nVous allez pouvoir commencer le TP suivant pour commencer Ã  ajouter vos couches dans votre application OpenLayers.\nCâ€™est partiÂ !\n\n\n\n\n\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#sommaire",
    "href": "cours/geonum/slides_le_point_technique.html#sommaire",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Sommaire",
    "text": "Sommaire\n\nPrÃ©sentation brÃ¨ve dâ€™OpenLayers\nLes bases de Node JS\nDe quelle architecture on a besoinÂ ?\nVMs, Docker et Docker Compose\nNotre Docker Compose\n\nEt si on avance bien, aujourdâ€™hui on aura non pas UN mais DEUX coursÂ ! Alors ne perdons pas de temps et en avantÂ !"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#prÃ©sentation-brÃ¨ve-dopenlayers",
    "href": "cours/geonum/slides_le_point_technique.html#prÃ©sentation-brÃ¨ve-dopenlayers",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "PrÃ©sentation brÃ¨ve dâ€™OpenLayers",
    "text": "PrÃ©sentation brÃ¨ve dâ€™OpenLayers\n\nOpenLayers est une librairie JavaScript Open Source qui permet de crÃ©er des cartes interactives pour le web.\nLa librairie a plus de 11Â 000 stars sur GitHub et 3Â 000 forks.\nAu moment oÃ¹ jâ€™Ã©cris ce cours, la derniÃ¨re mise Ã  jour date dâ€™il y a deux jours.\nLâ€™alpha dâ€™OpenLayers (premiÃ¨re version mise en ligne sur GitHub) date de 2013.\n\nCâ€™est une librairie populaire, mature, maintenue et bien documentÃ©e."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#prÃ©sentation-brÃ¨ve-dopenlayers-1",
    "href": "cours/geonum/slides_le_point_technique.html#prÃ©sentation-brÃ¨ve-dopenlayers-1",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "PrÃ©sentation brÃ¨ve dâ€™OpenLayers",
    "text": "PrÃ©sentation brÃ¨ve dâ€™OpenLayers\nğŸ¤” Ã‡a ressemble en tout point Ã  Leaflet, nonÂ ? Alors pourquoi apprendre les deuxÂ ?\n\nğŸ‘‰ Oui et nonÂ !\n\nLeaflet est plus pratique pour obtenir rapidement une â€œjolieâ€ carte avec moins de code, par exemple afficher/masquer les couches.\nMais Leaflet a aussi ses dÃ©fautsÂ : la carte est plus difficile Ã  customiser â€œen profondeurâ€ quâ€™OpenLayers, il y a de nombreux plug-ins qui parfois font plus ou moins la mÃªme chose, parfois ne sont plus maintenus, lÃ  oÃ¹ beaucoup de ces fonctionnalitÃ©s sont disponibles dans le code de base dâ€™OpenLayers.\n\n\n\nPour faire simple, selon mon expÃ©rience avec les deux librairies, OpenLayers est plus facilement customisable et se repose moins sur des plug-ins externes. Il existe une source de plug-ins pour ajouter des fonctionnalitÃ©s supplÃ©mentaires publiÃ©e par lâ€™utilisateur GitHub viglino. Ces extensions ol-ext sont rÃ©guliÃ¨rement maintenues."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#prÃ©sentation-brÃ¨ve-dopenlayers-2",
    "href": "cours/geonum/slides_le_point_technique.html#prÃ©sentation-brÃ¨ve-dopenlayers-2",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "PrÃ©sentation brÃ¨ve dâ€™OpenLayers",
    "text": "PrÃ©sentation brÃ¨ve dâ€™OpenLayers\nIl est donc intÃ©ressant de savoir utiliser Ã  la fois Leaflet et OpenLayers car chacune des librairies a ses points forts et ses faiblesses.\nCela dit, en ce qui concerne un usage simplifiÃ©, si vous comprenez Leaflet vous comprenez aussi OpenLayers.\n\nOn va devoir crÃ©er une application Node JS pour pouvoir importer la librairie OpenLayers et commencer Ã  coder."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js",
    "href": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Les bases de Node JS",
    "text": "Les bases de Node JS\nNode JS, câ€™est ce quâ€™on appelle un environnement runtime de JavaScript.\nVoilÃ . On continueÂ ?"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js-1",
    "href": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js-1",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Les bases de Node JS",
    "text": "Les bases de Node JS\nPour simplifier, voyons comment vous Ã©crivez et exÃ©cutez votre code JavaScript jusquâ€™Ã  maintenant.\n\nOn crÃ©e un document index.html dans lequel on met quelque part une balise &lt;script&gt;\nOn Ã©crit le code dans la balise &lt;script&gt;\nOn ouvre index.html dans le navigateur\nComme le JavaScript est dans index.html qui est ouvert dans un navigateur, le navigateur peut exÃ©cuter le code JavaScript\n\nCe nâ€™est pas super pratique quand on commence Ã  avoir une application qui grandit (ou â€œscaleâ€)."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js-2",
    "href": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js-2",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Les bases de Node JS",
    "text": "Les bases de Node JS\nLa force de Node JS est de permettre dâ€™exÃ©cuter du code Ã©crit en JavaScript sans passer par le navigateur. Si par la suite vous devez Ã©crire du code cÃ´tÃ© serveur, vous pouvez aussi le faire en JavaScript. Et surtout, Node JS permet de tÃ©lÃ©charger facilement des librairies et dÃ©ployer encore plus facilement notre application pour la mettre en production en utilisant quelques lignes de commande."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#un-serveur-pour-mon-appli-web",
    "href": "cours/geonum/slides_le_point_technique.html#un-serveur-pour-mon-appli-web",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Un serveur pour mon appli web",
    "text": "Un serveur pour mon appli web\nVous vous souvenez sÃ»rement du premier cours de Leaflet."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#un-serveur-pour-mon-appli-web-1",
    "href": "cours/geonum/slides_le_point_technique.html#un-serveur-pour-mon-appli-web-1",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Un serveur pour mon appli web",
    "text": "Un serveur pour mon appli web\nVous avez â€œtrichÃ©â€ pour Ã©viter dâ€™avoir Ã  utiliser un serveur. Mais maintenant, Ã§a ne vous fait plus peur. AprÃ¨s tout, on a bien utilisÃ© un serveur carto la derniÃ¨re fois et tout le monde a survÃ©cu. Maintenant, on va pouvoir Ã©crire une application web plus complexe, bien la structurer grÃ¢ce Ã  Node JS, et la servir sur un serveur web."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#de-quelle-architecture-on-a-besoin",
    "href": "cours/geonum/slides_le_point_technique.html#de-quelle-architecture-on-a-besoin",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "De quelle architecture on a besoinÂ ?",
    "text": "De quelle architecture on a besoinÂ ?\nFacileÂ ! On veutÂ :\n\nun serveur webcarto (GeoServer)\nmais aussi un serveur web pour servir notre application.\n\nDurant le premier TP, on a utilisÃ© Docker pour dÃ©ployer notre GeoServer. On peut aussi dÃ©ployer notre serveur web avec Docker. Mais Ã§a voudrait dire quâ€™Ã  chaque fois, on aurait deux containers diffÃ©rents Ã  allumer et Ã©teindre, quâ€™il faut faire attention Ã  ne pas les configurer de travers, ne pas oublier les lignes de commande quâ€™on a tapÃ©esâ€¦\n\nHeureusement, Docker dispose dâ€™un petit outil bien pratique pour gÃ©rer des architectures Ã  plusieurs containersÂ : Docker Compose. Sauf que pour comprendre Docker Compose, il faut comprendre Docker. Et pour comprendre Docker, il faut comprendre les Machines Virtuelles (VM)."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nEncore de la thÃ©orieÂ ?!\n\nOn ne va pas rentrer dans le dÃ©tail, lâ€™idÃ©e est que vous compreniez pourquoi on a utilisÃ© Docker et pas des machines virtuelles pour nos serveurs. Docker, câ€™est bien. Si vous dÃ©ployez des architectures par la suite, vous allez apprendre Ã  lâ€™aimer."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-1",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-1",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nLes Machines Virtuelles (VM)\n\nIl faut voir une machine virtuelle comme un ordinateur qui serait dÃ©matÃ©rialisÃ© (sans composants matÃ©riels). Elle possÃ¨de un processeur, de la mÃ©moire, des espaces de stockage pour la donnÃ©e, elle peut se connecter Ã  internetâ€¦\nOutils de crÃ©ation de machines virtuellesÂ : VirtualBox, VMWareâ€¦\n\nExempleÂ : en tÃ©lÃ©chargeant VirtualBox, je peux crÃ©er une machine virtuelle Linux sur mon ordinateur Windows.\n\nSource : microsoft.com"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-2",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-2",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nLes Machines Virtuelles (VM)\nSi je voulais mettre en place mon serveur sur une machine virtuelle, je devraisÂ :\n\ncrÃ©er la machine (avec des caractÃ©ristiques suffisantes pour faire tourner lâ€™application)\ninstaller et configurer mon serveur web (Apache, Nginx, Caddy)\najouter le build de mon application Node JS dans le dossier /var/www/ de mon serveur web\ntÃ©lÃ©charger, installer et configurer GeoServer\nÃ©ventuellement tÃ©lÃ©charger, installer et configurer une base Postgresql avec PostGIS et la connecter au serveur\netc."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-3",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-3",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nLes Machines Virtuelles (VM)\nMultiplier les machines virtuelles sur lâ€™hÃ´te est trÃ¨s demandeur.\n\nressources divisÃ©es entre lâ€™hÃ´te et les machines\nautant dâ€™OS Ã  faire tourner que de machines\nchaque machine = plusieurs Go dâ€™espace\n\nCâ€™est aussi difficile Ã  maintenir - il faut garder tous les OS Ã  jour, etc.\nMais nous, on aime la simplicitÃ© et Ã©viter de consommer plein de mÃ©moire â€œpour rienâ€."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-4",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-4",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nDocker\n\nDocker permet de faire tourner ce quâ€™on appelle des containers.\nLes containers sont rÃ©duits au minimum nÃ©cessaire pour faire tourner des services (un serveur, une base de donnÃ©es, â€¦).\nAutre outil de containerisationÂ : Podman\n\n\nSource : microsoft.com"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-5",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-5",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nDocker Compose\n\nSorti en 2013, Docker Compose permet de gÃ©rer des applications multi-containers.\nPour cela, on va rÃ©diger un fichier de type docker-compose.yml qui va agir comme une â€œrecetteâ€ pour permettre Ã  Docker de crÃ©er et connecter lâ€™ensemble des containers dont on a besoin."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#notre-docker-compose",
    "href": "cours/geonum/slides_le_point_technique.html#notre-docker-compose",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Notre Docker Compose",
    "text": "Notre Docker Compose\nExplications sur le contenuÂ :\nservices:\n\n  geoserver:\n    container_name: geonum_geoserver\n    image: docker.osgeo.org/geoserver:2.26.0\n    environment:\n      - RUN_UNPRIVILEGED=true\n      - CHANGE_OWNERSHIP_ON_FOLDERS=\"/opt /opt/geoserver_data/ /mnt/geoserver_geodata\"\n      - CORS_ENABLED=true\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - $PWD/geoserver/opt:/opt/geoserver_data\n  \n  web:\n    container_name: geonum_web\n    image: caddy:latest\n    ports:\n      - \"80:80\"\n    volumes:\n      - $PWD/Caddyfile:/etc/caddy/Caddyfile\n      - $PWD/app/dist/:/srv"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#Ã -vous",
    "href": "cours/geonum/slides_le_point_technique.html#Ã -vous",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Ã€ vous !",
    "text": "Ã€ vous !\nCommencez le TP â€œdÃ©marrage de la stackâ€ pour mettre en place vos containersÂ ! Ensuite, on pourra se pencher un peu plus sur le cas dâ€™OpenLayers.\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html",
    "href": "cours/geonum/serveurs_carto.html",
    "title": "Serveurs cartographiques",
    "section": "",
    "text": "Comprendre ce quâ€™est un serveur cartographique et ce que sont les flux WMS, WFS, etc.\nConnaÃ®tre les principaux serveurs cartographiques avec un focus sur GeoServer, un serveur cartographique Open-Source.\nApprendre Ã  dÃ©ployer une instance de GeoServer Ã  lâ€™aide de Docker.\nPublier des couches avec GeoServer et les styliser en passant par QGIS.\nLire les flux WMS de mon GeoServer dans une application OpenLayers basique.\nÃŠtre capable de dÃ©terminer dans quelles situations on a besoin dâ€™un serveur cartographique.",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#objectifs",
    "href": "cours/geonum/serveurs_carto.html#objectifs",
    "title": "Serveurs cartographiques",
    "section": "",
    "text": "Comprendre ce quâ€™est un serveur cartographique et ce que sont les flux WMS, WFS, etc.\nConnaÃ®tre les principaux serveurs cartographiques avec un focus sur GeoServer, un serveur cartographique Open-Source.\nApprendre Ã  dÃ©ployer une instance de GeoServer Ã  lâ€™aide de Docker.\nPublier des couches avec GeoServer et les styliser en passant par QGIS.\nLire les flux WMS de mon GeoServer dans une application OpenLayers basique.\nÃŠtre capable de dÃ©terminer dans quelles situations on a besoin dâ€™un serveur cartographique.",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#cours",
    "href": "cours/geonum/serveurs_carto.html#cours",
    "title": "Serveurs cartographiques",
    "section": "Cours",
    "text": "Cours\nSlidesÂ : Serveurs Cartographiques",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#tp---prise-en-main-de-geoserver",
    "href": "cours/geonum/serveurs_carto.html#tp---prise-en-main-de-geoserver",
    "title": "Serveurs cartographiques",
    "section": "ï¸TP - Prise en main de GeoServer",
    "text": "ï¸TP - Prise en main de GeoServer\n\nDÃ©ploiement de GeoServer Ã  lâ€™aide de Docker\nDocumentation GeoServer - DÃ©pÃ´t de lâ€™image Docker\n\n\n\n\n\n\nImportant\n\n\n\nCe TP suppose que Docker est installÃ© sur la machine. Il a Ã©tÃ© Ã©crit pour une machine Linux, certains chemins et lignes de commande peuvent donc Ãªtre diffÃ©rents sur une machine Windows ou Mac.\n\n\nUne fois que Docker est installÃ©, lancez la commande suivante pour tÃ©lÃ©charger une image de GeoServer en version 2.26.0Â :\ndocker pull docker.osgeo.org/geoserver:2.26.0\nPuis, pour construire un container Ã  partir de lâ€™image de GeoServerÂ :\ndocker run -it -p 80:8080 docker.osgeo.org/geoserver:2.26.0\nSi vous nâ€™avez pas eu de message dâ€™erreur, rendez-vous sur http://localhost/geoserver et connectez-vous avec lâ€™identifiant admin et le mot de passe geoserver. Si lâ€™authentification a fonctionnÃ©, fÃ©licitations, vous avez rÃ©ussi Ã  faire tourner un container avec GeoServerÂ !\n\n\n\n\n\n\nAttends, attendsâ€¦ des containers, des imagesÂ ? HeinÂ ?\n\n\n\n\n\n\n\n\n\n\nPas de paniqueÂ ! On nâ€™a pas besoin de savoir exactement comment fonctionne Docker pour ce TP. Si on veut simplifierÂ :\n\nDocker permet de faire tourner des services dans des containers crÃ©Ã©s Ã  partir dâ€™images.\nUne image est une recette Ã  suivre pour crÃ©er mon container. Elle demande Ã  Docker de crÃ©er un container basÃ© sur Debian, dâ€™y installer GeoServer ou bien une base PostgreSQL avec lâ€™extension postGIS, etc.\nUn container est le produit dâ€™une image. Câ€™est un peu le plat cuisinÃ© Ã  partir de la recette. Câ€™est Ã  lâ€™intÃ©rieur du container que tourne mon service comme ma base de donnÃ©es ou mon serveur web. On peut connecter plusieurs containers entre eux, pratique si on veut un site web et une base de donnÃ©es qui fonctionnent ensembleÂ !\nUn service est gÃ©nÃ©ralement une base de donnÃ©es (ex. PostgreSQL), un serveur de site web (ex. Apache), un serveur cartographique (ex. GeoServer), etc. Comme les bonnes pratiques demandent dâ€™avoir un seul service par container, on va parler du â€œcontainer GeoServerâ€ pour dire â€œle container qui contient mon service GeoServerâ€, Ã§a va plus vite.\n\nSi ce nâ€™est encore pas clair et que Ã§a vous gÃªne pour la comprÃ©hension de la suite du TP, hop, on lÃ¨ve la main et on demande des explications, je suis lÃ  pour Ã§aÂ ! Et si vous voulez aller plus loin, rendez-vous sur la documentation officelle de Docker.\n\n\n\nPour vÃ©rifier que tout fonctionne, on va faire une petite manip rapide.\n\nEn haut Ã  droite de lâ€™Ã©cran, si ce nâ€™est pas dÃ©jÃ  le cas, sÃ©lectionnez le langage â€œfrâ€ pour passer lâ€™interface en franÃ§ais.\nAllez dans â€œEspaces de travailâ€ (menu Ã  gauche de lâ€™Ã©cran) et cliquez sur le bouton â€œAjouter un nouvel espace de travailâ€.\nAppelez-le â€œmon_espaceâ€ et donnez lui un URI mon_espace.\nVÃ©rfiez quâ€™il apparaÃ®t bien dans la liste de vos espaces (normalement, au-dessus de â€œneâ€).\n\nEnsuite, on va arrÃªter notre container Docker. Commencez par utiliser la commande suivanteÂ :\ndocker ps\nVous devriez voir apparaÃ®tre une ligne avec lâ€™ID de votre container dans la colonne CONTAINER ID, lâ€™image utilisÃ©e pour le construire dans la colonne IMAGE, dâ€™autres informations qui ne nous servent pas dans ce TP et son nom dans la colonne NAME. La commande docker ps permet de lister les containers actifs en ce moment. On souhaite arrÃªter notre container avec la commande docker stop &lt;container_name&gt;. Pour cela, il faut utiliser le nom du container Ã  la place de &lt;container_name&gt;. Par exemple, voici les informations de mon containerÂ :\nCONTAINER ID   IMAGE                               COMMAND                  CREATED         STATUS                            PORTS                                     NAMES\n0a885cadf11d   docker.osgeo.org/geoserver:2.26.0   \"bash /opt/startup.sh\"   8 seconds ago   Up 7 seconds (health: starting)   0.0.0.0:80-&gt;8080/tcp, [::]:80-&gt;8080/tcp   charming_pare\nLe nom de mon container est donc charming_pare. Pour arrÃªter mon container, je dois taper la commande suivanteÂ :\ndocker stop charming_pare\n\n\n\n\n\n\nTip\n\n\n\nQuand on tape des lignes de commande en bash, utilisez la touche tab pour auto-complÃ©ter la commande. Par exemple, ici, jâ€™ai seulement tapÃ© docker stop ch puis appuyÃ© sur tab qui a complÃ©tÃ© le nom de mon container. Pratique, nonÂ ? Nâ€™hÃ©sitez pas Ã  en abuser. Si lâ€™auto-complete ne fonctionne pas, câ€™est quâ€™il ne trouve rien OU plusieurs rÃ©sultats. Dans ce cas, continuez Ã  Ã©crire la commande Ã  la main et rÃ©essayez.\n\n\nUtilisez Ã  nouveau la commande docker ps pour vÃ©rifier que ce container nâ€™apparaÃ®t plus dans la liste. Normalement, si vous actualisez la page GeoServer, vous devriez avoir une erreur du type â€œlocalhost refused to connectâ€.\nAlors, câ€™est bien sympa tout Ã§a, mais en lâ€™Ã©tat, on ne va pas pouvoir ajouter de donnÃ©es dans notre container. Il faudrait pouvoir accÃ©der au dossier /data de GeoServer. Heureusement, pour nous simplifier la vie, on peut utiliser Docker pour â€œconnecterâ€ deux dossiers en eux (monter, mount en anglais). Pour Ã§a, il faut crÃ©er sur notre ordinateur un nouveau dossier dans lequel on mettra tout ce quâ€™on veut retrouver dans le /data de notre GeoServer. Promis, câ€™est la derniÃ¨re Ã©tape aussi technique, ensuite je me dÃ©tends et jâ€™arrÃªte de vous faire taper autant de lignes de commande.\n\n\n\n\n\nDâ€™abord, on supprime notre container. On va en crÃ©er un nouveau dans les Ã©tapes suivantes.\ndocker rm &lt;nom_du_container&gt;\nEnsuite, on va crÃ©er un dossier Ã  monter sur le /data de notre container.\n\nAllez dans Documents et crÃ©er un nouveau dossier â€œGeoServerâ€.\nCopiez le chemin ABSOLU vers ce dossier. Par exemple, chez moi (Ubuntu), Ã§a donne Ã§aÂ : /home/marie/Documents/GeoServer\nRemplacez \"/absolute/path/on/host\" dans la commande suivante et copiez-collez la quelque part, on ne sait jamais.\n\ndocker run -it -p 80:8080 --mount src=\"/absolute/path/on/host\",target=/opt/geoserver_data/,type=bind docker.osgeo.org/geoserver:2.26.0\n\nExÃ©cutez la ligne de commande.\n\nMaintenant, on va ajouter notre jeu de donnÃ©es land_matrix_mines Ã  notre dossier /data.\n\nTÃ©lÃ©chargez le jeu de donnÃ©es land_matrix_mines.\nDans lâ€™explorateur de fichiers de votre ordinateur, ouvrez votre dossier GeoServer. Normalement, vous auriez du voir apparaÃ®tre plusieurs nouveaux dossiers. Allez dans /data et crÃ©ez un nouveau dossier geopackage.\nGlissez le fichier land_matrix_mines.gpkg dans le dossier geopackage.\n\n\n\n\n\n\n\nJe ne peux pas crÃ©er de nouveau dossier / dÃ©placer mon fichier !\n\n\n\n\n\nSi vous ne pouvez pas crÃ©er de nouveau dossier, câ€™est que vous ne disposez pas des permissions suffisantes. Dans mon cas (sur Ubuntu), tous les dossiers appartenaient Ã  lâ€™utilisateur et au groupe root. Il faut utiliser la commande chownÂ :\nsudo chown -R &lt;user&gt;:&lt;group&gt; /chemin/vers/mon/dossier\nPour changer les droits de mon dossier `/home/marie/Documents/GeoServer` jâ€™ai donc tapÃ©Â :\nsudo chown -R marie:marie /home/marie/Documents/GeoServer\nSi Ã§a ne fonctionne pas, ne restez pas bloquÃ©s et appelez-moi, on rÃ¨gle Ã§a ensemble.\n\n\n\nCâ€™est bon, Ã§a fonctionneÂ ? ParfaitÂ ! Les rÃ¨gles pour arrÃªter et dÃ©marrer son container restent les mÃªmes. Tout ce quâ€™il faut retenir, câ€™est quâ€™il ne faut pas supprimer ou dÃ©placer votre dossier GeoServer sous peine de tout casser. Pour le reste, tout devrait fonctionner tranquillement.\n\n\n\n\n\n\nRappel des commandes principales\n\n\n\n\n\n# Lister les containers actifs\ndocker ps\n\n# Lister tous les containers, mÃªme arrÃªtÃ©s\ndocker ps -a\n\n# DÃ©marrer mon container\ndocker start &lt;nom_du_container&gt;\n\n# ArrÃªter mon container\ndocker stop &lt;nom_du_container&gt;\n\n# /!\\ Supprimer mon container\ndocker rm &lt;nom_du_container&gt;\n\n\n\nVous avez survÃ©cu au dÃ©ploiement du GeoServer, bien jouÃ©Â ! Prenez un moment pour souffler, allez vous chercher un cafÃ©. La suite sera beaucoup moins prise de tÃªte, câ€™est promisÂ !\n\n\n\n\n\n\n\nEspaces de travail, EntrepÃ´ts et Couches\nCrÃ©er un espace de travail, câ€™est facile, on vient de le faire. Maintenant, on va crÃ©er un nouveau dÃ©pÃ´t par dÃ©faut quâ€™on appellera land_matrix et dans lequel on ajoutera notre geopackage.\n\nAllez dans â€œEspaces de travailâ€ et cliquez sur â€œAjouter un nouvel espace de travailâ€.\nNommez lâ€™espace de travail â€œland_matrixâ€ et donnez lui lâ€™URI â€œland_matrixâ€.\nCochez â€œEspace de travail par dÃ©fautâ€.\nCiquez sur â€œSauvegarderâ€.\n\nSi tout va bien, on voit maintenant notre espace â€œland_matrixâ€ dans la liste. On va pouvoir ajouter un entrepÃ´t de donnÃ©es dans notre espace.\n\nAllez dans â€œEntrepÃ´tsâ€ et cliquez sur â€œAjouter un nouvel entrepÃ´tâ€. Vous allez voir une liste de tous les types dâ€™entrepÃ´ts de donnÃ©es qui peuvent Ãªtre ajoutÃ©s Ã  votre espace de travail, par exempe du GeoPackage, une base PostGIS, un Shapefile ou encore un flux WMS distant.\nSÃ©lectionnez â€œGeoPackageâ€.\nNommez la source de donnÃ©es â€œland_matrix_minesâ€ et ajoutez une petite description, par exemple â€œTransactions miniÃ¨res de la Land Matrix, 2024â€.\nDans â€œParamÃ¨tres de connexionâ€ cliquez sur â€œParcourirâ€¦â€ Ã  droite de â€œdatabase *â€.\nAllez dans data/geopackage/ et cliquez sur le jeu de donnÃ©es land_matrix_mines.gpkg.\nVidez le champ â€œpasswdâ€.\nCliquez sur â€œSauvegarderâ€.\n\nUne fois de retour sur la page â€œEntrepÃ´tsâ€, vous devriez voir votre entrepÃ´t â€œland_matrix_minesâ€ associÃ© Ã  lâ€™espace de travail â€œland_matrixâ€. On avanceÂ ! Maintenant, on veut publier et lire des couches.\n\nAllez dans â€œCouchesâ€ et cliquez sur â€œAjouter une nouvelle coucheâ€.\nSÃ©lectionnez â€œland_matrix:land_matrix_minesâ€. Vous devriez voir apparaÃ®tre une liste de couches.\nCliquez sur â€œPublierâ€ Ã  droite de la couche â€œdealsâ€.\n\nLâ€™onglet de publication de couche permet de configurer la couche et dâ€™y ajouter de la mÃ©tadonnÃ©e. Dans ce TP, on se concentrera sur les informations â€œcrucialesâ€ pour dÃ©finir une couche, mais vous pourrez toujours allez plus loin en utilisant la documentation GeoServer sur les couches.\nLes trois choses Ã  faire absolument Ã  chaque fois dans lâ€™onglet donnÃ©es sontÂ :\n\nRenseigner les informations dans â€œInformations de base sur les donneÃ©sâ€ comme le nom de la couche et un rÃ©sumÃ©. Nâ€™oubliez pas de laisser â€œActivÃ©â€ et â€œPubliÃ©â€ cochÃ©s pour rendre la couche accessible depuis lâ€™extÃ©rieur.\nVÃ©rifier le â€œSystÃ¨me de RÃ©fÃ©rence de CoordonnÃ©es (SRC)â€ qui doit Ãªtre prÃ©-rempli en EPSG:4326 dans notre cas. Il correspond Ã  la projection WGS84 utilisÃ©e dans la grande majoritÃ© des cas en cartographie web.\nDÃ©finir les â€œEmprisesâ€ qui se calculent automatiquement sur GeoServer en cliquant sur â€œCalculer depuis les limites du SRSâ€ et â€œCalculÃ©es sur les emprises nativesâ€.\n\nCliquez ensuite sur â€œAppliquerâ€ pour sauvegarder vos changements et scrollez en haut de la page pour accÃ©der Ã  lâ€™onglet â€œPublicationâ€.\n\nDans â€œParamÃ¨tres de coucheâ€, cochez Interrogeable et vÃ©rifiez que le style par dÃ©faut est bien â€œpointâ€.\n\nCliquez sur â€œSauvegarderâ€. La couche devrait maintenant apparaÃ®tre au sommet du tableau. Cliquez simplement sur le nom de la couche (ici â€œdealsâ€) pour la paramÃ©trer Ã  nouveau si besoin. Pour vÃ©rifier que tout a fonctionnÃ©, on peut prÃ©visualiser la couche directement depuis GeoServer.\n\nAllez dans â€œPrÃ©visualisation de la Coucheâ€ (menu Ã  gauche de lâ€™Ã©cran).\nSur la ligne de la couche â€œdealsâ€, sÃ©lectionnez â€œOpenLayersâ€.\n\nVous devriez voir apparaÃ®tre quelque chose comme Ã§a, avec des informations supplÃ©mentaires si vous cliquez sur des points (possible car notre couche est interrogeable)Â :\n\n\n\n\n\nSi câ€™est bon, bravo, Ã§a a fonctionnÃ© ! Si vous voyez des artefacts autour des points, câ€™est normal. Ce que vous regardez, ce ne sont pas des polygones mais une image produite Ã  partir de notre couche et transmise comme un flux WMS par notre serveur. Lâ€™intÃ©rÃªt, câ€™est quâ€™on peut afficher rapidement des couches trÃ¨s lourdes de cette maniÃ¨re, lÃ  oÃ¹ un GeoJSON commencerait Ã  ramer. Et on peut toujours zoomer et cliquer sur un point pour lâ€™interroger. Câ€™est super pratiqueÂ ! Ce flux WMS est rÃ©cupÃ©rÃ© et lu par une petite appli OpenLayers, câ€™est comme Ã§a que vous Ãªtes capable de voir la couche sur votre page web (vous sentez venir la transition vers les prochains cours, lÃ Â ?).\nBon, super, on a notre couche moche. Maintenant, on en fait quoi de tous ces points rougesÂ ?\n\n\n\n\n\nFacile. On va dâ€™abord la rendre un peu plus belle, puis on va la lire dans notre propre application OpenLayers et commencer Ã  faire des trucs cools avec. Mais avant, comme vous avez tout compris Ã  ce quâ€™on vient de faire, ajoutez toutes les autres couches du geopackage Ã  votre espace de travail. Quand vous avez rÃ©ussi Ã  toutes les prÃ©visualiser (et pleurÃ© devant leur style austÃ¨re), crÃ©ez un nouveau projet QGIS et importez aussi ces couches.\n\n\nStyliser mes couches\nDocumentation GeoServer â€œStylingâ€\nPour le moment, afficher notre couche â€œdealsâ€ va juste donner lâ€™impression que notre carte a attrappÃ© la varicelle. On va commencer par changer son apparence en faisant des points bien ronds et dâ€™une couleur qui crie moins â€œDANGERÂ !!!â€. Pour Ã§a, on va devoir crÃ©er un nouveau style.\n\nAllez dans â€œStylesâ€ et cliquer sur â€œAjouter un nouveau styleâ€.\nNommez le style â€œdealsâ€ et choisissez lâ€™espace de travail â€œland_matrixâ€. Conservez le format SLD, câ€™est le seul disponible sans ajouter dâ€™extensions.\nPour nous aider, GeoServer propose de gÃ©nÃ©rer un SLD par dÃ©faut. SÃ©lectionnez â€œPointâ€ et cliquez sur â€œGÃ©nÃ©rerâ€¦â€. Vous devriez vous retrouver avec un fichier .xml dÃ©crivant la couche.\n\nOn pourrait aller lire en dÃ©tail le SLD Cookbook de GeoServer pour Ã©crire notre fichier manuellement, mais on est plus malins que Ã§a. On a un super outil Ã  disposition qui sâ€™appelle QGIS.\n\nSi vous ne lâ€™avez pas dÃ©jÃ  fait, crÃ©ez un projet QGIS et ajoutez les couches Land Matrix.\nDonnez un style sympa aux points de la couche deals. Jâ€™ai changÃ© la couleur pour les rendre orange.\nAllez dans les propriÃ©tÃ©s de votre couche et dans â€œSymbologieâ€. Tout en bas, choisissez â€œStyleâ€ et â€œEnregistrer le styleâ€¦â€.\nChoisissez lâ€™option â€œEn tant que fichier SLDâ€ et choisissez le chemin et le nom de votre fichier en cliquant sur â€œâ€¦â€ aprÃ¨s â€œFichierâ€. Jâ€™ai appelÃ© le mien â€œdeals.sldâ€\nAllez chercher votre fichier et ouvrez-le avec un Ã©diteur de texte (Notepad, VSCode, peu importe).\nCopiez le contenu.\nRetournez sur votre page GeoServer, supprimez tout le contenu de la zone de texte et collez Ã  la place le contenu de deals.sld. VoilÃ  ce que Ã§a donne pour moiÂ :\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix â€” deals&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix â€” deals&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Deal&lt;/se:Name&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#ffd157&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;7&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\nVous pouvez prÃ©visualiser la lÃ©gende en cliquant sur â€œAperÃ§u de la lÃ©gendeâ€. Le bouton â€œAjouter une lÃ©gendeâ€ permet quand Ã  lui dâ€™ajouter une image customisÃ©e plutÃ´t quâ€™une gÃ©nÃ©ration automatique. Câ€™est pratique quand on a des lÃ©gendes complexes, mais pas pour le moment. Ensuite, sauvegardez la lÃ©gende quand elle vous convient.\n\n\n\n\n\n\nTip\n\n\n\nUne autre mÃ©thode pour charger le contenu dâ€™un fichier de style .sld est de cliquer sur â€œBrowseâ€ en dessous de â€œFichier de styleâ€. Allez chercher votre fichier .sld et cliquez sur â€œChargerâ€¦â€ pour vous Ã©conomiser quelques copier-coller par la suiteÂ !\n\n\nMaintenant, il faut dire Ã  GeoServer quâ€™on veut utiliser ce style avec notre couche â€œdealsâ€.\n\nAllez dans â€œCouchesâ€.\nSÃ©lectionnez la couche â€œdeals et allez dans lâ€™ongletâ€Publicationâ€.\nDans â€œStyle par dÃ©fautâ€, sÃ©lectionnez â€œland_matrix:dealsâ€ et Sauvegardez.\n\nMaintenant, vous pouvez de nouveau prÃ©visualiser la couche â€œdealsâ€ et voilÃ Â ! Nos points sont ronds et jaunes. Vous savez maintenant crÃ©er un nouveau style SLD depuis QGIS et lâ€™ajouter Ã  une couche dans GeoServerÂ !\n\n\n\n\n\nNormalement, vous commencez Ã  bien comprendre le fonctionnement de GeoServer et la publication des couches. CrÃ©ez un style de couleur unique pour â€œdeals_by_countryâ€ quâ€™on utilisera comme pseudo fond de carte. Ensuite, crÃ©ez un style en cercles proportionnels pour â€œdeals_by_country_centroidâ€ en vous basant sur lâ€™attribut â€œsurface_haâ€.\n\n\n\n\n\n\nAttention Ã  la sÃ©miologie\n\n\n\nJe ne veux pas voir de polygones â€œdeals_by_countryâ€ de diffÃ©rentes couleurs. On nâ€™utilise pas de carte choroplÃ¨the pour reprÃ©senter une valeur absolue, elles servent pour les valeurs relatives ou les catÃ©gories.\n\n\n\n\n\n\n\nUne fois que vous avez au moins ajoutÃ© votre style Ã  â€œdeals_by_countryâ€ dans GeoServer, vous pouvez passer Ã  la suite. Si vous avez un train de retard, cliquez sur les boutons ci-dessous pour dÃ©rouler mes styles et les copier-coller dans votre GeoServer.\n\n\n\n\n\n\nSLD pour â€œdeals_by_countryâ€\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix â€” deals_by_country&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix â€” deals_by_country&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Single symbol&lt;/se:Name&gt;\n          &lt;se:PolygonSymbolizer&gt;\n            &lt;se:Fill&gt;\n              &lt;se:SvgParameter name=\"fill\"&gt;#fdbf6f&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"fill-opacity\"&gt;0.35&lt;/se:SvgParameter&gt;\n            &lt;/se:Fill&gt;\n            &lt;se:Stroke&gt;\n              &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-width\"&gt;1&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-linejoin\"&gt;bevel&lt;/se:SvgParameter&gt;\n            &lt;/se:Stroke&gt;\n          &lt;/se:PolygonSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\n\n\n\n\nSLD pour â€œdeals_by_country_centroidâ€\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix â€” deals_by_country_centroid&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix â€” deals_by_country_centroid&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;201 - 5466&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;201 - 5466&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;200.81000000000000227&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThanOrEqualTo&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;4&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;5466 - 20413&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;5466 - 20413&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;10&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;20413 - 61376&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;20413 - 61376&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;16&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;61376 - 160220&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;61376 - 160220&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;22&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;160220 - 1509612&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;160220 - 1509612&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;1509612&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;29&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\nLire mes flux dans une autre application\nCourage, on touche au but. Vous aurez bientÃ´t fait le tour du fonctionnement basique de GeoServer. Maintenant quâ€™on a nos couches, on veut pouvoir les lire.\nPour commencer, on va rapidement vÃ©rifier quâ€™on communique bien avec notre GeoServer en utilisant QGIS et la requÃªte GetCapabilities du serveur. Cette requÃªte, lorsquâ€™elle rÃ©ussit, nous rÃ©pond avec un fichier .xml qui explique Ã  QGIS tout ce que le serveur est capable de faire, et notamment quelles couches peuvent Ãªtre affichÃ©es.\n\nDans QGIS, cliquez sur â€œAjouter une coucheâ€ et sÃ©lectionnez â€œWMSâ€.\nDans lâ€™onglet â€œCouchesâ€, cliquez sur â€œNouveauâ€.\nAppelez la connexion â€œmon_geoserverâ€ et collez lâ€™url GetCapabilities dans â€œURLâ€. Elle devrait Ãªtre identique Ã  celle-ciÂ :\n\nhttp://localhost/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetCapabilities\n\n\n\n\n\n\nÃ‡a ne fonctionne pasÂ !\n\n\n\n\n\nPour vÃ©rifier que votre requÃªte est bonne, allez dans GeoServer, affichez nâ€™importe quelle couche en prÃ©visualisation et copiez lâ€™adresse.\nhttp://localhost/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetMap&layers=land_matrix%3Adeals&bbox=-180.0%2C-90.0%2C180.0%2C90.0&width=768&height=384&srs=EPSG%3A4326&styles=&format=application/openlayers\nSupprimez tout ce qui se trouve aprÃ¨s â€œrequest=â€ et ajoutez â€œGetCapabilitiesâ€.\nhttp://localhost/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetCapabilities\n\n\n\n\nCliquez ensuite sur â€œConnexionâ€ et vÃ©rifiez quâ€™une liste de couche apparaÃ®t et quâ€™elle contient bien vos couches â€œdealsâ€, etc.\n\nVous pouvez afficher la couche dans QGIS avec â€œAddâ€ si vous le souhaitez. Lâ€™essentiel, câ€™est quâ€™on a vÃ©rifier que notre serveur Ã©met bien des flux WMS pour nos couches et quâ€™on peut bien les lire. On va maintenant faire la mÃªme chose dans une application OpenLayers. Comme on nâ€™a pas encore commencÃ© les cours, je vous donne le code. Vous verrez, Ã§a ressemble beaucoup Ã  Leaflet. Dans le dossier de votre choix, crÃ©ez un document index.html et collez le contenu suivantÂ :\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;GeoServer + OpenLayers&lt;/title&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width\"&gt;\n\n        &lt;!-- CSS --&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/ol.css\" /&gt;\n        &lt;style&gt;\n        #map {\n            height: 500px;\n            width: 800px;\n        }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;GeoServer + OpenLayers&lt;/h1&gt;\n\n        &lt;div id=\"map\"&gt;&lt;/div&gt;\n\n        &lt;!-- OpenLayers JS--&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/dist/ol.js\"&gt;&lt;/script&gt;\n\n        &lt;!-- App code --&gt;\n        &lt;script&gt;\n            // OSM layer and source\n            var source_osm = new ol.source.OSM()\n            var layer_osm = new ol.layer.Tile({ source: source_osm })\n\n            // GeoServer layer and source\n\n            // Map\n            var map = new ol.Map({\n                target: 'map',\n                layers: [ layer_osm ],\n                view: new ol.View({\n                center: ol.proj.fromLonLat([2.1833, 41.3833]),\n                zoom: 2\n                })\n            });\n        &lt;/script&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\nDouble-cliquez sur index.html pour lâ€™ouvrir dans le navigateur. Vous devriez voir apparaÃ®tre une carte avec un fond OSM. On va ajouter nos couches GeoServer Ã  cette carte.\n\n\n\n\n\nSous la section commentÃ©e â€œGeoServer Layer and sourceâ€, ajoutez les lignes suivantes :\nvar url_geoserver = 'http://localhost/geoserver/land_matrix/wms'\nvar source_geoserver = new ol.source.ImageWMS({\n    url: url_geoserver,\n    params: {'LAYERS': 'land_matrix:deals'},\n    serverType: 'geoserver',\n})\nvar layer_geoserver = new ol.layer.Image({ source: source_geoserver })\nEt ajoutez layer_geoserver Ã  la liste de couches de mapÂ :\n// Map\nvar map = new ol.Map({\n    target: 'map',\n    layers: [ layer_osm, layer_geoserver ],\n    view: new ol.View({\n    center: ol.proj.fromLonLat([2.1833, 41.3833]),\n    zoom: 2\n    })\n});\nActualisez la carte. Vous devriez maintenant voir apparaÃ®tre la couche â€œdealsâ€ de lâ€™entrepÃ´t â€œland_matrixâ€Â ! DÃ©cortiquons rapidement ces lignes de code.\nvar url_geoserver = 'http://localhost/geoserver/land_matrix/wms'\nOn rÃ©cupÃ¨re lâ€™url de notre serveur. Si vous ne la trouvez pas, allez dans votre GeoServer et prÃ©visualisez nâ€™importe quelle couche. RÃ©cupÃ©rez lâ€™url et coupez tout aprÃ¨s â€œwmsâ€. land_matrix est lâ€™URI que nous avons donnÃ© Ã  notre espace de travail (voir la section Espaces de travail du TP).\nvar source_geoserver = new ol.source.ImageWMS({\n    url: url_geoserver,\n    params: {'LAYERS': 'land_matrix:deals'},\n    serverType: 'geoserver',\n})\nOn crÃ©e ensuite une nouvelle source de donnÃ©es de type ImageWMS. On indique lâ€™url de la source, Ã  savoir lâ€™url de notre espace de donnÃ©es GeoServer stockÃ© dans la variable url_geoserver. Lâ€™image prend aussi un ou plusieurs paramÃ¨tres. On indique dans â€˜LAYERSâ€™ la couche quâ€™on souhaite afficher. Celle ligne sâ€™Ã©crit toujours sous la formeÂ :\n'LAYERS' : '&lt;entrepÃ´t&gt;:&lt;couche&gt;'\nSi vous avez un doute, allez dans â€œPrÃ©visualisation de la coucheâ€ et regardez le contenu de la colonne â€œNomâ€. Câ€™est la valeur Ã  donner Ã  â€˜LAYERSâ€™.\nEnfin, on renseigne le type du serveur, ici â€˜geoserverâ€™. Ce paramÃ¨tre permet Ã  OpenLayers de communiquer plus facilement avec GeoServer lorsque vous utiliserez des fonctionnalitÃ©s plus avancÃ©es. De maniÃ¨re gÃ©nÃ©rale, cela vous permet aussi de vous souvenir du type de serveur avec lequel vous communiquez.\nChouette, aprÃ¨s tout Ã§a on a enfin rÃ©ussi Ã  crÃ©er, lire et afficher un flux WMSÂ ! Sauf que, il manque encore quelque choseâ€¦ la lÃ©gendeÂ ! Et lÃ  vous me dites â€œpitiÃ©, jâ€™en peux plus, jâ€™ai la tÃªte qui va exploserâ€. Allez, encore un petit effort. On a vu que GeoServer est capable de gÃ©nÃ©rer tout seul une lÃ©gende, il nous suffit donc de la rÃ©cupÃ©rer. Pour Ã§a, rien de plus facileÂ ! Le serveur distribue les images comme il distribue les couches de donnÃ©es. Il nous suffit de rÃ©cupÃ©rer lâ€™image en question et lâ€™afficher dans une nouvelle &lt;div&gt; sur notre carte.\nOn reviendra en dÃ©tail sur le fonctionnement des lÃ©gendes dans le TP sur OpenLayers. Commencez par crÃ©er une &lt;div&gt; pour la lÃ©gende sous &lt;div id=\"map\"&gt;&lt;/div&gt; :\n&lt;div id=\"map\"&gt;&lt;/div&gt;\n&lt;div&gt;&lt;img id=\"legend\" /&gt;&lt;/div&gt;\nNotre script permettra de modifier la source de lâ€™image legend en interrogeant GeoServer Ã  chaque fois quâ€™on fera changer la rÃ©solution de la carte. Dans le tag &lt;script&gt;, en dessous du code de la carte â€œMapâ€, ajoutez les lignes suivantes :\n&lt;!-- App code --&gt;\n&lt;script&gt;\n    //â€¦\n\n    // Function to update the legend    \n    function updateLegend(resolution) {\n        const graphicUrl = source_geoserver.getLegendUrl(resolution, { 'LEGEND_OPTIONS' : 'forceLabels:on' });\n        const img = document.getElementById('legend');\n        img.src = graphicUrl;\n    };\n\n    // Initial legend\n    const resolution = map.getView().getResolution();\n    updateLegend(resolution);\n\n    // Update legend when resolution changes\n    map.getView().on('change:resolution', function (event) {\n        const resolution = event.target.getResolution();\n        updateLegend(resolution);\n    });\n\n&lt;/script&gt;\nEn rÃ©sumÃ©Â :\n\nLa fonction updateLegend() permet de rÃ©cupÃ©rer lâ€™url de la lÃ©gende depuis notre source GeoServer source_geoserver en utilisant la mÃ©thode getLegendUrl(). On modifie ensuite la source de notre image &lt;img id=\"legend\" /&gt; sur lâ€™url de la lÃ©gende.\nLa fonction getLegendUrl() a besoin de connaÃ®tre la rÃ©solution de la carte pour fonctionner.\nLorsque la carte est crÃ©Ã©e pour la premiÃ¨re fois, on stocke sa rÃ©solution dans la variable resolution. La mÃ©thode getView() de lâ€™objet map permet de rÃ©cupÃ©rer la valeur de cette rÃ©solution. Ensuite, on exÃ©cute notre fonction updateLegend() pour rÃ©cupÃ©rer la lÃ©gende une premiÃ¨re fois.\nPour mettre Ã  jour la lÃ©gende lorsque la rÃ©solution change, on Ã©coute les Ã©vÃ¨nements change:resolution de la map. Ã€ chaque fois que la rÃ©solution change, on va rÃ©cupÃ©rer Ã  nouveau cette rÃ©solution et exÃ©cuter la fonction updateLegend().\n\n\n\n\n\n\n\nCode complet de lâ€™application\n\n\n\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;GeoServer + OpenLayers&lt;/title&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width\"&gt;\n\n        &lt;!-- CSS --&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/ol.css\" /&gt;\n        &lt;style&gt;\n        #map {\n            height: 500px;\n            width: 800px;\n        }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;GeoServer + OpenLayers&lt;/h1&gt;\n\n        &lt;div id=\"map\"&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;img id=\"legend\" /&gt;&lt;/div&gt;\n\n        &lt;!-- OpenLayers JS--&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/dist/ol.js\"&gt;&lt;/script&gt;\n\n        &lt;!-- App code --&gt;\n        &lt;script&gt;\n            // OSM layer and source\n            var source_osm = new ol.source.OSM()\n            var layer_osm = new ol.layer.Tile({ source: source_osm })\n\n            // GeoServer layer and source\n            var url_geoserver = 'http://localhost/geoserver/land_matrix/wms'\n            var source_geoserver = new ol.source.ImageWMS({\n                url: url_geoserver,\n                params: {'LAYERS': 'land_matrix:deals'},\n                serverType: 'geoserver',\n            })\n            var layer_geoserver = new ol.layer.Image({ source: source_geoserver })\n\n            // Map\n            var map = new ol.Map({\n                target: 'map',\n                layers: [ layer_osm, layer_geoserver ],\n                view: new ol.View({\n                center: ol.proj.fromLonLat([2.1833, 41.3833]),\n                zoom: 2\n                })\n            });\n\n            // Function to update the legend    \n            function updateLegend(resolution) {\n                const graphicUrl = source_geoserver.getLegendUrl(resolution, { 'LEGEND_OPTIONS' : 'forceLabels:on' });\n                const img = document.getElementById('legend');\n                img.src = graphicUrl;\n            };\n\n            // Initial legend\n            const resolution = map.getView().getResolution();\n            updateLegend(resolution);\n\n            // Update legend when resolution changes\n            map.getView().on('change:resolution', function (event) {\n                const resolution = event.target.getResolution();\n                updateLegend(resolution);\n            });\n\n        &lt;/script&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\n\n\n\nOufÂ ! On a enfin une lÃ©gende. Pour ceux qui ont encore le temps et lâ€™Ã©nergie, je vous propose dâ€™afficher les autres couches et leur lÃ©gende sur la carte, au moins â€œdeals_by_country_centroidsâ€ pour avoir nos cercles proportionnels. Câ€™est partiÂ !",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#conclusions",
    "href": "cours/geonum/serveurs_carto.html#conclusions",
    "title": "Serveurs cartographiques",
    "section": "Conclusion(s)",
    "text": "Conclusion(s)\n\nCâ€™est quoi lâ€™intÃ©rÃªt du serveur carto, dÃ©jÃ Â ?\n\nCentralisation de la donnÃ©e et mise Ã  jour\nDistribution de la donnÃ©e\nGestion des droits\nBien quand on a une organisation et bcp de donnÃ©es, sâ€™intÃ¨gre trÃ¨s bien dans une IDG\nBien pour les couches Raster et les couches Vecteur lourdes qui peuvent Ãªtre servies en tant quâ€™images (WMS)\nConnexion directe Ã  une base de donnÃ©es PostgreSQL\nPossibilitÃ© dâ€™Ã©crire des requÃªtes SQL pour former les couches\nPossibilitÃ© de crÃ©er des styles complexes â€œÃ  la QGISâ€.\n\nEst-ce que jâ€™en ai besoin pour mon projet GeoNumÂ ?\n\nÃ‡a dÃ©pend des donnÃ©es que vous utilisez et ce que vous en faites. Le mieux câ€™est dâ€™en discuter avec les profsÂ !\n\nJe nâ€™utilise pas de connexion Ã  une base de donnÃ©es, je prÃ©fÃ¨re juste afficher des couches avec un style complexe. Ce serait pas plus simple si on pouvait directement importer les couches dâ€™un projet QGISÂ ?",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#tp---qgis-server-avec-lizmap",
    "href": "cours/geonum/serveurs_carto.html#tp---qgis-server-avec-lizmap",
    "title": "Serveurs cartographiques",
    "section": "TP - QGIS Server avec LizMap",
    "text": "TP - QGIS Server avec LizMap\nEn cours de rÃ©daction, revenez plus tardÂ !",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/evaluation.html",
    "href": "cours/geonum/evaluation.html",
    "title": "Ã‰valuation",
    "section": "",
    "text": "Commentaires dans le code\nIntendation du code\nPas de fautes dans le texte (surtout quâ€™il y en a vraiment trÃ¨s peuÂ !)\nOn ajoute un peu de CSS, on essaie de ne pas juste faire le minimum vital"
  },
  {
    "objectID": "cours/geonum/evaluation.html#memo",
    "href": "cours/geonum/evaluation.html#memo",
    "title": "Ã‰valuation",
    "section": "",
    "text": "Commentaires dans le code\nIntendation du code\nPas de fautes dans le texte (surtout quâ€™il y en a vraiment trÃ¨s peuÂ !)\nOn ajoute un peu de CSS, on essaie de ne pas juste faire le minimum vital"
  },
  {
    "objectID": "cours/geonum/evaluation.html#ce-qui-est-demandÃ©",
    "href": "cours/geonum/evaluation.html#ce-qui-est-demandÃ©",
    "title": "Ã‰valuation",
    "section": "Ce qui est demandÃ©",
    "text": "Ce qui est demandÃ©\nâ€¦"
  },
  {
    "objectID": "cours/geonum/evaluation.html#points-bonus",
    "href": "cours/geonum/evaluation.html#points-bonus",
    "title": "Ã‰valuation",
    "section": "Points bonus",
    "text": "Points bonus\nâ€¦"
  },
  {
    "objectID": "cours/geonum/introduction.html",
    "href": "cours/geonum/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "SlidesÂ : Introduction",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#intervenante",
    "href": "cours/geonum/slides_introduction.html#intervenante",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Intervenante",
    "text": "Intervenante\nMarie Gradeler\nâ›°ï¸ Licence de GÃ©ologie\nğŸ¤  Master dâ€™ArchÃ©ologie du Paysage (SIG, tÃ©lÃ©dec, stats)\nğŸ¤· Pas de sous en archÃ©o donc galÃ¨re de trouver du travail\nğŸ—ºï¸ Master GeoNum (arrivÃ©e en M2)\nğŸ’» Stage AgroParisTech dans le cadre du Master : dÃ©veloppement dâ€™une appli de cartographie web\nğŸ’» Contrat de 6 mois au CIRAD pour terminer la production de lâ€™appli carto du stage\nğŸ’» Depuis, je travaille comme consultante IFAD sur le project Land Matrix (crÃ©ation dâ€™indicateurs, stats avec R, beaucoup de dataviz et dÃ©veloppement Web)"
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#les-cours",
    "href": "cours/geonum/slides_introduction.html#les-cours",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Les cours",
    "text": "Les cours\n\nJeudi 21 Nov : 9h - 12h\nMercredi 27 Nov : 9h - 12h\nJeudi 28 Nov : 9h - 12h\nJeudi 28 Nov : 13h30 - 16h30\n\nOn va beaucoup travailler sur les serveurs cartographiques, notamment GeoServer, mais aussi sur la librairie de cartographie OpenLayers. Cela va nous demander de savoir Ã©crire du code en JavaScript, dâ€™Ãªtre capable dâ€™exÃ©cuter une ou deux lignes de commandes en Bash et de comprendre lâ€™architecture client-serveur du web.\nJe vous recommande dâ€™Ãªtre bien attentifs aux cours de Leaflet (entre autres) qui sont complÃ©mentaires de celui-ci. Si vous connaissez Leaflet, vous connaissez presque dÃ©jÃ  OpenLayers."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#les-ressources",
    "href": "cours/geonum/slides_introduction.html#les-ressources",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Les ressources",
    "text": "Les ressources\nğŸ’» Mon site internetÂ : https://gradelerm.github.io\nIl est en cours de construction mais suffit dÃ©jÃ  Ã  hÃ©berger les ressources pour le cours. Vous y trouverez tout le reste !\nMoiÂ : marie.gradeler@gmail.com\nNâ€™hÃ©sitez pas Ã  me contacter. Mes cours sont condensÃ©s sur 2 semaines. Si quelque chose ne va pas, je dois le savoir dÃ¨s la premiÃ¨re sÃ©ance. Je serai aussi disponible pour vous accompagner durant les projets GeoNum si vous avez besoin dâ€™aide sur lâ€™une des notions abordÃ©es en cours."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#comment-Ã§a-se-passe",
    "href": "cours/geonum/slides_introduction.html#comment-Ã§a-se-passe",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Comment Ã§a se passe",
    "text": "Comment Ã§a se passe\nOrganisation des cours\n\nPas mal de mise en pratique\nOn mâ€™appelle si on est perdu, je suis lÃ  pour vous aider (ne me laissez pas faire mon cours dans le vide parce que vous avez abandonnÃ© tout espoir de raccrocher les wagons, Ã§a ne sert Ã  rien)\nSi on doit ralentir parce que jâ€™ai trop prÃ©vu de choses techniques, on ralentit et puis câ€™est tout, jâ€™adapterai lâ€™Ã©valuation Ã  ce quâ€™on a eu le temps de voir en cours\nPas dâ€™IA pour Ã©crire le code ! Je donne gÃ©nÃ©ralement les corrigÃ©s dans le TP, vous nâ€™en aurez mÃªme pas besoin. Pour apprendre, le mieux, câ€™est de faire soi-mÃªme, et Ã§a ne mâ€™intÃ©resse pas trop de venir faire cours Ã  Chat-GPT ou Gemini de toute faÃ§on.\nJe sais que câ€™est difficile mais on lÃ¢che son tÃ©lÃ©phone pendant le cours (ou cet onglet mal planquÃ©) et on se concentre sur le cours. WhatsApp et les ouvertures de boosters attendront la pause cafÃ©."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#Ã©valuation",
    "href": "cours/geonum/slides_introduction.html#Ã©valuation",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Ã‰valuation",
    "text": "Ã‰valuation\nProjet Ã  rendre basÃ© sur une petite architecture web que je vous fournirai (et qui pourrait Ã©ventuellement servir de base pour une archi de projet GeoNum, je dis Ã§a je dis rienâ€¦). Dans les grandes lignes, ce qui vous sera demandÃ©Â :\nğŸ› ï¸ Publication de couches sur un GeoServer\nğŸ—ºï¸ Lecture des flux WMS sur une petite appli OpenLayers\nğŸ’» DÃ©ploiement (rudimentaire) de votre serveur GeoServer + application OpenLayers en sâ€™appuyant sur lâ€™architecture web fournie\nJe vais recalibrer lâ€™Ã©valuation suivant la vitesse Ã  laquelle on avance et le niveau moyen de la promo en dev. Du coup, vous aurez les consignes pendant le dernier cours."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#cest-parti",
    "href": "cours/geonum/slides_introduction.html#cest-parti",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Câ€™est parti !",
    "text": "Câ€™est parti !\nPrÃªts Ã  encore entendre parler de serveurs, clients, requÃªtes, variables et fonctionsÂ ?\n\n\n\n\n\nCourage. Promis, Ã§a va nous permettre de faire des trucs cools qui seront trÃ¨s utiles pour les projets GeoNum et si vous faites de la webcarto ou des IDGs plus tard.\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html",
    "href": "cours/geonum/openlayers_geoserver.html",
    "title": "OpenLayers & GeoServer",
    "section": "",
    "text": "Savoir ce que sont Node JS, OpenLayers et Docker.\nComprendre la diffÃ©rence entre une machine virtuelle et un container.\nDÃ©ployer une stack de dÃ©veloppement avec un serveur GeoServer et un serveur Caddy pour servir une application sous Node JS en utilisant Docker Compose.\nCrÃ©er une application OpenLayers avec Node JS.\nComprendre le contenu de lâ€™application de base de OpenLayers et oÃ¹ doit vivre mon code.\nApprendre Ã  utiliser la documentation et les exemples dâ€™OpenLayers pour ajouter des Ã©lÃ©ments Ã  ma carte.\nAfficher des couches WMS dans une application OpenLayers.",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#objectifs",
    "href": "cours/geonum/openlayers_geoserver.html#objectifs",
    "title": "OpenLayers & GeoServer",
    "section": "",
    "text": "Savoir ce que sont Node JS, OpenLayers et Docker.\nComprendre la diffÃ©rence entre une machine virtuelle et un container.\nDÃ©ployer une stack de dÃ©veloppement avec un serveur GeoServer et un serveur Caddy pour servir une application sous Node JS en utilisant Docker Compose.\nCrÃ©er une application OpenLayers avec Node JS.\nComprendre le contenu de lâ€™application de base de OpenLayers et oÃ¹ doit vivre mon code.\nApprendre Ã  utiliser la documentation et les exemples dâ€™OpenLayers pour ajouter des Ã©lÃ©ments Ã  ma carte.\nAfficher des couches WMS dans une application OpenLayers.",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#cours---le-point-technique",
    "href": "cours/geonum/openlayers_geoserver.html#cours---le-point-technique",
    "title": "OpenLayers & GeoServer",
    "section": "Cours - Le point technique",
    "text": "Cours - Le point technique\nSlidesÂ : Le point technique",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#tp---dÃ©marrage-de-la-stack",
    "href": "cours/geonum/openlayers_geoserver.html#tp---dÃ©marrage-de-la-stack",
    "title": "OpenLayers & GeoServer",
    "section": "TP - DÃ©marrage de la stack",
    "text": "TP - DÃ©marrage de la stack\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nCe TP suppose que Docker et Docker Compose sont installÃ©s sur la machine. Il a Ã©tÃ© Ã©crit pour une machine Linux, certains chemins et lignes de commande peuvent donc Ãªtre diffÃ©rents sur une machine Windows ou Mac.\nLâ€™Ã©diteur de code utilisÃ© pour lâ€™Ã©criture de ce TP est VSCode mais nâ€™importe quel autre Ã©diteur fait lâ€™affaire.\n\n\n\nInitialiser mon dossier\nCommencez par crÃ©er un nouveau dossier dans lequel nous allons dÃ©velopper notre app. Vous pouvez le mettre oÃ¹ vous voulez - par exemple dans Mes Documents. Jâ€™ai appelÃ© mon dossier app_openlayers_geoserver mais le nom importe peu.\nOuvez-ce dossier dans VSCode (par exemple avec un clic-droit &gt; Ouvrir avec VSCode). Vous vous trouvez Ã  la racine du dossier. Pour la suite du TP, Ã  chaque fois que jâ€™Ã©voquerais la racine du projet, il sâ€™agita de ce dossier.\nCrÃ©ez un nouveau fichier et appelez-le README.md. Il sâ€™agit dâ€™un simple fichier texte au format markdown qui nous servira de mÃ©mo. Lâ€™application pourrait tout Ã  fait fonctionner sans.\nCopiez dans README.md le texte suivant et sauvegardez le documentÂ :\nPour dÃ©marrer les containersÂ :\n`docker compose up -d`\n\nPour arrÃªter les containersÂ :\n`docker compose down`\nSi jamais vous oubliez les commandes pour utiliser docker compose, vous pourrez les retrouver dans ce fichier.\nEnsuite, toujours Ã  la racine du projet, crÃ©er un nouveau fichier et appelez-le Caddyfile (la majuscule est importanteÂ !). Collez le contenu suivant Ã  lâ€™intÃ©rieur et sauvegardez.\n:80 {\n    root * /srv\n    file_server\n}\n\n\n\n\n\n\nCâ€™est quoi, ce CaddyfileÂ ?\n\n\n\n\n\nIl sâ€™agit du fichier de configuration du serveur Caddy que nous allons utiliser pour servir notre application OpenLayers. On aurait pu choisir dâ€™utiliser Apache ou Nginx, mais jâ€™aime bien Caddy, je le trouve plus clair Ã  prendre en main.\nOn lui indique simplement trois Ã©lÃ©mentsÂ :\n\nOn sert notre application sur le port 80 (le localhost par dÃ©faut). Il faudra donc aller sur localhost pour voir notre application OpenLayers.\nCaddy doit chercher les fichiers de notre site web dans le dossier /srv (configuration par dÃ©faut).\nCaddy sait quâ€™on va utiliser des fichiers statiques.\n\n\n\n\n\n\nCrÃ©er (et comprendre) mon docker-compose.yml\nNormalement, si vous avez bien suivi les Ã©tapes prÃ©cÃ©dentes, le contenu de votre dossier devrait ressembler Ã  Ã§aÂ :\n- Caddyfile\n- README.md\nÃ€ la racine du projet, crÃ©ez un nouveau fichier et appelez-le docker-compose.yml. Collez le contenu suivant dans ce fichier et sauvegardez.\nservices:\n\n  geoserver:\n    container_name: geonum_geoserver\n    image: docker.osgeo.org/geoserver:2.26.0\n    environment:\n      - RUN_UNPRIVILEGED=true\n      - CHANGE_OWNERSHIP_ON_FOLDERS=\"/opt /opt/geoserver_data/ /mnt/geoserver_geodata\"\n      - CORS_ENABLED=true\n      - SKIP_DEMO_DATA=true\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - ./geoserver/opt:/opt/geoserver_data\n  \n  web:\n    container_name: geonum_web\n    image: caddy:latest\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./Caddyfile:/etc/caddy/Caddyfile\n      - ./app/dist/:/srv\n\n\n\n\n\n\nEt Ã§a, Ã§a veut dire quoiÂ ?\n\n\n\n\n\nSi tout sâ€™est bien passÃ©, on a dÃ©jÃ  vu ensemble comment fonctionne le docker-compose.yml en cours, mais voici un petit rappelÂ :\n\non crÃ©e deux â€œservicesâ€, qui sont en fait deux containers, un geoserver et un web .\npour chaque service, on indiqueÂ :\n\nle nom quâ€™on donne au container (pour Ã©viter les noms gÃ©nÃ©rÃ©s alÃ©atoirement comme lors du prÃ©cÃ©dent TP, qui ne sont pas super clairs)\nle nom de lâ€™image Docker (pour rappel, image = recette pour construire un container) quâ€™on souhaite utiliser\nles ports quâ€™on souhaite connecter, sous la forme HOST_PORT:CONTAINER_PORT . Exemple pour GeoServerÂ : je sais quâ€™il est toujours servi sur le port 8080, donc si jâ€™Ã©cris 3000:8080, Ã§a veut dire que sur mon ordinateur je dois aller sur localhost:3000 pour pouvoir regarder le port 8080 de mon container et voir mon GeoServer.\nSi ce nâ€™est pas clair et que Ã§a vous travaille de comprendre comment Ã§a fonctionne, on mâ€™appelleÂ !\ndes volumes dans lesquels on stocke de la donnÃ©e, ici on va connecter les volumes docker Ã  des dossier dans notre ordinateur (comme au TP prÃ©cÃ©dent) en utilisant la syntaxe HOST_DIRECTORY:CONTAINER_DIRECTORY . Pour reprendre lâ€™exemple de GeoServer, je sais que par dÃ©faut la donnÃ©e est stockÃ©e dans /opt/geoserver_data/ dans le serveur. Je dis donc Ã  mon container de se connecter Ã  un dossier sur ma machine dans $PWD/geoserver/opt , un dossier qui sera crÃ©Ã© au premier lancement de la stack. Comme on lâ€™a expÃ©rimentÃ© au TP prÃ©cÃ©dent, monter des volumes depuis les containers sur mon ordinateur est le moyen le plus simple dâ€™y transfÃ©rer de la donnÃ©e. Ce nâ€™est pas toujours aussi simple dâ€™accÃ©der Ã  lâ€™intÃ©rieur dâ€™un serveur - câ€™est toute la puissance de Docker, et câ€™est pour Ã§a quâ€™on sâ€™en sertÂ !\n\n\nCe nâ€™est encore pas super clairÂ ? Attendez de commencer Ã  manipuler le TP, Ã§a viendra tout seul. Si câ€™est toujours flou au bout de quelques exercices, appelez-moi et on refait une explicationÂ !\n\n\n\n\n\nInitialiser mon application OpenLayers\nDocumentation OpenLayers\nAvant de pouvoir lancer tous nos services, on doit encore crÃ©er notre application OpenLayers. Ouvrez un terminal Ã  la racine du projet. Vous avez deux optionsÂ :\n\nla simpleÂ : ouvrez un Terminal dans votre editeur de Code (par exemple, dans VSCode, allez dans le menu en haut et cliquez sur â€œTerminalâ€)\nla moins simpleÂ : ouvez un terminal et dÃ©placez-vous jusquâ€™Ã  votre projet en utilisant la commande cd /chemin/de/mon/projet\n\nUne fois que le terminal est ouvert dans le projet (vÃ©rifiez bien deux foisÂ !), tapez la commande suivante pour crÃ©er un projet OpenLayers quâ€™on appelle â€œappâ€Â :\nnpm create ol-app app\n\n\n\n\n\n\nJâ€™ai un message dâ€™erreur â€œcould not find commit hash for HEADâ€\n\n\n\n\n\nCela doit vouloir dire que git nâ€™est pas installÃ© sur la machine. Pour savoir comment installer Git pour Linux, Windows et MacOS, rendez-vous sur le site officiel de GitÂ : https://git-scm.com/book/en/v2/Getting-Started-Installing-Git\nPour gagner du temps, voilÃ  la page pour WindowsÂ : https://git-scm.com/downloads/win\nQuand git est installÃ©, recommencez lâ€™Ã©tape prÃ©cÃ©dente. Si Ã§a ne fonctionne toujours pas, essayez deÂ :\n\nfermer et ouvrir de nouveau VS Code\nredÃ©marrer lâ€™ordinateur\n\nPour moi Ã§a a fonctionnÃ© dans la salle de TP ğŸ¤\n\n\n\nVous devriez voir un nouveau dossier appelÃ© â€œappâ€. Tapez la commande suivante pour vous â€œdÃ©placerâ€ dans le dossier â€œappâ€.\ncd app\nOn va dÃ©marrer notre application avec la commande suivanteÂ :\nnpm start\nVous devriez avoir quelque chose comme Ã§a dans votre terminalÂ :\n  VITE v5.4.11  ready in 137 ms\n\n  âœ  Local:   http://localhost:5173/\n  âœ  Network: use --host to expose\n  âœ  press h + enter to show help\nSuper, le serveur de dÃ©veloppement de lâ€™application fonctionneÂ ! On va pouvoir y accÃ©der en entrant dans le navigateur lâ€™adresse indiquÃ©e dans Local. Allez-y et vÃ©rifiez que vous voyez bien une carte.\n\n\n\n\n\n\nUn serveur de dÃ©veloppementÂ ?\n\n\n\n\n\nComme on lâ€™a vu en cours, lâ€™un des intÃ©rÃªts de Node JS est quâ€™il permet dâ€™avoir un serveur de dÃ©veloppement pour servir notre application facilement et la mettre Ã  jour au fur et Ã  mesure des changements. Pour lancer ce serveur de dÃ©veloppement, on utilise la commande npm start depuis le dossier app.\nPar contre, câ€™est un serveur de dÃ©veloppement et non pas de production. On apprendra donc pendant le dernier cours Ã  mettre en production une application - ce sera dans le rendu de votre Ã©valuation, mais pas de pression ğŸ˜ˆ\n\n\n\nSi vous voyez bien une carte, il ne reste que deux toutes petites Ã©tapes et on va enfin pouvoir passer Ã  la suite.\nDâ€™abord, quittez le serveur de dÃ©veloppement (ctrl + c dans le terminal). Tapez ensuite la commande suivanteÂ :\nnpm run build\nNode JS va crÃ©er un build, une version pour la production de notre site. Câ€™est ce build qui va Ãªtre servi par notre fameux serveur Caddy quâ€™on a vu dans le docker-compose.yml. Les fichiers de cette application se trouvent dans le dossier ./app/dist/.\nPour vÃ©rifier que tout a fonctionnÃ©, tapez les commandes suivantes dans votre terminalÂ :\ncd ..\ndocker compose up\nLa premiÃ¨re commande permet de retourner Ã  la racine du projet. La seconde demande Ã  Docker de crÃ©er nos containers Ã  partir des instructions de docker-compose.yml. Le dÃ©marrage peut prendre un peu de temps, profitez-en pour vous reposer un peu le cerveau.\nQuand câ€™est terminÃ©, le contenu de votre projet devrait ressembler Ã  Ã§aÂ :\n- app/\n- geoserver/\n- Caddyfile\n- docker-compose.yml\n- README.md\nSi câ€™est le cas, il reste une derniÃ¨re chose Ã  vÃ©rifier.\n\nallez sur http://localhost/ et confirmez que vous voyez bien une carte\nallez sur http://localhost:8080/geoserver/ et confirmez que vous voyez bien une interface de GeoServer\n\nSi tout est OK, fÃ©licitationsÂ ! Vous venez de crÃ©er une stack avec un serveur pour votre application en Node JS et un GeoServer.",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#cours---les-bases-dopenlayers",
    "href": "cours/geonum/openlayers_geoserver.html#cours---les-bases-dopenlayers",
    "title": "OpenLayers & GeoServer",
    "section": "Cours - Les bases dâ€™OpenLayers",
    "text": "Cours - Les bases dâ€™OpenLayers\nSlidesÂ : Les bases dâ€™OpenLayers",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#tp---cartographie-web-avec-geoserver-et-openlayers",
    "href": "cours/geonum/openlayers_geoserver.html#tp---cartographie-web-avec-geoserver-et-openlayers",
    "title": "OpenLayers & GeoServer",
    "section": "TP - Cartographie web avec GeoServer et OpenLayers",
    "text": "TP - Cartographie web avec GeoServer et OpenLayers\n\nImporter la couche de lâ€™exemple OpenLayers\nEn vous basant sur lâ€™exemple OpenLayers â€œSingle Image WMSâ€, importez la couche de cet exemple dans votre application.\n\n\n\n\n\n\nRappels pour dÃ©marrer mon application\n\n\n\n\n\n\nOuvrir le fichier du projet (si vous avez suivi le premier TP il devrait sâ€™appeler app_openlayers_geoserver) dans votre Ã©diteur de code, par exemple VS Code\nOuvrir un terminal et taper cd app pour vous dÃ©placer dans le dossier de votre application\nTapez npm start pour dÃ©marrer le serveur de dÃ©veloppement\nOuvrez le localhost indiquÃ© dans votre terminal pour voir votre application\n\n\n\n\nEssayez un peu par vous-mÃªme avant de simplement copier-coller ma solution depuis les diaposÂ ! Nâ€™oubliez pas que tant que votre code fonctionne, câ€™est bon. Il nâ€™y a pas une seule et unique maniÃ¨re dâ€™Ã©crire votre application. Souvent, dans mes solutions, je vais Ã©crire du code un peu plus long que la moyenne pour bien dÃ©cortiquer ce quâ€™on fait avec OpenLayers. Plus on va avancer dans les TPs et plus vous devrez comparer votre code au mien plutÃ´t que copier-coller (on ne va sÃ»rement pas appeler toutes les variables pareil).\n\n\n\n\n\n\nMa solution (code montrÃ© dans les diapos)\n\n\n\n\n\nimport './style.css';\nimport {Map, View} from 'ol';\nimport { ImageWMS } from 'ol/source';\nimport TileLayer from 'ol/layer/Tile';\nimport ImageLayer from 'ol/layer/Image';\nimport OSM from 'ol/source/OSM';\n\n// Je sors la couche OSM de lâ€™objet Map pour la stocker dans une variable\nconst couche_osm = new TileLayer({ source: new OSM() });\n\n// CrÃ©ation de la source et la couche\nconst ma_source = new ImageWMS({\n  url: 'https://ahocevar.com/geoserver/wms',\n  params: { 'LAYERS' : 'topp:states' },\n  serverType: 'geoserver',\n});\n\nconst ma_couche = new ImageLayer({\n  source: ma_source,\n});\n\n// CrÃ©ation de lâ€™objet map avec appel de mes deux couches \"couche_osm\" et \"ma_couche\" dans layers\nconst map = new Map({\n  target: 'map',\n  layers: [ couche_osm, ma_couche ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\n\n\nMaintenant, modifiez le code pour crÃ©er directement ma_couche sans passer par une source ma_source. Pour rappel, voici le morceau de code que jâ€™avais mis dans mes diaposÂ :\nconst ma_couche = new ImageLayer({\n  source: new ImageWMS({\n    url: '&lt;lien_vers_mon_serveur&gt;',\n    params: {'LAYERS': '&lt;espace&gt;:&lt;couche&gt;'},\n    serverType: 'geoserver',\n  }),\n});\n\n\n\n\n\n\nTip\n\n\n\nAttention Ã  la diffÃ©rence entre les virgules et les points-virgulesÂ !\n\n\nPour cet exercice, pas de solution, Ã§a devrait couler de source. Si vous bloquez, appelez-moiÂ ! Je le dis et le re-dis, mais on ne reste pas dans son coin Ã  sâ€™arracher les cheveux. Câ€™est contre productif et en plus si on ne me demande pas de lâ€™aide je sers juste Ã  tourner en rond dans la salle. Câ€™est un peu ennuyeux.\nQuand Ã§a fonctionne, on passe Ã  la suiteÂ !\n\n\nImporter une couche depuis mon GeoServer\nCommencez par vÃ©rifier que vos containers Docker tournent toujours. Pour Ã§a, rendez-vous sur http://localhost:8080/geoserver/ et vÃ©rifiez que vous voyez bien lâ€™interface de GeoServer. Sinon, dÃ©marrez la stack depuis Docker Desktop ou bien ouvrez un terminal Ã  la racine de votre projet et tapez docker compose up.\nOn souhaite maintenant ajouter une couche OpenLayers depuis notre GeoServer.\nVous avez une impression de dÃ©jÃ -vuÂ ? NormalÂ ! Si vous avez bien suivi le TP prÃ©cÃ©dent, ce sera un jeu dâ€™enfant pour vous. Si vous voulez retourner au TP pour Ãªtre guidÃ©s parce que vous avez un trou de mÃ©moire, câ€™est par ici. Pour vous aider, je vous remets ici quelques Ã©lÃ©mentsÂ :\n\nLe jeu de donnÃ©es land_matrix_mines Ã  tÃ©lÃ©charger\nLe fichier de style SLD des couches Ã  copier ci-dessous (vous nâ€™Ãªtes pas obligÃ©s dâ€™utiliser ceux-ciÂ !)\n\n\n\n\n\n\n\nSLD pour â€œdealsâ€\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix â€” deals&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix â€” deals&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Deal&lt;/se:Name&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#ffd157&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;7&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\n\n\n\n\nSLD pour â€œdeals_by_countryâ€\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix â€” deals_by_country&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix â€” deals_by_country&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Single symbol&lt;/se:Name&gt;\n          &lt;se:PolygonSymbolizer&gt;\n            &lt;se:Fill&gt;\n              &lt;se:SvgParameter name=\"fill\"&gt;#fdbf6f&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"fill-opacity\"&gt;0.35&lt;/se:SvgParameter&gt;\n            &lt;/se:Fill&gt;\n            &lt;se:Stroke&gt;\n              &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-width\"&gt;1&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-linejoin\"&gt;bevel&lt;/se:SvgParameter&gt;\n            &lt;/se:Stroke&gt;\n          &lt;/se:PolygonSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\n\n\n\n\nSLD pour â€œdeals_by_country_centroidâ€\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix â€” deals_by_country_centroid&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix â€” deals_by_country_centroid&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;201 - 5466&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;201 - 5466&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;200.81000000000000227&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThanOrEqualTo&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;4&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;5466 - 20413&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;5466 - 20413&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;10&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;20413 - 61376&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;20413 - 61376&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;16&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;61376 - 160220&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;61376 - 160220&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;22&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;160220 - 1509612&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;160220 - 1509612&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;1509612&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;29&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\nUne fois que vos couches sont (Ã  nouveau) importÃ©es dans votre GeoServer et que vous parvenez Ã  les visualiser correctement, importez la couche â€œdealsâ€ dans votre application OpenLayers. Il doit sâ€™agir dâ€™une nouvelle coucheÂ : ne remplacez pas celle de lâ€™exemple que nous venons dâ€™afficherÂ ! En utilisant le TP prÃ©cÃ©dent et ce quâ€™on vient de voir, vous ne devriez pas avoir trop de difficultÃ©s.\nPour rappel, vous pouvez ouvrir lâ€™outil de dÃ©veloppement de votre navigateur avec la touche F12 et vous verrez les messages dâ€™erreur dans lâ€™onglet Console. Câ€™est eux qui vous diront ce qui ne va pas dans le codeÂ !\nAu besoin, vous pouvez utiliser une fusÃ©e de dÃ©tresse, mais comme pour les vraies, câ€™est mieux de les allumer quand on en a besoin et pas juste parce quâ€™on est curieux.\n\n\n\n\n\n\nFusÃ©e de dÃ©tresse : comment trouver lâ€™url qui pointe vers mon service wmsÂ ?\n\n\n\n\n\n\n\n\n\n\n\nPrÃ©visualisez votre couche dans GeoServer\nCopiez lâ€™URL qui est dans la barre de votre navigateur\nSupprimez tout ce qui est aprÃ¨s le â€œ?â€ et votre URL devrait se terminer par â€œwmsâ€, par exempleÂ : â€œhttp://localhost/geoserver/land_matrix/wmsâ€\n\n\n\n\n\n\n\n\n\n\nFusÃ©e de dÃ©tresseÂ : comment trouver le nom de mon espace et de ma coucheÂ ?\n\n\n\n\n\n\n\n\n\n\n\nAllez dans â€œCouchesâ€ ou â€œPrÃ©visualisation de la coucheâ€ dans GeoServer\nTrouvez votre couche dans la liste et regardez la colonne â€œNomâ€\nLa premiÃ¨re partie du nom (avant les â€œ:â€) correspond Ã  lâ€™espace et la seconde partie au nom de la couche, par exempleÂ : â€œland_matrix:dealsâ€\n\n\n\n\n\n\n\n\n\n\nFusÃ©e de dÃ©tresseÂ : Jâ€™ai crÃ©Ã© ma couche mais elle nâ€™apparaÃ®t pas sur la carte\n\n\n\n\n\n\n\n\n\n\nVous pensez avoir bien crÃ©Ã© votre source ImageWMS et votre couche ImageLayer mais il nâ€™y a rien sur la carte et pas de message dâ€™erreurÂ ?\nVÃ©rifiez que vous avez bien ajoutÃ© votre couche dans la propriÃ©tÃ© layers: de votre objet mapÂ ! Pour rappel, pour ajouter un Ã©lÃ©ment Ã  un tableau (â€œarrayâ€) en JavaScript, il faut sÃ©parer ces Ã©lÃ©ments par des virgules.\n\n\n\nSi vous avez atteint cette ligne, bravoÂ ! Si vous coincez, appelez-moi. Il faudrait que tout le monde parvienne Ã  atteindre au moins cette Ã©tape avant la fin du TP.\nSâ€™il aprÃ¨s Ã§a vous reste un peu de temps, ajoutez les couches â€œdeals_by_countryâ€ et â€œdeals_by_country_centroidâ€ Ã  la carte.\n\n\nJe suis en avanceÂ !\nPas de panique, on nâ€™a pas le temps de sâ€™ennuyer iciÂ ! On va faire un peu de HTML et de CSS. Trouvez comment gagner de lâ€™espace en haut de la page web pour ajouter un titre (avec la balise &lt;h1&gt;) et donnez un joli nom Ã  votre pageÂ !\nSi vous avez encore un peu de temps, expÃ©rimentez avec le style de la carte. Vous pouvez arrondir les coins, changer la police du titre, ou pourquoi pas commencer Ã  dÃ©gager une zone pour mettre la lÃ©gende et les options dâ€™affichage des couches.\nVous pourriez aussi relire votre code JavaScript. Est-ce que certaines informations se rÃ©pÃ¨tent, est-ce que vous pourriez les mettre dans des variablesÂ ?",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#cest-fini-pour-aujourdhui",
    "href": "cours/geonum/openlayers_geoserver.html#cest-fini-pour-aujourdhui",
    "title": "OpenLayers & GeoServer",
    "section": "Câ€™est fini pour aujourdâ€™huiÂ !",
    "text": "Câ€™est fini pour aujourdâ€™huiÂ !\nMerci Ã  vous dâ€™avoir tenu le coup, je sais que câ€™Ã©tait dense. Pendant les deux premiers cours, on a appris tout ce quâ€™il nous fallait pour les prochaines sÃ©ances. Maintenant, adieu la thÃ©orie, on va pouvoir passer Ã  la pratique et ENFIN pouvoir enrichir notre super carte interactiveÂ !",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Accueil",
    "section": "",
    "text": "Bienvenue sur mon site en cours de construction. Si vous avez trouvÃ© cette page, vous Ãªtes sÃ»rement un Ã©tudiant en master GeoNum. Les ressources pour les TD, câ€™est par iciÂ !"
  }
]