[
  {
    "objectID": "posts/maps_package.html",
    "href": "posts/maps_package.html",
    "title": "Figures layout",
    "section": "",
    "text": "Classique, on n’ajoute rien.\n\n\n\n\n\n\n\n\n\nOn utilise plus d’espace pour afficher une figure en plus large.\n\n\n\n\n\n\n\n\n\nOn peut aussi afficher les figures dans la marge, il semblerait."
  },
  {
    "objectID": "posts/maps_package.html#test-des-layouts",
    "href": "posts/maps_package.html#test-des-layouts",
    "title": "Figures layout",
    "section": "",
    "text": "Classique, on n’ajoute rien.\n\n\n\n\n\n\n\n\n\nOn utilise plus d’espace pour afficher une figure en plus large.\n\n\n\n\n\n\n\n\n\nOn peut aussi afficher les figures dans la marge, il semblerait."
  },
  {
    "objectID": "cours/geonum/09_rendu.html",
    "href": "cours/geonum/09_rendu.html",
    "title": "Enrichir ma carte",
    "section": "",
    "text": "Les profs sont encore en train de se mettre d’accord sur ce qui est demandé pour le projet final. Pour ceux qui voudraient commencer, je mets déjà quelques éléments comme le jeu de données pour que vous puissiez commencer à l’intégrer dans GeoServer.",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "cours/geonum/09_rendu.html#attention-cette-page-est-en-cours-de-rédaction",
    "href": "cours/geonum/09_rendu.html#attention-cette-page-est-en-cours-de-rédaction",
    "title": "Enrichir ma carte",
    "section": "",
    "text": "Les profs sont encore en train de se mettre d’accord sur ce qui est demandé pour le projet final. Pour ceux qui voudraient commencer, je mets déjà quelques éléments comme le jeu de données pour que vous puissiez commencer à l’intégrer dans GeoServer.",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "cours/geonum/09_rendu.html#résumé-des-éléments-demandés",
    "href": "cours/geonum/09_rendu.html#résumé-des-éléments-demandés",
    "title": "Enrichir ma carte",
    "section": "Résumé des éléments demandés",
    "text": "Résumé des éléments demandés\nEn cours de rédaction\n\nUn GeoServer qui sert au moins une couche de points requêtable (deals) et une couche de polygones (pays). Vous pouvez (et devriez certainement) servir plus de couches.\nUne page qui contient une carte OpenLayers et une carte Leaflet (ou plusieurs pages web si vous êtes très chauds).\nLe code final build (npm run build) et visible sur le serveur de production localhost:80.\nLe code mis en ligne sur un projet GitHub (on ne demande pas de branch, etc. mais juste d’avoir le code final sur GitHub).\n\n\nSur la carte OpenLayers\n\nUn menu pour choisir entre deux fonds de carte (utilisez des radio buttons).\nUn menu qui permet d’afficher / masquer les autres couches de la carte.\nUn menu qui vous permet de filtrer une des couches (probablement deals).",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "cours/geonum/09_rendu.html#le-jeu-de-données",
    "href": "cours/geonum/09_rendu.html#le-jeu-de-données",
    "title": "Enrichir ma carte",
    "section": "Le jeu de données",
    "text": "Le jeu de données\nPour ceux qui veulent commencer à importer les couches dans GeoServer.\nSi vous voulez utiliser un autre jeu de données, sur un truc qui vous intéresse plus, vous pouvez ! Tant qu’on a tous les éléments demandés dans l’évaluation, peu importe la donnée.\nland_matrix_agri",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#sommaire",
    "href": "cours/geonum/07_diapos_interactions.html#sommaire",
    "title": "Ajouter des interactions à ma carte",
    "section": "Sommaire",
    "text": "Sommaire\n\nLe DOM, l’API pour interagir avec notre document HTML\nLes évènements du DOM\nLes évènements spécifiques à OpenLayers"
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html",
    "href": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html",
    "title": "Ajouter des interactions à ma carte",
    "section": "Le DOM, l’API pour interagir avec notre document HTML",
    "text": "Le DOM, l’API pour interagir avec notre document HTML\nQui est le Dom’ ?\n\n\n\nLe DOM (Document Object Model en anglais) est une API qui représente et permet d’interagir ave tout document de langage de balisage basé sur HTML ou XML.\nLe DOM […] permet au code exécuté dans un navigateur d’accéder à chaque nœud du document et d’interagir avec lui. Les nœuds peuvent être créés, déplacés et modifiés.\n\nSource : MDN\n\n\nSource de l’image : Wikipedia"
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html-1",
    "href": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html-1",
    "title": "Ajouter des interactions à ma carte",
    "section": "Le DOM, l’API pour interagir avec notre document HTML",
    "text": "Le DOM, l’API pour interagir avec notre document HTML\nRécupérer un nœud dans mon DOM\nOn va voir comment accéder à nos éléments créés en HTML (nos nœuds du DOM) grâce à JavaScript. Si ce n’est pas déjà fait, ajoutez un titre dans le &lt;body&gt; de votre document. Assurez-vous de lui donner un identifiant unique avec id :\n&lt;h1 id=\"title\"&gt;My map&lt;/h1&gt;\nSi la carte se dessine par-dessus, vous devez lui dire de ne pas se positionner tout en haut du document.\n#map {\n  position: absolute;\n  top: 160px; /* On demande à la carte de se positionner plus bas */\n  bottom: 0;\n  width: 100%;\n}"
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html-2",
    "href": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html-2",
    "title": "Ajouter des interactions à ma carte",
    "section": "Le DOM, l’API pour interagir avec notre document HTML",
    "text": "Le DOM, l’API pour interagir avec notre document HTML\nRécupérer un nœud dans mon DOM\nMaintenant, on va utiliser le DOM (Document Object Model) pour accéder à notre titre.\nL’objet document possède des attributs et des méthodes qu’on va pouvoir utiliser à notre avantage. Nous allons nous servir de la méthode getElementById() pour récupérer notre titre. Pour rappel, voici comment notre titre a été déclaré dans le HTML :\n&lt;h1 id=\"title\"&gt;My map&lt;/h1&gt;\nDans votre fichier JS, tapez la ligne de code suivante et vérifiez le résultats dans la console de votre navigateur (rappel : appuyez sur F12 pour y accéder).\ndocument.getElementById(\"title\");"
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html-3",
    "href": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html-3",
    "title": "Ajouter des interactions à ma carte",
    "section": "Le DOM, l’API pour interagir avec notre document HTML",
    "text": "Le DOM, l’API pour interagir avec notre document HTML\nRécupérer un nœud dans mon DOM\nIl ne s’est rien passé, c’est normal ?\nOui, c’est normal. Notre application a bien récupéré notre nœud “title” mais on ne lui a pas demandé d’afficher le résultat.\nconst title = document.getElementById(\"title\");\nconsole.log(title);\nVérifiez que le résultat s’affiche bien dans votre console et passez votre souris dessus."
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html-4",
    "href": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html-4",
    "title": "Ajouter des interactions à ma carte",
    "section": "Le DOM, l’API pour interagir avec notre document HTML",
    "text": "Le DOM, l’API pour interagir avec notre document HTML\nModifier un nœud dans mon DOM\nSuper, on a réussi à récupérer notre titre ! Maintenant, on en fait quoi ?\nD’abord, récupérez le contenu de votre balise &lt;div&gt; via sa propriété innerHTML.\nconsole.log(title.innerHTML);\n\nGénéralement, si on peut récupérer quelque chose, on peut le modifier. Pour changer le contenu d’une &lt;div&gt;, c’est simple :\ntitle.innerHTML = \"Ma super carte !\";"
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html-5",
    "href": "cours/geonum/07_diapos_interactions.html#le-dom-lapi-pour-interagir-avec-notre-document-html-5",
    "title": "Ajouter des interactions à ma carte",
    "section": "Le DOM, l’API pour interagir avec notre document HTML",
    "text": "Le DOM, l’API pour interagir avec notre document HTML\nModifier un nœud dans mon DOM, à quoi ça sert ?\nModifier les nœuds après la création du document peut permettre d’ajouter dynamiquement du contenu. C’est comme ça qu’on va pouvoir créer une table attributaire, par exemple.\nDès que vous ne pouvez pas écrire quelque chose en HTML “dès le départ”, vous pouvez l’ajouter en JavaScript grâce au DOM !"
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#les-évènements-du-dom",
    "href": "cours/geonum/07_diapos_interactions.html#les-évènements-du-dom",
    "title": "Ajouter des interactions à ma carte",
    "section": "Les évènements du DOM",
    "text": "Les évènements du DOM\nLes évènements en général\n\nLes évènements sont des actions ou des occurences qui se produisent dans le système que vous programmez et dont le système vous informe afin que vous puissiez y répondre d’une manière ou d’une autre si vous le souhaitez.\n\nSource : MDN\n\nCeux du DOM\n\nLes évènements DOM sont déclenchés pour notifier au code des « changements intéressants » qui peuvent affecter l’exécution du code. Ces chagements peuvent résulter d’interactions avec l’utilisateur, comme l’utilisation de la souris […].\n\nSource : MDN"
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#les-évènements-du-dom-1",
    "href": "cours/geonum/07_diapos_interactions.html#les-évènements-du-dom-1",
    "title": "Ajouter des interactions à ma carte",
    "section": "Les évènements du DOM",
    "text": "Les évènements du DOM\nCes évènements vont donc nous permettre de savoir quand « quelque chose » se passe et d’agir en conséquence.\nPour l’exemple, on va créer un bouton sous notre titre.\n&lt;button id=\"bouton\"&gt;Bouton&lt;/button&gt;\nCliquez dessus. Il ne se passe rien… normal ! On a simplement créé un nœud “bouton” mais on ne lui a pas dit quoi faire."
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#les-évènements-du-dom-2",
    "href": "cours/geonum/07_diapos_interactions.html#les-évènements-du-dom-2",
    "title": "Ajouter des interactions à ma carte",
    "section": "Les évènements du DOM",
    "text": "Les évènements du DOM\nPour qu’il se passe quelque chose, on peut utiliser plusieurs méthodes. Ici, je vous présente .addEventListener() (c’est la méthode recommandée).\nCette méthode permet de dire à notre application d’écouter (listen) des évènements (events) et d’agir en conséquence en exécutant une fonction.\nconst button = document.getElementById(\"bouton\");\n\nfunction direBonjour() {\n  console.log(\"Bonjour !\");\n}\n\nbutton.addEventListener('click', direBonjour);\n. . . Cette fois, votre bouton devrait vous dire bonjour !"
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#les-évènements-du-dom-3",
    "href": "cours/geonum/07_diapos_interactions.html#les-évènements-du-dom-3",
    "title": "Ajouter des interactions à ma carte",
    "section": "Les évènements du DOM",
    "text": "Les évènements du DOM\nPas besoin de se contenter de console.log(), on peut faire plein d’autres choses ! Cette fois, on va faire en sorte que notre bouton change la couleur de notre titre.\nPour rappel, on récupére déjà dans notre code le nœud du titre :\nconst title = document.getElementById(\"title\");\nMaintenant, on remplace direBonjour() par une nouvelle fonction :\nfunction titreBleu() {\n  title.style.color = \"orange\";\n}\n\nbutton.addEventListener('click', titreBleu);\nEt voilà ! C’est moche, mais ça fonctionne."
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#les-évènements-du-dom-4",
    "href": "cours/geonum/07_diapos_interactions.html#les-évènements-du-dom-4",
    "title": "Ajouter des interactions à ma carte",
    "section": "Les évènements du DOM",
    "text": "Les évènements du DOM\nOn peut aussi se servir de ce bouton pour interagir avec la carte. Dans mon code, j’ai créé une couche maCouche qui est affichée sur ma carte.\nconst maCouche = new ImageLayer({\n  source: maSource,\n});\n\nOn va utiliser le bouton pour la retirer de la carte ! Pour ça, on se sert de la méthode .removeLayer() de la classe map (docs).\nAttention à bien utiliser notre variable “map” APRÈS l’avoir déclarée !\nbutton.addEventListener('click', function () {\n  map.removeLayer(maCouche);\n});\nEt voilà ! Vous verrez dans le TP d’autres méthodes pratiques pour afficher/masquer les couches de votre carte."
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#les-évènements-spécifiques-à-openlayers",
    "href": "cours/geonum/07_diapos_interactions.html#les-évènements-spécifiques-à-openlayers",
    "title": "Ajouter des interactions à ma carte",
    "section": "Les évènements spécifiques à OpenLayers",
    "text": "Les évènements spécifiques à OpenLayers\nL’API d’OpenLayers a aussi donné à la librairie des évènements très pratiques pour pouvoir interagir avec notre carte. Vous verrez les plus importants lors des prochains TPs, mais faisons un exemple ensemble.\nAccédez à la documentation de Map et regardez la section “fires”. Il s’agit de la liste des évènements qui peuvent être déclenchés par la carte."
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#les-évènements-spécifiques-à-openlayers-1",
    "href": "cours/geonum/07_diapos_interactions.html#les-évènements-spécifiques-à-openlayers-1",
    "title": "Ajouter des interactions à ma carte",
    "section": "Les évènements spécifiques à OpenLayers",
    "text": "Les évènements spécifiques à OpenLayers\nNous allons nous servir de l’évènement singleclick de la carte pour récupérer les coordonnées de notre clic sur la carte.\nimport { toLonLat } from 'ol/proj';\n\nmap.on('singleclick', function (evt) {\n  console.log(toLonLat(evt.coordinate));\n});\n\nL’évènement singleclick ne se déclenche qu’au clic simple sur la carte (il existe aussi l’évènement dblclick pour le double-clic).\nevt nous permet de récupérer les informations sur notre évènement.\nOn accède aux coordonnées avec la propriété coordinate de notre évènement.\nOn les convertit en latitude et longitude avec toLonLat()."
  },
  {
    "objectID": "cours/geonum/07_diapos_interactions.html#les-évènements-spécifiques-à-openlayers-2",
    "href": "cours/geonum/07_diapos_interactions.html#les-évènements-spécifiques-à-openlayers-2",
    "title": "Ajouter des interactions à ma carte",
    "section": "Les évènements spécifiques à OpenLayers",
    "text": "Les évènements spécifiques à OpenLayers\nÀ vous de jouer ! Vous pouvez commencer à suivre le TP pour apprendre à créer un menu d’affichage des couches et afficher une table attributaire."
  },
  {
    "objectID": "cours/geonum/06_cours_ajout_couches.html",
    "href": "cours/geonum/06_cours_ajout_couches.html",
    "title": "Ajouter des couches",
    "section": "",
    "text": "Ajouter des couches à ma carte (WMS, WFS, GeoJSON)\nLes fonctions de base pour ajouter les couches : map.addLayer() et ses dérivés\nStyliser mes couches\nAjouter une légende",
    "crumbs": [
      "Ajouter des couches"
    ]
  },
  {
    "objectID": "cours/geonum/06_cours_ajout_couches.html#objectifs-de-la-session",
    "href": "cours/geonum/06_cours_ajout_couches.html#objectifs-de-la-session",
    "title": "Ajouter des couches",
    "section": "",
    "text": "Ajouter des couches à ma carte (WMS, WFS, GeoJSON)\nLes fonctions de base pour ajouter les couches : map.addLayer() et ses dérivés\nStyliser mes couches\nAjouter une légende",
    "crumbs": [
      "Ajouter des couches"
    ]
  },
  {
    "objectID": "cours/geonum/06_cours_ajout_couches.html#supports",
    "href": "cours/geonum/06_cours_ajout_couches.html#supports",
    "title": "Ajouter des couches",
    "section": "Supports",
    "text": "Supports\nPas de support spécifique pour ce cous, référez-vous à “Développer avec NodeJS et OpenLayers” (Section “Cycle de développement”) pour le code détaillé d’affichage des couches.",
    "crumbs": [
      "Ajouter des couches"
    ]
  },
  {
    "objectID": "cours/geonum/06_cours_ajout_couches.html#tp-ajouter-mes-couches",
    "href": "cours/geonum/06_cours_ajout_couches.html#tp-ajouter-mes-couches",
    "title": "Ajouter des couches",
    "section": "TP – Ajouter MES couches",
    "text": "TP – Ajouter MES couches\n\nImporter une couche depuis mon GeoServer (version WMS)\nN’oubliez pas de créer une nouvelle branche git sur laquelle travailler ! Si vous avez un doute sur la méthode, référez-vous à “Développer avec NodeJS et OpenLayers” (Section “Cycle de développement”).\nEnsuite, vérifiez que vos containers Docker tournent toujours. Pour ça, rendez-vous sur http://localhost:8080/geoserver/ et vérifiez que vous voyez bien l’interface de GeoServer. Sinon, démarrez la stack depuis Docker Desktop ou bien ouvrez un terminal à la racine de votre projet et tapez docker compose up.\nOn souhaite maintenant ajouter une couche OpenLayers depuis notre GeoServer.\nVous avez une impression de déjà-vu ? Normal ! Si vous avez bien suivi le TP précédent, ce sera un jeu d’enfant pour vous. Pour vous aider, je vous remets ici quelques éléments :\n\nLe jeu de données land_matrix_mines à télécharger\nLe fichier de style SLD des couches à copier ci-dessous (vous n’êtes pas obligés d’utiliser ceux-ci !)\n\n\n\n\n\n\n\nSLD pour “deals”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Deal&lt;/se:Name&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#ffd157&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;7&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\n\n\n\n\nSLD pour “deals_by_country”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals_by_country&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals_by_country&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Single symbol&lt;/se:Name&gt;\n          &lt;se:PolygonSymbolizer&gt;\n            &lt;se:Fill&gt;\n              &lt;se:SvgParameter name=\"fill\"&gt;#fdbf6f&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"fill-opacity\"&gt;0.35&lt;/se:SvgParameter&gt;\n            &lt;/se:Fill&gt;\n            &lt;se:Stroke&gt;\n              &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-width\"&gt;1&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-linejoin\"&gt;bevel&lt;/se:SvgParameter&gt;\n            &lt;/se:Stroke&gt;\n          &lt;/se:PolygonSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\n\n\n\n\nSLD pour “deals_by_country_centroid”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals_by_country_centroid&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals_by_country_centroid&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;201 - 5466&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;201 - 5466&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;200.81000000000000227&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThanOrEqualTo&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;4&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;5466 - 20413&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;5466 - 20413&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;10&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;20413 - 61376&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;20413 - 61376&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;16&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;61376 - 160220&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;61376 - 160220&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;22&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;160220 - 1509612&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;160220 - 1509612&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;1509612&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;29&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\nUne fois que vos couches sont (à nouveau) importées dans votre GeoServer et que vous parvenez à les visualiser correctement, importez la couche “deals” dans votre application OpenLayers. Il doit s’agir d’une nouvelle couche : ne remplacez pas celle de l’exemple que nous venons d’afficher !\nPour rappel, vous pouvez ouvrir l’outil de développement de votre navigateur avec la touche F12 et vous verrez les messages d’erreur dans l’onglet Console. C’est eux qui vous diront ce qui ne va pas dans le code !\nAu besoin, vous pouvez utiliser une fusée de détresse, mais comme pour les vraies, c’est mieux de les allumer quand on en a besoin et pas juste parce qu’on est curieux.\n\n\n\n\n\n\nFusée de détresse : comment trouver l’url qui pointe vers mon service wms ?\n\n\n\n\n\n\n\n\n\n\n\nPrévisualisez votre couche dans GeoServer\nCopiez l’URL qui est dans la barre de votre navigateur\nSupprimez tout ce qui est après le “?” et votre URL devrait se terminer par “wms”, par exemple : “http://localhost:8080/geoserver/land_matrix/wms”\n\n\n\n\n\n\n\n\n\n\nFusée de détresse : comment trouver le nom de mon espace et de ma couche ?\n\n\n\n\n\n\n\n\n\n\n\nAllez dans “Couches” ou “Prévisualisation de la couche” dans GeoServer\nTrouvez votre couche dans la liste et regardez la colonne “Nom”\nLa première partie du nom (avant les “:”) correspond à l’espace et la seconde partie au nom de la couche, par exemple : “land_matrix:deals”\n\n\n\n\n\n\n\n\n\n\nFusée de détresse : J’ai créé ma couche mais elle n’apparaît pas sur la carte\n\n\n\n\n\n\n\n\n\n\nVous pensez avoir bien créé votre source ImageWMS et votre couche ImageLayer mais il n’y a rien sur la carte et pas de message d’erreur ?\nVérifiez que vous avez bien ajouté votre couche dans la propriété layers: de votre objet map ! Pour rappel, pour ajouter un élément à un tableau (“array”) en JavaScript, il faut séparer ces éléments par des virgules.\n\n\n\nSi vous avez atteint cette ligne, bravo ! Ensuite, ajoutez les couches “deals_by_country” et “deals_by_country_centroid” à la carte.\n\n\nImporter une couche depuis mon GeoServer (version WFS)\nLes images, c’est bien, mais peut-être qu’on voudrait plutôt récupérer les features de notre couche et les styliser directement dans l’application pour ajouter plus d’interaction.\nNotre objectif va être d’afficher notre couche dealsByCountryCentroid et de la styliser pour afficher des cercles proportionnels. Et vous allez voir que récupérer une couche WFS avec OpenLayers, c’est du gâteau.\nJe vous donne la structure du code à écrire dans main.js. N’oubliez pas que les éléments encadrés par des chevrons \"&lt;un_truc&gt;\" doivent être remplacés par une vraie valeur. Par exemple, si je vous écris const formation = \"&lt;ma_formation&gt;\", vous devrez mettre dans votre code const formation = \"geonum\". Facile ! Voilà donc le snippet de base :\n// N’oubliez pas de mettre un commentaire pour m’expliquer ce que vous faites\nconst sourceCentroid = new VectorSource({\n  format: new GeoJSON(),\n  url: '&lt;mon_flux_wfs&gt;'\n});\n\nconst layerCentroid = new VectorLayer({\n  source: sourceCentroid,\n});\n… et les imports à ajouter tout en haut du fichier :\nimport VectorSource from 'ol/source/Vector';\nimport GeoJSON from 'ol/format/GeoJSON.js';\nimport VectorLayer from 'ol/layer/Vector';\nVous remarquez que vous avons un élément &lt;mon_flux_wms&gt; à remplacer. Pour trouver l’URL de ce flux, allez dans votre interface GeoServer, sélectionnez “Prévisualisation de la couche”. Cette fois, au lieu de choisir “OpenLayers” (qui nous donne le flux WMS), allez dans la colonne “Tous les formats” et sélectionnez GeoJSON. Je rappelle qu’on ne travaille plus sur la couche deals mais bien sur la couche dealsByCountryCentroid. Il ne vous reste plus qu’à copier l’URL dans votre navigateur : c’est la valeur de url dans votre VectorSource().\n\n\n\n\n\n\nOups, j’ai oublié de retirer les chevrons “&lt;” en collant mon url\n\n\n\n\n\n\n\n\n\n\n\n\n\nIl ne reste plus qu’une seule étape pour afficher la couche sur la carte. Je vous laisse trouver laquelle !\n\n\n\n\n\n\nAllez, un petit indice ?\n\n\n\n\n\nVous l’avez déjà fait plusieurs fois dans le TP précédent et celui-ci, et c’est souvent une étape qu’on oublie.\n\n\n\n\n\n\n\n\n\n\n\nJe ne trouve vraiment pas…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPromis, j’ai vraiment cherché !\n\n\n\n\n\nBon, d’accord. Dites-moi, comment se porte l’attribut layers de votre objet map ?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUne fois cette étape complétée, la couche devrait apparaître sur votre carte. Super ! Par contre, ça ressemble certainement à des cercles blancs, un peu transparents, avec un contour bleu. Et surtout, ce ne sont pas des cercles proportionnels !\nHeureusement, vous avez été bien attentifs pendant vos cours de Leaflet et vous avez déjà stylisé des couches à partir de donnée GeoJSON, ça devrait être super facile pour vous. Comme la documentation GeoServer n’est pas très claire sur ce point, je vous donne un snippet et je vais vous demander de l’ajuster un peu pour vérifier que vous comprenez bien qui fait quoi.\nD’abord, on importe les éléments de style dont on va avoir besoin :\nimport {Circle, Fill, Stroke, Style} from 'ol/style.js';\nOn commence par créer un style “pas proportionnel” qu’on stocke dans la constante styleCentroid.\nconst styleCentroid = new Style({\n  image: new Circle({\n    radius: 40,\n    fill: new Fill({ color: 'white' }),\n    stroke: new Stroke({ color: 'blue', width: 5 }),\n  }),\n});\nN’oubliez pas d’appeler votre style dans la propriété style de votre VectorLayer ou bien la couche ne changera pas.\nconst layerCentroid = new VectorLayer({\n  source: sourceCentroid,\n  style: styleCentroid    // On a rajouté cette ligne\n});\nAttention à l’ordre dans lequel vous ajoutez les éléments dans le code. N’oubliez pas que pour appeler une constante (ou une variable) comme styleCentroid, il faut avoir défini celle-ci avant !\nRegardez à quoi ressemble la couche maintenant qu’on lui a donné un style. C’est moche, hein ? Et bien c’est à vous de la rendre belle. Modifiez le code pour obtenir quelque chose qui ressemble à ça :\n\n\n\n\n\nNotez que les cercles ne sont pas entièrement opaques. Prenez le temps de vous appliquer, cela vous servira de base pour la suite. Quand vous avez terminé, vous pouvez utiliser ce snippet pour afficher des cercles proportionnels.\nfunction getStyleCentroid(feature) {\n  const nDeals = feature.get('n_deals');\n  const rayon = Math.sqrt(nDeals) * 0.01;\n  const style = new Style({\n    image: new Circle({\n      radius: rayon,\n      fill: new Fill({ color: 'white' }),\n      stroke: new Stroke({ color: 'blue', width: 5 }),\n    }),\n  });\n  return style;\n}\n\nconst layerCentroid = new VectorLayer({\n  source: sourceCentroid,\n  style: getStyleCentroid,\n});\nVous noterez que la différence principale ici est qu’on appelle une fonction et non une constante, et que cette fonction prend feature en argument. En fait, ce qu’il se passe, c’est que la fonction va regarder chaque objet de ma couche (chaque feature) et appliquer les étapes qu’on a définies à l’intérieur.\n\non lit un attribut de notre feature avec la méthode .get()\non calcule un rayon\non définit notre style comme précédemment, mais au lieu d’être une valeur fixe, notre propriété radius prend la valeur de notre rayon\n\nJe suis restée volontairement vague dans ce cas pour ne pas vous souffler toutes les réponses. Comme précédemment, vous allez devoir modifier le snippet de code pour rendre la couche un peu plus élégante. Je vous montre mon exemple, essayez de le reproduire le plus fidèlement possible :\n\n\n\n\n\nUne fois que c’est terminé, il reste un dernier exercice à faire avec ces cercles proportionnels. Vous aurez compris qu’ici, nos cercles sont proportionnels au nombre de deals qui sont enregistrés dans le pays. Maintenant, créez une couche de cercles proportionnels en vous basant sur la surface total couverte par les deals dans chaque pays.\nOn arrive sur la fin du TP et vous commencez (j’espère) à bien comprendre comment fonctionne notre application donc je ne vous donne pas d’indices. Faites juste attention à bien faire varier la taille des cercles petit à petit : si jamais votre navigateur essaie de dessiner des cercles trop grands, vous avez des chances de faire crasher votre machine (ça m’est peut-être arrivé pendant mes tests et ce serait dommage que ça vous arrive aussi).\n\n\nEt maintenant, le détail qui tue…\nQuand on développe une application, on essaie d’éviter d’utiliser les chemins absolus ou bien d’éviter de les répéter.\n\n\n\n\n\n\nChemins absolus, chemins relatifs\n\n\n\nSi vous ne savez pas ce que sont des chemins absolus et chemins relatifs, regardez votre terminal. Vous devriez avoir votre nom et le chemin vers votre geonum_docker. Chez moi, ça ressemble à ça :\nmarie@pop-os:~/Documents/Cours/GeoNum/Webmapping/geonum_docker$\nLa partie ~/Documents/Cours/GeoNum/Webmapping/geonum_docker$ est le chemin absolu vers mon projet geonum_docker. Si je voulais accéder à app, j’aurais deux choix :\n# Utliser le chemin absolu\ncd ~/Documents/Cours/GeoNum/Webmapping/geonum_docker/app\n\n# Utiliser le chemin relatif au répertoire où je me trouve, ici genum_docker\ncd ./app\n\n# ou bien, aussi en relatif\ncd app\n\n\nQuand vous avez appelé votre GeoServer, vous avez utilisé une URL qui pointe vers un chemin absolu sur votre ordinateur (localhost). Le problème, c’est que ce chemin d’accès va changer quand on mettra en ligne notre application (pas celle-ci, mais celle du projet GeoNum).\nAutrement dit, la personne qui devra mettre en ligne votre application devra d’abord démarrer votre GeoServer, puis retourner copier-coller l’URL et aller la modifier partout où vous allez l’utiliser dans votre code. C’est beaucoup trop fastidieux.\nOn va donc utiliser une bonne pratique de code qui va aussi régler ce problème : éviter au maximum de répéter une information qui ne change pas. Vous allez donc pouvoir créer une variable dans laquelle stocker l’URL de votre GeoServer (la partie que vous collez après url quand vous créez une source).\nJe ne vous donne pas la solution ici comme ça faciliterait trop les étapes précédentes, mais j’ai confiance en vous, vous pouvez le faire ! Appelez-moi si vous avez un doute ou que ça ne fonctionne pas.\n\n\nJe suis en avance !\nPas de panique, on n’a pas le temps de s’ennuyer ici ! On va faire un peu de HTML et de CSS. Trouvez comment gagner de l’espace en haut de la page web pour ajouter un titre (avec la balise &lt;h1&gt;) et donnez un joli nom à votre page si ce n’est pas déjà fait !\nEnsuite, expérimentez avec le style de la carte. Vous pouvez arrondir les coins, changer la police du titre, ou pourquoi pas commencer à dégager une zone pour mettre la légende et les options d’affichage des couches.\nVous pourriez aussi relire votre code JavaScript. Est-ce que certaines informations se répètent, est-ce que vous pourriez les mettre dans des variables ?",
    "crumbs": [
      "Ajouter des couches"
    ]
  },
  {
    "objectID": "cours/geonum/06_cours_ajout_couches.html#cest-fini-pour-aujourdhui",
    "href": "cours/geonum/06_cours_ajout_couches.html#cest-fini-pour-aujourdhui",
    "title": "Ajouter des couches",
    "section": "C’est fini pour aujourd’hui !",
    "text": "C’est fini pour aujourd’hui !\nBien joué ! Maintenant que vous avez une base solide pour votre carte, on va pouvoir ajouter des interactions avec celle-ci au cours des prochaines séances.",
    "crumbs": [
      "Ajouter des couches"
    ]
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#sommaire",
    "href": "cours/geonum/05_diapos_ai.html#sommaire",
    "title": "Un point sur l’IA générative",
    "section": "Sommaire",
    "text": "Sommaire\n\nPourquoi ce point ?\nIntroduction au concept d’intelligence artificielle\nLe cas de l’IA générative, exemple avec Chat-GPT\nLe coût de l’IA générative\nConseils pour utiliser l’IA : efficacité et esprit critique\nSi on a le temps de débattre un peu…\nLe mot de la fin"
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#pourquoi-ce-point",
    "href": "cours/geonum/05_diapos_ai.html#pourquoi-ce-point",
    "title": "Un point sur l’IA générative",
    "section": "Pourquoi ce point ?",
    "text": "Pourquoi ce point ?\nD’abord, pour moi.\nParce qu’à force d’entendre tout et n’importe quoi sur cet outil que j’ai commencé à utiliser un peu plus tard que la moyenne (l’an dernier), il fallait que j’éclaire quelques points.\n\nEnsuite, pour vous aussi.\nC’est toujours mieux de comprendre un outil qu’on utilise. Vous pourriez apprendre des choses (en tout cas j’espère) qui changeront votre manière de l’aborder."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#pourquoi-ce-point-1",
    "href": "cours/geonum/05_diapos_ai.html#pourquoi-ce-point-1",
    "title": "Un point sur l’IA générative",
    "section": "Pourquoi ce point ?",
    "text": "Pourquoi ce point ?\nL’IA dans mon cours : oui, avec intelligence et transparence\nVous avez le droit d’utiliser l’IA générative pendant mon cours et pour les rendus.\nPar contre, je vous demande de le faire intelligemment et avec transparence.\n\nIntelligemment : en fait, il faudrait plutôt dire le faire quand on en a besoin (et pas par réflexe ou pire, par fainéantise), de rédiger des prompts efficaces, de toujours conserver un esprit critique quand vous utilisez l’IA et de revoir les réponses pour les affiner (surtout si vous générez du texte).\nAvec transparence : si vous utilisez de l’IA générative dans un rapport, dans votre code, etc. je dois pouvoir savoir laquelle vous avez utilisé et pourquoi (générer du code ? générer le texte de présentation de votre application ?). Vous verrez que je vous demande parfois de garder un ou deux prompts en exemple.\n\n\nLa partie “intelligemment” devrait venir petit à petit quand vous comprendrez mieux l’outil."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#pourquoi-ce-point-2",
    "href": "cours/geonum/05_diapos_ai.html#pourquoi-ce-point-2",
    "title": "Un point sur l’IA générative",
    "section": "Pourquoi ce point ?",
    "text": "Pourquoi ce point ?\nDe grandes inconnues autour d’un outil du quotidien\n\nQui sait quelle est la différence entre IA, ML, LLM, IA générative ?\nSavez-vous comment fonctionne une IA générative ?\nQui ici est déjà allé se renseigner sur le fonctionnement des IA génératives ? Leur entraînement ? Leur coût ?"
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#introduction-au-concept-dintelligence-artificielle",
    "href": "cours/geonum/05_diapos_ai.html#introduction-au-concept-dintelligence-artificielle",
    "title": "Un point sur l’IA générative",
    "section": "Introduction au concept d’intelligence artificielle",
    "text": "Introduction au concept d’intelligence artificielle"
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#le-cas-de-lia-générative-exemple-avec-chat-gpt",
    "href": "cours/geonum/05_diapos_ai.html#le-cas-de-lia-générative-exemple-avec-chat-gpt",
    "title": "Un point sur l’IA générative",
    "section": "Le cas de l’IA générative, exemple avec Chat-GPT",
    "text": "Le cas de l’IA générative, exemple avec Chat-GPT\nRegarder la vidéo explicative de Frandroid : 7min pour savoir comment fonctionne CHATGPT (et se la péter ensuite)\n\nFaisons une liste de ce qu’on a appris sur l’IA générative."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#le-cycle-de-la-vie-de-lia-générative",
    "href": "cours/geonum/05_diapos_ai.html#le-cycle-de-la-vie-de-lia-générative",
    "title": "Un point sur l’IA générative",
    "section": "Le cycle de la vie de l’IA générative",
    "text": "Le cycle de la vie de l’IA générative\nChat-GPT est un chatbot basé sur le modèle GPT-4 de OpenAI. D’autres agents conversationnels connus sont Llama3 (Meta, Open-Source), Gemini (Google), Claude (Anthropic). Ces modèles sont entraînés de la même manière :\n\nD’abord, une phase de pré-entraînement expose le modèle à un corpus massif de livres, articles et autres contenus accessibles en ligne. Il utilise ce corpus pour apprendre à prédire un mot dans une phrase. C’est à ce moment qu’il détecte des relations entre les mots (par exemple, chaud et froid qui sont souvent utilisés ensemble, en opposition), prédire des structures grammaticales, etc.\nEnsuite, la phase de fine-tuning permet d’affiner le modèle pour qu’il réponde à des besoins spécifiques (par exemple, les agents conversationnels doivent pouvoir tenir des conversations). On demande à des humains de vérifier les réponses de Chat-GPT et dire si oui ou non elles sont correctes, correspondent à la demande, si elles sont appropriées (questions d’éthique surtout), etc.\n\nSource: Comment Fonctionne un Modèle de Langage comme ChatGPT ? — Technomind"
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#le-coût-de-lia-générative",
    "href": "cours/geonum/05_diapos_ai.html#le-coût-de-lia-générative",
    "title": "Un point sur l’IA générative",
    "section": "Le coût de l’IA générative",
    "text": "Le coût de l’IA générative\n\n\nLa phase d’entraînement (c.f. diapo précédente) demande à des milliers de GPU (NVIDIA, ça vous parle ?) qui tournent à plein régime pendant des mois.\n\n\n\n\nEn 2026, la hausse de la consommation électrique des centres de données, des cryptomonnaies et de l’IA pourrait s’élever à l’équivalent de la consommation électrique de la Suède ou de l’Allemagne, par rapport à 2022.\nL’empreinte carbone de l’IA est loin d’être négligeable, ainsi, des scientifiques estiment que l’entraînement du modèle d’IA BLOOM émet 10 fois plus de gaz à effet de serre qu’un Français en une année.\nSource : https://www.polytechnique-insights.com/tribunes/energie/ia-generative-la-consommation-energetique-explose/"
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#le-coût-de-lia-générative-1",
    "href": "cours/geonum/05_diapos_ai.html#le-coût-de-lia-générative-1",
    "title": "Un point sur l’IA générative",
    "section": "Le coût de l’IA générative",
    "text": "Le coût de l’IA générative\n\nLa phrase d’inférence (quand vous faites vos requêtes) consomme aussi énormément. L’eau est particulièrement touchée. Elle est utilisée pour refroidir les serveurs : chaque requête consomme en moyenne 1/2 litre d’eau.\n\n\n\nLes interactions avec des IA comme ChatGPT pourraient consommer 10 fois plus d’électricité qu’une recherche Google classique, d’après l’Agence internationale de l’énergie.\nSource: https://www.polytechnique-insights.com/tribunes/energie/ia-generative-la-consommation-energetique-explose/"
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#le-coût-de-lia-générative-2",
    "href": "cours/geonum/05_diapos_ai.html#le-coût-de-lia-générative-2",
    "title": "Un point sur l’IA générative",
    "section": "Le coût de l’IA générative",
    "text": "Le coût de l’IA générative\nPosez-vous la question : Est-ce que j’ai vraiment besoin de cette requête ?\n\nJ’ai demandé à Gemini de me parler de son coût environnemental. Voilà une partie de sa réponse :\n\nMessage : “Utiliser l’IA pour générer un ‘Hello World’ en HTML, c’est comme prendre l’avion pour aller acheter du pain. C’est possible, mais est-ce raisonnable ?”"
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique",
    "href": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique",
    "title": "Un point sur l’IA générative",
    "section": "Conseils pour utiliser l’IA : efficacité et esprit critique",
    "text": "Conseils pour utiliser l’IA : efficacité et esprit critique\nJ’ai utilisé Gemini pour générer des conseils pour rédiger un prompt efficace (réponses éditées pour ajouter des éléments et retirer une hallucination de l’IA). Voilà son exemple de “mauvais prompt” :\n\n\n“Fais-moi une carte avec des mines de lithium en rouge à partir de mon fichier geojson. Mets un fond de carte Stamen Watercolor et ajoute du texte en bas pour expliquer le contexte.”\n\n\n\nIl n’y a aucun contexte technique : l’IA ne sait pas si on veut utiliser Leaflet, OpenLayers, MapBox… elle va donc deviner. (Dans la réponse de l’IA, le nom de Leaflet est revenu le plus fréquemment).\nL’IA ignore les données et leur structure. Elle ne peut pas examiner la structure d’un éventuel fichier d’entrée et inventer des noms de colonnes “logiques” mais faux.\nLa demande d’ajouter du “texte en bas” est aussi trop floue, l’IA va produire du texte d’une longueur non contrôlée (vous espérez cinq lignes et vous avez cinq paragraphes).\nDans tous les cas, il reste le problème de la version utilisée (que ce soit pour Leaflet/OpenLayers ou pour la ressource de couche Stamen). L’IA ne pourra utiliser que des informations sur lesquelles elle a été entraînée qui deviennent très rapidement obsolètes dans le contexte du développement informatique. Préciser une version demandée ou aller chercher un lien vers une couche soi-même permet d’éviter d’écrire du code obsolète."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-1",
    "href": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-1",
    "title": "Un point sur l’IA générative",
    "section": "Conseils pour utiliser l’IA : efficacité et esprit critique",
    "text": "Conseils pour utiliser l’IA : efficacité et esprit critique\nVoilà maintenant son exemple de “bon prompt” (j’ai surligné en vert les passages qui me semblent discutables).\n\n\n\nRôle : Agis comme un développeur web expert en géomatique.\nContexte technique : Je crée une page web avec la librairie OpenLayers (version 8 ou supérieure). J’ai un fichier local nommé mines.geojson.\nDescription des données : Dans ce GeoJSON, chaque point a une propriété nommée “produce”.\nTâches à réaliser :\nInitialise une carte centrée sur le monde avec le fond de carte Stamen Watercolor (Attention : utilise les URLs valides actuelles via Stadia Maps si possible, ou préviens-moi si tu n’es pas sûr).\nCharge le fichier mines.geojson.\nApplique un style conditionnel : Si la propriété “produce” est égale à “lithium”, le point doit être un cercle rouge. Sinon, utilise une couleur par défaut.\nAjoute des éléments HTML hors de la carte : Un titre &lt;h1&gt;, un sous-titre &lt;h3&gt; avec le texte “Étudiant : [Mon Nom]”, et un &lt;footer&gt;.\nGénération de texte : Dans le footer, rédige un paragraphe de 5 phrases maximum expliquant les enjeux géopolitiques et environnementaux de l’extraction du lithium aujourd’hui. Ajoute l’année du Master.\nContrainte : Ne génère pas tout le code d’un coup, explique d’abord la logique du style conditionnel."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-2",
    "href": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-2",
    "title": "Un point sur l’IA générative",
    "section": "Conseils pour utiliser l’IA : efficacité et esprit critique",
    "text": "Conseils pour utiliser l’IA : efficacité et esprit critique\nCe qui fonctionne :\n\nLe prompt est structuré en parties claires ce qui permet à l’IA (et aussi et surtout à vous) de bien dégager les éléments dont vous avez besoin pour coder : contexte, données, librairies et versions, etc.\nOn indique qu’on utilise OpenLayers et sa version ce qui limite la probabilité de générer du code obsolète.\nOn indique à l’IA la structure du jeu de données (en tout cas la partie qui nous intéresse), elle pourra donc inclure les champs de la donnée dans le code sans halluciner (donc sans inventer un nom probable mais faux).\nL’ordre des étapes est clair et permet à l’IA de structurer le code (et ajouter ses commentaires) en conséquence.\nLes éléments HTML sont clairement indiqués par les balises qu’on attend. L’IA n’aura pas à deviner de quelles balises on aura besoin et aura de grandes chances de bien les positionner.\nLa longueur du texte attendu et son contenu sont clairs. L’IA a de grandes chances de générer un texte qui correspond à nos attentes."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-3",
    "href": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-3",
    "title": "Un point sur l’IA générative",
    "section": "Conseils pour utiliser l’IA : efficacité et esprit critique",
    "text": "Conseils pour utiliser l’IA : efficacité et esprit critique\nCe qui, selon moi, doit encore être amélioré :\n\n\n(Attention : utilise les URLs valides actuelles via Stadia Maps si possible, ou préviens-moi si tu n’es pas sûr)\n\n(De ce que j’ai compris de son fonctionnement et par expérience), l’IA n’aura pas de moyens d’être “sûre” d’utiliser la nouvelle version. Elle aura des chances de simplement retourner quelque chose comme “Je ne suis pas sûre, allez vérifier sur les sources officielles” ou, pire, “Je suis sûre d’utiliser la dernière version” alors que ce n’est pas le cas.\n\n\n\nCharge le fichier mines.geojson.\n\nÇa, même pour un humain, c’est flou. J’écrirais “Charge le fichier nommé mines.geojson dans l’application”.\n\n\nAttention aussi à revoir le texte généré : on travaille notamment sur des mines, qui sont concentrées sur de certaines régions du mondes qui peuvent être victimes de biais de la part de l’IA en fonction du corpus sur lequel elle a été entraînée."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-4",
    "href": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-4",
    "title": "Un point sur l’IA générative",
    "section": "Conseils pour utiliser l’IA : efficacité et esprit critique",
    "text": "Conseils pour utiliser l’IA : efficacité et esprit critique\nEn règle générale, quand vous générez du texte, relisez toujours et remettez toujours en question ce que dit l’IA : plus l’élément est important et plus vous devez passer de temps à vérifier sa véracité."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-5",
    "href": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-5",
    "title": "Un point sur l’IA générative",
    "section": "Conseils pour utiliser l’IA : efficacité et esprit critique",
    "text": "Conseils pour utiliser l’IA : efficacité et esprit critique\nGemini a conclu sa réponse avec une liste de “Do’s” and “Don’t” suffisamment intéressante pour que je vous la partage aussi. Cette liste est non-exhaustive, améliorable et en partie éditée par mes soins (texte en couleur).\n\n\n🟢 À FAIRE (DOs)\n\nDécrire les données : Toujours dire à l’IA comment s’appellent vos colonnes/attributs (ex: “J’ai une colonne ‘population’ et une colonne ‘nom_ville’”). L’IA ne peut pas voir vos fichiers locaux !\nPréciser la version : Les librairies JS évoluent vite. Précisez “OpenLayers v7+” sinon vous aurez du code de 2015 (v3) incompatible. Souvenez-vous que l’IA ne peut pas utiliser une version de la librairie sur laquelle elle n’a pas été entraînée. Les dernières fonctions ne seront peut-être pas disponibles et elle pourait vous donner des fonctions obsolètes.\nDemander des commentaires : Ajoutez “Commente chaque ligne importante du code” pour comprendre ce que vous copiez. L’IA commente parfois “trop”. Vous pouvez lui demander d’ajuster la fréquence des commentaires.\nDécouper le problème : Ne demandez pas tout le site d’un coup. Demandez d’abord l’affichage de la carte, puis le chargement du GeoJSON, puis le style. Mais essayez quand même de limiter le nombre de prompts. C’est une question d’équilibre !\n\n\n🔴 À NE PAS FAIRE (DON’Ts)\n\nFaire confiance aveuglément aux URLs : L’IA invente souvent des liens vers des données ou des tuiles qui n’existent plus. Vérifiez toujours la documentation.\nCopier-coller sans lire : C’est la garantie d’avoir des variables qui s’appellent var map en haut et const myMap en bas, ce qui cassera le code.\nOublier l’esprit critique : Si l’IA propose une fonction map.enable3DMode(), demandez-vous si ça existe vraiment dans OpenLayers (spoiler : non, c’est du CesiumJS ou du Mapbox, l’IA hallucine souvent des mix de librairies). L’IA vient de nous faire une superbe hallucination, parce que je n’ai pas non plus trouvé cette fonction dans CesiumJS ni Mapbox."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-6",
    "href": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-6",
    "title": "Un point sur l’IA générative",
    "section": "Conseils pour utiliser l’IA : efficacité et esprit critique",
    "text": "Conseils pour utiliser l’IA : efficacité et esprit critique\nEnfin, voici quelques exemples de biais à garder en tête quand on utilise de l’IA générative.\nBiais présents lors de la sélection des données :\n\nBiais de sélection et biais d’omission : au moment de l’entraînement du modèle, sélection consciente ou inconsciente de donnée qui confirme des croyances ou hypothèses existantes.\nBiais de disponibilité : le modèle est plus entraîné sur de l’information facilement accessible qui peut ne pas être complète.\nBiais de représentativité : Les données utilisées ne reflètent pas correctement la diversité des personnes ou des cas d’utilisation.\nBiais de préjugés: Des stéréotypes ou hypothèses sociétales erronnées se retrouvent dans le jeu de données ce qui conduit le modèle à les “adopter”.\n\n_Sources : https://www.iqo.eu/data/biais-humains-ia-generative/ et https://www.ibm.com/fr-fr/think/topics/ai-bias_"
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-7",
    "href": "cours/geonum/05_diapos_ai.html#conseils-pour-utiliser-lia-efficacité-et-esprit-critique-7",
    "title": "Un point sur l’IA générative",
    "section": "Conseils pour utiliser l’IA : efficacité et esprit critique",
    "text": "Conseils pour utiliser l’IA : efficacité et esprit critique\nEnfin, voici quelques exemples de biais à garder en tête quand on utilise de l’IA générative.\nBiais présents lors de l’utilisation du modèle :\n\nBiais d’automatisation : Il s’agit de la confiance excessive de l’utilisateur dans les performances du modèle qui négligera donc ses vérifications.\nIllusion de connaissance : C’est la croyance de l’utilisateur dans le fait que le modèle comprend les sujets ou répond aux questions de manière plus précise qu’elle ne le fait réellement. Ce biais est particulièrement préjudiciable dans le cas d’hallucinations.\nBiais de confirmation : C’est l’interprétation des résultats (ou même la rédaction de prompts) d’une manière qui confirme nos croyances préexistantes."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#si-on-a-le-temps-de-débattre-un-peu",
    "href": "cours/geonum/05_diapos_ai.html#si-on-a-le-temps-de-débattre-un-peu",
    "title": "Un point sur l’IA générative",
    "section": "Si on a le temps de débattre un peu…",
    "text": "Si on a le temps de débattre un peu…\n…voici quelques questions qui peuvent vous donner à réfléchir."
  },
  {
    "objectID": "cours/geonum/05_diapos_ai.html#le-mot-de-la-fin",
    "href": "cours/geonum/05_diapos_ai.html#le-mot-de-la-fin",
    "title": "Un point sur l’IA générative",
    "section": "Le mot de la fin",
    "text": "Le mot de la fin\nL’IA générative est un outil auquel vous êtes déjà confrontés au quotidien et serez (très, très certainement) confrontés dans le monde du travail.\nServez-vous en avec intelligence et esprit critique, et je ne peux que vous conseiller de vous documenter sur le sujet.\nConfrontez les points de vue, identifiez les biais des utilisateurs de l’IA, de ses défenseurs et ses opposants. Comment est-ce qu’elle transforme notre société, comment est-ce qu’elle déplace les compétences demandées aux humains ?\nEt faites un peu de prévention auprès de vos proches qui s’en servent un peu trop sans réfléchir !"
  },
  {
    "objectID": "cours/geonum/04_diapos_intro_openlayers.html#sommaire",
    "href": "cours/geonum/04_diapos_intro_openlayers.html#sommaire",
    "title": "Introduction à OpenLayers",
    "section": "Sommaire",
    "text": "Sommaire\n\nPrésentation brève d’OpenLayers\nPrésentation (brève aussi) de NodeJS"
  },
  {
    "objectID": "cours/geonum/04_diapos_intro_openlayers.html#objectif-du-cours",
    "href": "cours/geonum/04_diapos_intro_openlayers.html#objectif-du-cours",
    "title": "Introduction à OpenLayers",
    "section": "Objectif du cours",
    "text": "Objectif du cours\nCréer une application OpenLayers avec NodeJS."
  },
  {
    "objectID": "cours/geonum/04_diapos_intro_openlayers.html#présentation-brève-dopenlayers",
    "href": "cours/geonum/04_diapos_intro_openlayers.html#présentation-brève-dopenlayers",
    "title": "Introduction à OpenLayers",
    "section": "Présentation brève d’OpenLayers",
    "text": "Présentation brève d’OpenLayers\n\nOpenLayers est une librairie JavaScript Open Source qui permet de créer des cartes interactives pour le web.\nLa librairie a plus de 11 000 stars sur GitHub et 3 000 forks.\nAu moment où j’écris ce cours, la dernière mise à jour date de hier.\nL’alpha d’OpenLayers (première version mise en ligne sur GitHub) date de 2013.\n\nC’est une librairie populaire, mature, maintenue et bien documentée."
  },
  {
    "objectID": "cours/geonum/04_diapos_intro_openlayers.html#présentation-brève-dopenlayers-1",
    "href": "cours/geonum/04_diapos_intro_openlayers.html#présentation-brève-dopenlayers-1",
    "title": "Introduction à OpenLayers",
    "section": "Présentation brève d’OpenLayers",
    "text": "Présentation brève d’OpenLayers\n🤔 Ça ressemble en tout point à Leaflet, non ? Alors pourquoi apprendre les deux ?\n\n👉 Oui et non !\n\nLeaflet est plus pratique pour obtenir rapidement une “jolie” carte avec moins de code, par exemple afficher/masquer les couches.\nMais Leaflet a aussi ses défauts : la carte est plus difficile à customiser “en profondeur” qu’OpenLayers, il y a de nombreux plug-ins qui parfois font plus ou moins la même chose, parfois ne sont plus maintenus, là où beaucoup de ces fonctionnalités sont disponibles dans le code de base d’OpenLayers.\n\n\n\nPour faire simple, selon mon expérience avec les deux librairies, OpenLayers est plus facilement customisable et se repose moins sur des plug-ins externes. Il existe une source de plug-ins pour ajouter des fonctionnalités supplémentaires publiée par l’utilisateur GitHub viglino. Ces extensions ol-ext sont régulièrement maintenues."
  },
  {
    "objectID": "cours/geonum/04_diapos_intro_openlayers.html#présentation-brève-dopenlayers-2",
    "href": "cours/geonum/04_diapos_intro_openlayers.html#présentation-brève-dopenlayers-2",
    "title": "Introduction à OpenLayers",
    "section": "Présentation brève d’OpenLayers",
    "text": "Présentation brève d’OpenLayers\nIl est donc intéressant de savoir utiliser à la fois Leaflet et OpenLayers car chacune des librairies a ses points forts et ses faiblesses.\nCela dit, en ce qui concerne un usage simplifié, si vous comprenez Leaflet vous comprenez aussi OpenLayers.\n\nOn va devoir créer une application Node JS pour pouvoir importer la librairie OpenLayers et commencer à coder."
  },
  {
    "objectID": "cours/geonum/04_diapos_intro_openlayers.html#les-bases-de-node-js",
    "href": "cours/geonum/04_diapos_intro_openlayers.html#les-bases-de-node-js",
    "title": "Introduction à OpenLayers",
    "section": "Les bases de Node JS",
    "text": "Les bases de Node JS\nNode JS, c’est ce qu’on appelle un environnement runtime de JavaScript.\nVoilà. On continue ?"
  },
  {
    "objectID": "cours/geonum/04_diapos_intro_openlayers.html#les-bases-de-node-js-1",
    "href": "cours/geonum/04_diapos_intro_openlayers.html#les-bases-de-node-js-1",
    "title": "Introduction à OpenLayers",
    "section": "Les bases de Node JS",
    "text": "Les bases de Node JS\nPour simplifier, voyons comment vous écrivez et exécutez votre code JavaScript jusqu’à maintenant.\n\nOn crée un document index.html dans lequel on met quelque part une balise &lt;script&gt;\nOn écrit le code dans la balise &lt;script&gt;\nOn ouvre index.html dans le navigateur\nComme le JavaScript est dans index.html qui est ouvert dans un navigateur, le navigateur peut exécuter le code JavaScript\n\nCe n’est pas super pratique quand on commence à avoir une application qui grandit (ou “scale”)."
  },
  {
    "objectID": "cours/geonum/04_diapos_intro_openlayers.html#les-bases-de-node-js-2",
    "href": "cours/geonum/04_diapos_intro_openlayers.html#les-bases-de-node-js-2",
    "title": "Introduction à OpenLayers",
    "section": "Les bases de Node JS",
    "text": "Les bases de Node JS\nLa force de Node JS est de permettre d’exécuter du code écrit en JavaScript sans passer par le navigateur. Si par la suite vous devez écrire du code côté serveur, vous pouvez aussi le faire en JavaScript. Et surtout, Node JS permet de télécharger facilement des librairies et déployer encore plus facilement notre application pour la mettre en production en utilisant quelques lignes de commande."
  },
  {
    "objectID": "cours/geonum/04_diapos_intro_openlayers.html#les-bases-de-node-js-3",
    "href": "cours/geonum/04_diapos_intro_openlayers.html#les-bases-de-node-js-3",
    "title": "Introduction à OpenLayers",
    "section": "Les bases de Node JS",
    "text": "Les bases de Node JS\nPour mieux comprendre de quoi on parle, on va commencer par créer une application OpenLayers grâce à NodeJS.\nVous pouvez commencer à suivre le TP !"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#sommaire",
    "href": "cours/geonum/03_diapos_geoserver.html#sommaire",
    "title": "Introduction à GeoServer",
    "section": "Sommaire",
    "text": "Sommaire\n\nIntroduction aux serveurs cartographiques\nLes standards OGC\nPourquoi utiliser un serveur cartographique ?\nExemples de serveurs cartographiques\nGeoServer"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#les-serveurs-cartographiques",
    "href": "cours/geonum/03_diapos_geoserver.html#les-serveurs-cartographiques",
    "title": "Introduction à GeoServer",
    "section": "Les serveurs cartographiques",
    "text": "Les serveurs cartographiques\nLa spécificité du serveur carto\nUn serveur cartographique va servir - sans surprise - de la donnée cartographique sous forme de vecteur ou de raster, tuilée ou non. Il le fait selon des standards OGC bien définis comme le WMS (Web Map Service) et le WFS (Web Feature Service) qui vont définir la structure de la donnée récupérée et les interactions possibles avec cette couche de d‘information.\n\n\n\nSource : hansongis.com/blog/"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc",
    "href": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc",
    "title": "Introduction à GeoServer",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nLes spécifications OGC suivantes définissent ce qu’on appelle des interfaces (ou API) pour requêter des cartes géoréférencées d’un serveur.\nPas de panique - “interface” est un joli mot pour expliquer comment on doit structurer notre requête et ce qu’on recevra en réponse. Par exemple, quand on commande une glace, on sait qu’il faut indiquer pot ou cornet, le nombre de boules et le parfum de chacune. En échange, on obtiendra une glace bien structurée, prête à être dégustée. Si on veut beaucoup simplifier, l’interface fait le lien entre ce que le client aimerait et ce que le cuisinier peut lui donner en encadrant la question posée par le client et les réponses possibles du cuisinier.\nSource : Documentation GeoServer"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc-1",
    "href": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc-1",
    "title": "Introduction à GeoServer",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Map Service (WMS)\n\nLa spécification WMS fournit une interface standard pour requêter une image géoréférencée et sa légende. Le client reçoit une image géoréférencée.\nC’est le plus couramment utilisé car il est plus rapide que le WFS lorsqu’il s’agit de représenter beaucoup d’éléments.\nLa requête GetMap permet de récupérer une carte.\nLa requête GetFeatureInfo permet de récupérer la géométrie et les valeurs d’un pixel.\nLa requête GetLegendGraphic permet de récupérer la légende.\n\nSource : GeoServer WMS reference - Source : QGISserver WMS reference"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc-2",
    "href": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc-2",
    "title": "Introduction à GeoServer",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Feature Service (WFS)\n\nLa spécification WFS fournit une interface standard pour créer, modifier et requêter de l’information géographique au format vecteur. Le client reçoit de la donnée au format GML.\nC’est celui qu’il faut utiliser dans le cas de la manipulation de vecteurs (pour les requêtes attributaires, le WMS suffit).\nLa requête GetFeature retourne une sélection de features avec leur géométrie et la valeur de leurs attributs.\nLa requête Transaction permet d’éditer une feature existante en utilisant “create”, “update” ou “delete”.\n\nSource : GeoServer WFS reference - Source : QGISserver WFS reference"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc-3",
    "href": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc-3",
    "title": "Introduction à GeoServer",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Coverage Service (WCS)\n\nLa spécification WCS fournit une interface pour accéder à de la donnée raster. On peut le voir comme le WMS pour du raster.\nLa requête DescribeCoverage retourne un document XML qui décrit la couverture du pixel sélectionné.\nLa requête GetCoverage retourne un résultat similaire à la requête GetMap du flux WMS mais avec des extensions additionnelles pour supporter la récupération de données raster.\n\nSource : GeoServer WCS reference - Source : QGISserver WCS reference"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc-4",
    "href": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc-4",
    "title": "Introduction à GeoServer",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Map Tile Service (WMTS)\n\nLa spécification WMTS fournit une interface pour requêter des images tuilées. Il s’agit plus ou moins de la même chose que WMS mais qui permet d’utiliser des couches tuilées.\nLa requête GetTile retourne une tuile.\nLa requête GetFeatureInfo permet de récupérer la géométrie et les valeurs d’un pixel (comme dans le cas du flux WMS).\n\nSource : QGISserver WMTS reference"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc-5",
    "href": "cours/geonum/03_diapos_geoserver.html#les-standards-ogc-5",
    "title": "Introduction à GeoServer",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nDans ce TP, nous allons utiliser les flux les plus communs : WMS et WFS."
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#pourquoi-utiliser-un-serveur-carto",
    "href": "cours/geonum/03_diapos_geoserver.html#pourquoi-utiliser-un-serveur-carto",
    "title": "Introduction à GeoServer",
    "section": "Pourquoi utiliser un serveur carto",
    "text": "Pourquoi utiliser un serveur carto\n\nPermet de rester à jour - quand la donnée est mise à jour sur le serveur, toutes les applications clientes (comme une application Leaflet ou OpenLayers (OL)) récupèrent aussi la donnée à jour. C’est pratique quand on a une IDG.\nPermet de servir de la donnée depuis une base de données PostgreSQL. Au lieu de requêter la donnée en SQL, de l’exporter en JSON et de l’importer dans l’application Leaflet/OL, et de refaire ça à chaque fois que la donnée change, on peut simplement utiliser GeoServer pour générer une couche à partir de SQL.\nPermet de gérer et communiquer les métadonnées. GeoServer permet par exemple d’uploader des fiches de métadonnées pour chaque couche qu’il émet.\nLes serveurs cartographiques sont au cœur des IDG, il faut donc savoir les utiliser. Par exemple, geOrchestra propose GeoServer comme module de serveur cartographique."
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#pourquoi-utiliser-un-serveur-carto-1",
    "href": "cours/geonum/03_diapos_geoserver.html#pourquoi-utiliser-un-serveur-carto-1",
    "title": "Introduction à GeoServer",
    "section": "Pourquoi utiliser un serveur carto",
    "text": "Pourquoi utiliser un serveur carto\nEn résumé\nOn peut se passer d’un serveur cartographique quand on a “juste” quelques features en JSON à afficher. Dès qu’on commence à avoir des couches souvent mises à jour, besoin d’accéder aux métadonnées, de plus nombreuses couches, d’importer des couches stylisées dans QGIS, de créer des couches à partir d’une base de données PostgreSQL… dans ce cas l’utilisation d’un serveur cartographique nous facilite grandement la vie.\n\nExemple 1 : data.grandlyon.com qui permet de lire directement ses couches de données en passant par son API.\nExemple 2 : les fonds de carte OSM (WMS)"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#exemples-de-serveurs-cartographiques",
    "href": "cours/geonum/03_diapos_geoserver.html#exemples-de-serveurs-cartographiques",
    "title": "Introduction à GeoServer",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nMapServer\nLien vers MapServer\nPlateforme Open Source pour la publication de donnée géospatiale. (J’ai peu de choses à dire dessus, je ne l’ai jamais utilisée).\nMapServer continue à exister dans les organisations qui s’en servent déjà mais ce n’est plus forcément la solution la plus populaire lorsqu’il faut partir de zéro."
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#exemples-de-serveurs-cartographiques-1",
    "href": "cours/geonum/03_diapos_geoserver.html#exemples-de-serveurs-cartographiques-1",
    "title": "Introduction à GeoServer",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nGeoServer\nLien vers GeoServer\nServeur Java gratuit et Open Source qui permet aux utilisateurs de visualiser et éditer de la donnée géospatiale. La librairie OpenLayers est intégrée à GeoServer pour générer rapidement des cartes. Les capacités du serveur peuvent être étendues via l’installation d’extensions diverses.\nGeoServer est le plus simple à déployer. Il peut aussi directement se connecter avec des bases de données comme PostgreSQL - l’équipe le décrit comme étant “designé pour l’interopérabilité”. GeoServer est assez complexe à configurer mais le plus adaptable aux besoins utilisateur, notamment grâce à la gestion fine des droits utilisateurs et l’utilisation de plugins pour enrichir les possibilités."
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#exemples-de-serveurs-cartographiques-2",
    "href": "cours/geonum/03_diapos_geoserver.html#exemples-de-serveurs-cartographiques-2",
    "title": "Introduction à GeoServer",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nQGIS Server\nLien vers QGIS Server Guide Manual\nAPI gratuite et Open Source qui permet aussi d’implanter des éléments cartographiques avancés pour créer des cartes thématiques. Elle fonctionne avec un serveur web (Apache ou Nginx).\nQGIS Server est plus difficile à mettre en place (il existe des application tierces pour simplifier son utilisation comme LizMap) mais est le plus compatible avec la publication de projets via QGIS. C’est la meilleure solution pour publier rapidement un projet QGIS."
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#geoserver---introduction",
    "href": "cours/geonum/03_diapos_geoserver.html#geoserver---introduction",
    "title": "Introduction à GeoServer",
    "section": "GeoServer - Introduction",
    "text": "GeoServer - Introduction\n\nGeoServer est un serveur Open Source écrit en Java qui permet aux utilisateurs de partager et éditer de la donnée géospatiale.\nIl a été designé pour maximisé son interopérabilité, permettant de publier de la donnée des sources de données les plus courantes en utilisant des standards ouverts.\nGeoServer est un projet développé, testé et soutenu par sa communauté - comme dans le cas de QGIS.\nGeoServer est une référence dans l’implementation des standards WFS, WMS et WCS de l’OGC.\n\n\nSource : hansongis.com/blog/Source : GeoServer Overview"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#geoserver---introduction-1",
    "href": "cours/geonum/03_diapos_geoserver.html#geoserver---introduction-1",
    "title": "Introduction à GeoServer",
    "section": "GeoServer - Introduction",
    "text": "GeoServer - Introduction\n\nLe projet a débuté en 2001 avec le Open Planning Project (TOPP), un organisme à but non lucratif basé à New York et qui a créé une suite d’outils pour promouvoir la transparence de la donnée. Leur premier outil, GeoServer, avait pour objectif de permettre aux citoyens d’accéder aux documents de planification urbaine du gouvernement en partageant la donnée spatiale.\nAvec le temps, le projet GeoTools a été ajouté avec la possibilité de supporter les Shapefiles, les bases de données Oracle, etc.\nD’autres projets ouverts ont continué à enrichir GeoServer et ses fonctionnalités comme le développement de PostGIS (par Refractions Reseach) qui a permis de connecter GeoServer à une base de données gratuite (PostgreSQL).\nLicence : la GNU General Public License, mais contient aussi des logiciels Apache donc dépend de la Apache Software Foundation ainsi que le la Eclipse Public License, qui sont toutes très permissives.\n\nSource : GeoServer Overview"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#geoserver---avantages-et-inconvénients",
    "href": "cours/geonum/03_diapos_geoserver.html#geoserver---avantages-et-inconvénients",
    "title": "Introduction à GeoServer",
    "section": "GeoServer - avantages et inconvénients",
    "text": "GeoServer - avantages et inconvénients\nAvantages\n\nSolution très bien documentée\nNombreux plugins qui sont bien maintenus\nPeut lire de multiple sources de données (shapefile, geopackage, connexion à une base PostgreSQL)\nOutil activement maintenu et communauté réactive\nPas difficile à déployer (comparé à d’autres)\nDocumentation riche\nUn outil bien solide sur le long terme"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#geoserver---avantages-et-inconvénients-1",
    "href": "cours/geonum/03_diapos_geoserver.html#geoserver---avantages-et-inconvénients-1",
    "title": "Introduction à GeoServer",
    "section": "GeoServer - avantages et inconvénients",
    "text": "GeoServer - avantages et inconvénients\nInconvénients\n\nDifficile à prendre en main au début (gestion des droits, différencier les couches et les dépôts, etc.)\nL’interface est un peu vieille et pas super intuitive\nLa grande majorité des ressources est uniquement disponible en anglais (mais ça ne devrait pas vous faire trop peur !)\nVous allez parfois vous arracher les cheveux sur des fichiers de style complexes"
  },
  {
    "objectID": "cours/geonum/03_diapos_geoserver.html#geoserver---comment-utiliser-la-documentation",
    "href": "cours/geonum/03_diapos_geoserver.html#geoserver---comment-utiliser-la-documentation",
    "title": "Introduction à GeoServer",
    "section": "GeoServer - Comment utiliser la documentation",
    "text": "GeoServer - Comment utiliser la documentation\nhttps://geoserver.org/"
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#sommaire",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#sommaire",
    "title": "Architecture client-serveur",
    "section": "Sommaire",
    "text": "Sommaire\n\nRévision du fonctionnement d’une architecture client-serveur\nIntroduction à Docker pour créer une architecture client-serveur"
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#larchitecture-client-serveur",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#larchitecture-client-serveur",
    "title": "Architecture client-serveur",
    "section": "L’architecture client-serveur",
    "text": "L’architecture client-serveur\n\nRappels sur ce qu’est un serveur\nLe serveur matériel (hardware) : Une ou plusieurs machines physiques reliées entre elles et et sur lesquelles fonctionnent un ou plusieurs logiciels.\nSource : Ionos\nDans ce TP, notre serveur physique sera notre ordinateur. En pratique, cela ressemble plus souvent à ça (serveurs WikiMedia foundation) :"
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#larchitecture-client-serveur-1",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#larchitecture-client-serveur-1",
    "title": "Architecture client-serveur",
    "section": "L’architecture client-serveur",
    "text": "L’architecture client-serveur\nRappels sur ce qu’est un serveur\nLe serveur (software) : Un programme effectuant des interactions en réseau avec d’autres programmes appelés logiciels clients. Le service apporté dépend du logiciel serveur.\nSource : Ionos\nUn logiciel serveur peut-être un serveur Web (Apache, Nginx), un serveur email, un serveur de bases de données (PostgreSQL), un serveur cartographique (GeoServer), etc. Un logiciel client est par exemple un navigateur internet pour afficher un site web (Firefox, Google Chrome), un client mail (Thunderbird), et plus généralement une machine cliente."
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#larchitecture-client-serveur-2",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#larchitecture-client-serveur-2",
    "title": "Architecture client-serveur",
    "section": "L’architecture client-serveur",
    "text": "L’architecture client-serveur\nComment le serveur communique-t-il avec les clients ?\nDans le cas des serveurs web et cartographiques, le client (par exemple notre Firefox) va envoyer des requêtes au serveur (par exemple GeoServer). Le serveur va lire la requête et renvoyer une réponse. Cette réponse peut-être une page web, un JSON, un flux cartographique, mais aussi un message d’erreur comme le fameux 404 not found.\n\nSource : codegym.cc"
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#larchitecture-client-serveur-3",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#larchitecture-client-serveur-3",
    "title": "Architecture client-serveur",
    "section": "L’architecture client-serveur",
    "text": "L’architecture client-serveur\nComment le serveur communique-t-il avec la source de donnée ?\nEn réalité, la plupart des applications fonctionnent de la manière suivante : le client envoie des requêtes au serveur. Le serveur va communiquer avec la base de données, traiter le résultat et renvoyer une réponse au client.\nExemple :\n- Client = mon application Firefox\n- Serveur = les serveurs de Google\n- Database = la base de données de Google\n- Requête = cherche les sites qui correspondent à la requête “apprendre le JavaScript”\n- Réponse = liste des sites qui correspondent à la requête “apprendre le JavaScript”\n\nSource : codegym.cc"
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#nos-besoins",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#nos-besoins",
    "title": "Architecture client-serveur",
    "section": "Nos besoins",
    "text": "Nos besoins\n\nOn souhaite servir des couches de données géographique avec GeoServer et pouvoir permettre à des applications clientes de les lire.\n\nUn client pour récupérer et afficher nos couches de données (Firefox, QGIS, …)\nUn serveur web cartographique (GeoServer)\n\n\n\nGénéralement, quand on développe une application, on a tout sur notre ordinateur (les serveurs et les clients) et on attend que l’application soit prête pour l’héberger sur un serveur dédié. On a deux possibilités : utiliser des machines virtuelles (VM) ou Docker."
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose",
    "title": "Architecture client-serveur",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\n\nLes Machines Virtuelles (VM)\n\nIl faut voir une machine virtuelle comme un ordinateur qui serait dématérialisé (sans composants matériels). Elle possède un processeur, de la mémoire, des espaces de stockage pour la donnée, elle peut se connecter à internet…\nOutils de création de machines virtuelles : VirtualBox, VMWare…\n\nExemple : en téléchargeant VirtualBox, je peux créer une machine virtuelle Linux sur mon ordinateur Windows.\n\n\n\nSource : microsoft.com"
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose-1",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose-1",
    "title": "Architecture client-serveur",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nLes Machines Virtuelles (VM)\nSi je voulais mettre en place mon serveur sur une machine virtuelle, je devrais :\n\ncréer la machine (avec des caractéristiques suffisantes pour faire tourner l’application)\ntélécharger, installer et configurer GeoServer\néventuellement télécharger, installer et configurer une base Postgresql avec PostGIS et la connecter au serveur\nrefaire la même chose pour tout autre serveur que je voudrais installer (au hasard, un serveur pour une application OpenLayers)\netc."
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose-2",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose-2",
    "title": "Architecture client-serveur",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nLes Machines Virtuelles (VM)\nMultiplier les machines virtuelles sur l’hôte est très demandeur.\n\nressources divisées entre l’hôte et les machines\nautant d’OS à faire tourner que de machines\nchaque machine = plusieurs Go d’espace\n\nC’est aussi difficile à maintenir - il faut garder tous les OS à jour, etc.\nMais nous, on aime la simplicité et éviter de consommer plein de mémoire “pour rien”."
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose-3",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose-3",
    "title": "Architecture client-serveur",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nHeureusement…\n…il existe des outils de containerisation comme Docker."
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose-4",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose-4",
    "title": "Architecture client-serveur",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nDocker\n\nDocker permet de faire tourner ce qu’on appelle des containers.\nLes containers sont réduits au minimum nécessaire pour faire tourner des services (un serveur, une base de données, …).\nAutre outil de containerisation : Podman\n\n\nSource : microsoft.com"
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose-5",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#vms-docker-et-docker-compose-5",
    "title": "Architecture client-serveur",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nDocker Compose\n\nSorti en 2013, Docker Compose permet de gérer des applications multi-containers.\nPour cela, on va rédiger un fichier de type docker-compose.yml qui va agir comme une “recette” pour permettre à Docker de créer et connecter l’ensemble des containers dont on a besoin."
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#déploiement",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#déploiement",
    "title": "Architecture client-serveur",
    "section": "Déploiement",
    "text": "Déploiement\nRecette pour un bon GeoServer\nRécupérez le contenu du dépôt GitHub du cours (voir notes du TP)."
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#notre-docker-compose",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#notre-docker-compose",
    "title": "Architecture client-serveur",
    "section": "Notre Docker Compose",
    "text": "Notre Docker Compose\nExplications sur le contenu :\nservices:\n\n  geoserver:\n    container_name: geonum_geoserver\n    image: docker.osgeo.org/geoserver:2.26.0\n    environment:\n      - RUN_UNPRIVILEGED=true\n      - CHANGE_OWNERSHIP_ON_FOLDERS=\"/opt /opt/geoserver_data/ /mnt/geoserver_geodata\"\n      - CORS_ENABLED=true\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - $PWD/geoserver/opt:/opt/geoserver_data\n  \n  web:\n    container_name: geonum_web\n    image: caddy:latest\n    ports:\n      - \"80:80\"\n    volumes:\n      - $PWD/Caddyfile:/etc/caddy/Caddyfile\n      - $PWD/app/dist/:/srv"
  },
  {
    "objectID": "cours/geonum/02_diapos_architecture_client_serveur.html#à-vous",
    "href": "cours/geonum/02_diapos_architecture_client_serveur.html#à-vous",
    "title": "Architecture client-serveur",
    "section": "À vous !",
    "text": "À vous !\nPoursuivez le TP jusqu’à réussir à vous connecter à votre GeoServer."
  },
  {
    "objectID": "cours/geonum/01_diapos_introduction.html#intervenante",
    "href": "cours/geonum/01_diapos_introduction.html#intervenante",
    "title": "Formation WebCarto GeoNum 2025-2026",
    "section": "Intervenante",
    "text": "Intervenante\nMarie Gradeler\n⛰️ Licence de Géologie\n🤠 Master d’Archéologie du Paysage (SIG, télédec, stats)\n🤷 Pas de sous en archéo donc galère de trouver du travail\n🗺️ Master GeoNum (arrivée en M2)\n💻 Stage AgroParisTech dans le cadre du Master : développement d’une appli de cartographie web\n💻 Contrat de 6 mois au CIRAD pour terminer la production de l’appli carto du stage\n💻 Depuis, je travaille comme consultante IFAD sur le project Land Matrix (création d’indicateurs, stats avec R, beaucoup de dataviz et développement Web)"
  },
  {
    "objectID": "cours/geonum/01_diapos_introduction.html#les-cours",
    "href": "cours/geonum/01_diapos_introduction.html#les-cours",
    "title": "Formation WebCarto GeoNum 2025-2026",
    "section": "Les cours",
    "text": "Les cours\n\n1er Décembre, 9h-12h — Architecture Web et Serveurs Cartographiques\n2 Décembre, 9h-12h — Introduction à OpenLayers\n4 Décembre, 9h-12h — Ajouter des couches à ma carte\n8 Décembre, 9h-12h — Interactions entre carte et interface\n11 Décembre, 9h-12h — Enrichir la carte en fonctionnalités, partie 1\n12 Décembre, 9h-12h — Enrichir la carte en fonctionnalités, partie 2\n\nOn va travailler sur les serveurs cartographiques, notamment GeoServer, mais aussi sur la librairie de cartographie OpenLayers. Cela va nous demander de savoir écrire du code en JavaScript, d’être capable d’exécuter une ou deux lignes de commandes en Bash et de comprendre l’architecture client-serveur du web.\nJe vous recommande de revoir les cours de Leaflet (entre autres) qui sont complémentaires de celui-ci. Si vous connaissez Leaflet, vous connaissez presque déjà OpenLayers."
  },
  {
    "objectID": "cours/geonum/01_diapos_introduction.html#les-ressources",
    "href": "cours/geonum/01_diapos_introduction.html#les-ressources",
    "title": "Formation WebCarto GeoNum 2025-2026",
    "section": "Les ressources",
    "text": "Les ressources\n💻 Mon site internet : https://gradelerm.github.io\nIl est en cours de construction mais suffit déjà à héberger les ressources pour le cours. Vous y trouverez tout le reste !\nMoi : marie.gradeler@gmail.com\nN’hésitez pas à me contacter. Mes cours sont condensés sur 2 semaines. Si quelque chose ne va pas, je dois le savoir dès la première séance. Je serai aussi disponible pour vous accompagner durant les projets GeoNum si vous avez besoin d’aide sur l’une des notions abordées en cours."
  },
  {
    "objectID": "cours/geonum/01_diapos_introduction.html#comment-ça-se-passe",
    "href": "cours/geonum/01_diapos_introduction.html#comment-ça-se-passe",
    "title": "Formation WebCarto GeoNum 2025-2026",
    "section": "Comment ça se passe",
    "text": "Comment ça se passe\nOrganisation des cours\n\nPas mal de mise en pratique\nOn m’appelle si on est perdu, je suis là pour vous aider (ne me laissez pas faire mon cours dans le vide parce que vous avez abandonné tout espoir de raccrocher les wagons, ça ne sert à rien)\nSi on doit ralentir parce que j’ai trop prévu de choses techniques, on ralentit et puis c’est tout, j’adapterai l’évaluation à ce qu’on a eu le temps de voir en cours.\nJe sais que c’est difficile mais on lâche son téléphone pendant le cours (ou cet onglet mal planqué) et on se concentre sur le cours."
  },
  {
    "objectID": "cours/geonum/01_diapos_introduction.html#évaluation",
    "href": "cours/geonum/01_diapos_introduction.html#évaluation",
    "title": "Formation WebCarto GeoNum 2025-2026",
    "section": "Évaluation",
    "text": "Évaluation\nProjet à rendre basé sur une petite architecture web que je vous fournirai (et qui pourrait éventuellement servir de base pour une archi de projet GeoNum, je dis ça je dis rien…). Dans les grandes lignes, ce qui vous sera demandé :\n🛠️ Publication de couches sur un GeoServer\n🗺️ Lecture des flux WMS sur une petite appli OpenLayers OU Leaflet\n💻 Déploiement (rudimentaire) de votre serveur GeoServer + application OpenLayers OU Leaflet en s’appuyant sur l’architecture web fournie\nJe vais recalibrer l’évaluation suivant la vitesse à laquelle on avance et le niveau moyen de la promo en dev. Du coup, vous aurez les consignes pendant le dernier cours."
  },
  {
    "objectID": "cours/geonum/01_diapos_introduction.html#cest-parti",
    "href": "cours/geonum/01_diapos_introduction.html#cest-parti",
    "title": "Formation WebCarto GeoNum 2025-2026",
    "section": "C’est parti !",
    "text": "C’est parti !\nPrêts à encore entendre parler de serveurs, clients, requêtes, variables et fonctions ?\n\nCourage. Promis, ça va nous permettre de faire des trucs cools qui seront très utiles pour les projets GeoNum et si vous faites de la webcarto ou des IDGs plus tard."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Dummy blog post TWO\n\n\n\n\n\nSome dummy blog post for pages config\n\n\n\n\n1 min\n\n\n\n\n\n\nFigures layout\n\n\n\n\n\n\nR\n\ntmap\n\n\n\nLayout des figures dans les articles avec Quarto.\n\n\n\n\n\nMar 10, 2025\n\n\nMarie Gradeler\n\n1 min\n\n\n\n\n\n\nDummy blog post\n\n\n\n\n\n\nR\n\ndataviz\n\n\n\nSome dummy blog post for pages config\n\n\n\n\n\nOct 10, 2024\n\n\nMarie Gradeler\n\n1 min\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "cours/geonum/01_cours_introduction.html",
    "href": "cours/geonum/01_cours_introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Cours : Introduction",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "cours/geonum/01_cours_introduction.html#cours-en-2025-2026",
    "href": "cours/geonum/01_cours_introduction.html#cours-en-2025-2026",
    "title": "Introduction",
    "section": "Cours en 2025-2026",
    "text": "Cours en 2025-2026\n\n1er Décembre, 9h-12h — Architecture Web et Serveurs Cartographiques\n2 Décembre, 9h-12h — Introduction à OpenLayers\n4 Décembre, 9h-12h — Ajouter des couches à ma carte\n8 Décembre, 9h-12h — Interactions entre carte et interface\n11 Décembre, 9h-12h — Enrichir la carte en fonctionnalités, partie 1\n12 Décembre, 9h-12h — Enrichir la carte en fonctionnalités, partie 2",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "cours/geonum/02_cours_architecture_client_serveur.html",
    "href": "cours/geonum/02_cours_architecture_client_serveur.html",
    "title": "Architecture web",
    "section": "",
    "text": "Comprendre comment fonctionne une architecture web basique\nDéployer une architecture web de développement en utilisant Docker\n\nDurée : 1h",
    "crumbs": [
      "Architecture web"
    ]
  },
  {
    "objectID": "cours/geonum/02_cours_architecture_client_serveur.html#objectifs-de-la-session",
    "href": "cours/geonum/02_cours_architecture_client_serveur.html#objectifs-de-la-session",
    "title": "Architecture web",
    "section": "",
    "text": "Comprendre comment fonctionne une architecture web basique\nDéployer une architecture web de développement en utilisant Docker\n\nDurée : 1h",
    "crumbs": [
      "Architecture web"
    ]
  },
  {
    "objectID": "cours/geonum/02_cours_architecture_client_serveur.html#supports",
    "href": "cours/geonum/02_cours_architecture_client_serveur.html#supports",
    "title": "Architecture web",
    "section": "Supports",
    "text": "Supports\nCours : Architecture client-server",
    "crumbs": [
      "Architecture web"
    ]
  },
  {
    "objectID": "cours/geonum/02_cours_architecture_client_serveur.html#tp-déploiement-de-notre-geoserver",
    "href": "cours/geonum/02_cours_architecture_client_serveur.html#tp-déploiement-de-notre-geoserver",
    "title": "Architecture web",
    "section": "TP – Déploiement de notre GeoServer",
    "text": "TP – Déploiement de notre GeoServer\n\n\n\n\n\n\nImportant\n\n\n\nCe TP suppose que Git, NodeJS et Docker sont installés sur la machine. Il a été écrit pour une machine Linux, certains chemins et lignes de commande peuvent donc être différents sur une machine Windows ou Mac.\n\n\n\nAvant de commencer\nAvant de commencer, on doit vérifier que Git, NodeJS et Docker sont bien installés et à jour.\n\nGit\nOuvrez le terminal de votre choix (pour les utilisateurs Windows, je recommande Powershell) et tapez la commande suivante :\ngit version\nVous devriez obtenir la réponse suivante : git version 2.43.0\nSi la version est plus ancienne, il faut la mettre à jour. Si vous avez un message d’erreur, git n’est pas installé. Dans les deux cas, rendez-vous sur la page d’installation de git pour télécharger et installer la nouvelle version : https://git-scm.com/install/windows\nVous pouvez vérifier que git est installé et à jour en re-tapant la commande git version.\nNote : il faut parfois redémarrer l’ordinateur pour qu’il reconnaisse bien l’installation de Git.\n\n\nNodeJS\nDans le terminal, tapez la commande suivante :\nnode -v\nVous devriez obtenir la réponse suivante : v24.11.1\nSi Node n’est pas installé… on peut essayer mais on a peu de chances d’avoir les droits sur les ordis de la fac. Voilà quand même le lien officiel : https://nodejs.org/en/download\nSi Node est installé mais la version trop ancienne, essayez la commande suivante :\nnvm install 24\nPuis vérifier la mise à jour avec la commande suivante :\nnode -v\n\n\nDocker\nPour vérifier que Docker est installé, vous avez plusieurs options : cherchez le logiciel “Docker Desktop” sur votre ordinateur ou bien tapez la commande suivante :\ndocker run hello-world\nNote : si vous utilisez votre propre machine Linux, essayez sudo. Quoi qu’il en soit, il vaut mieux éviter d’utiliser Docker en tant que super utilisateur, référez-vous aux instructions post-installation officielles : https://docs.docker.com/engine/install/linux-postinstall\nVous devriez obtenir dans votre terminal le message suivant :\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\nSi c’est le cas, docker est installé est fonctionne. Sinon… si vous êtes sur les ordinateurs de la fac, on est fichus. On n’a pas les droits pour l’installer. Donc… on croise les doigts 🤞\n\n\n\nRécupération du code sur GitHub\nRendez-vous sur le GitHub du projet pour récupérer le code : https://github.com/GradelerM/geonum_docker\nCréez un dossier dans lequel vous voulez travailler. Il nous servira pour le cours de GeoServer et le cours d’OpenLayers. Vous pouvez l’appeler comme vous voulez, mais évitez les espaces et autres caractères difficiles à prendre en charge quand on doit définir un chemin d’accès.\nEnsuite, ouvrez ce dossier dans votre terminal (le clic droit devrait vous donner l’option sous Linux comme Windows). Vérfiez que le chemin pointe bien vers votre nom de dossier. Par exemple, si j’ai créé un dossier qui s’appelle “Cours_Geoserver_Openlayers” dans Documents, le chemin doit ressembler à ça : ~/Documents/Cours_Geoserver_Openlayers\nQuand c’est bon, on va utiliser Git pour cloner mon dépôt. En langage courant, ça veut dire qu’on utilise Git pour créer une copie de mon code sur votre ordinateur.\ngit clone https://github.com/GradelerM/geonum_docker.git\nVérifiez votre dossier. Vous devriez avec un nouveau répertoire geonum_docker. Ouvrez ce répertoire dans VSCode pour qu’on puisse regarder le code ensemble.\n\n\n\n\n\n\nPoint diapos sur le contenu du répertoire\n\n\n\n\n\n\n\n\nDéploiement de la stack\nMaintenant qu’on a compris le contenu du fichier docker_compose.yml, on peut déployer notre GeoServer et commencer à l’utiliser. Pour ça, ouvrez un terminal dans VSCode et vérifiez que le chemin correspond bien au répertoire qu’on vient de récupérer. Si on reprend l’exemple, précédent, au lieu d’avoir ~/Documents/Cours_Geoserver_Openlayers vous devriez maintenant avoir ~/Documents/Cours_Geoserver_Openlayers/geonum_docker . C’est ce qu’on va appeler à partir de maintenant la racine de notre projet.\nUne fois que votre terminal est ouvert à la racine de votre projet, taper la commande suivante :\ndocker compose up -d\nCette commande demande à Docker de lire notre recette de docker_compose.yml pour créer notre GeoServer (et une autre application web qu’on utilisera plus tard, mais pas aujourd’hui).\nSi vous avez Docker Desktop d’installé, vous pouvez l’ouvrir pour vérifier qu’il se passe bien quelque chose.\nSi ça prend du temps la première fois, c’est normal. Docker doit d’abord aller récupérer les “recettes” (images) en ligne pour GeoServer et Caddy (qu’on présentera pendant les cours OpenLayers). Normalement, les prochaines fois, ça ira vite.\nQuand le container est prêt, rendez-vous sur http://localhost:8080/geoserver/web/?0. Si vous voyez l’interface de GeoServer, hourra ! On peut passer au prochain cours.\nSinon, appelez-moi, on va débugger tout ça ensemble.",
    "crumbs": [
      "Architecture web"
    ]
  },
  {
    "objectID": "cours/geonum/02_cours_architecture_client_serveur.html#mémo",
    "href": "cours/geonum/02_cours_architecture_client_serveur.html#mémo",
    "title": "Architecture web",
    "section": "Mémo",
    "text": "Mémo\nDans cette section, j’ajoute quelques éléments d’aide à la compréhension du cours comme des explications supplémentaires ou des pistes pour aller plus loin.\n\n\n\n\n\n\nContainers, images, services…\n\n\n\n\n\n\n\n\n\n\nPas de panique ! On n’a pas besoin de savoir exactement comment fonctionne Docker pour ce TP. Si on veut simplifier :\n\nDocker permet de faire tourner des services dans des containers créés à partir d’images.\nUne image est une recette à suivre pour créer mon container. Elle demande à Docker de créer un container basé sur Debian, d’y installer GeoServer ou bien une base PostgreSQL avec l’extension postGIS, etc.\nUn container est le produit d’une image. C’est un peu le plat cuisiné à partir de la recette. C’est à l’intérieur du container que tourne mon service comme ma base de données ou mon serveur web. On peut connecter plusieurs containers entre eux, pratique si on veut un site web et une base de données qui fonctionnent ensemble !\nUn service est généralement une base de données (ex. PostgreSQL), un serveur de site web (ex. Apache), un serveur cartographique (ex. GeoServer), etc. Comme les bonnes pratiques demandent d’avoir un seul service par container, on va parler du “container GeoServer” pour dire “le container qui contient mon service GeoServer”, ça va plus vite.\n\nSi ce n’est encore pas clair et que ça vous gêne pour la compréhension de la suite du TP, hop, on lève la main et on demande des explications, je suis là pour ça ! Et si vous voulez aller plus loin, rendez-vous sur la documentation officelle de Docker.",
    "crumbs": [
      "Architecture web"
    ]
  },
  {
    "objectID": "cours/geonum/03_cours_geoserver.html",
    "href": "cours/geonum/03_cours_geoserver.html",
    "title": "GeoServer",
    "section": "",
    "text": "Apprendre ce qu’est un serveur cartographique\nConnaître les standards OGC WFS, WMS, WMTS…\nSavoir importer, styliser et visualiser une couche de données dans GeoServer\n\nDurée : 2h",
    "crumbs": [
      "GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/03_cours_geoserver.html#objectifs-de-la-session",
    "href": "cours/geonum/03_cours_geoserver.html#objectifs-de-la-session",
    "title": "GeoServer",
    "section": "",
    "text": "Apprendre ce qu’est un serveur cartographique\nConnaître les standards OGC WFS, WMS, WMTS…\nSavoir importer, styliser et visualiser une couche de données dans GeoServer\n\nDurée : 2h",
    "crumbs": [
      "GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/03_cours_geoserver.html#supports",
    "href": "cours/geonum/03_cours_geoserver.html#supports",
    "title": "GeoServer",
    "section": "Supports",
    "text": "Supports\nCours : Introduction à GeoServer",
    "crumbs": [
      "GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/03_cours_geoserver.html#tp---prise-en-main-de-geoserver",
    "href": "cours/geonum/03_cours_geoserver.html#tp---prise-en-main-de-geoserver",
    "title": "GeoServer",
    "section": "️TP - Prise en main de GeoServer",
    "text": "️TP - Prise en main de GeoServer\n\nDéploiement de GeoServer à l’aide de Docker\nDocumentation GeoServer - Dépôt de l’image Docker\n\n\n\n\n\n\nImportant\n\n\n\nCe TP suppose que Docker est installé sur la machine. Il a été écrit pour une machine Linux, certains chemins et lignes de commande peuvent donc être différents sur une machine Windows ou Mac.\n\n\nSi tout s’est bien passé lors du TP précédent, vous devriez avoir une instance de GeoServer qui tourne à l’adresse suivante : http://localhost:8080/geoserver/web/?0\n\n\n\n\n\n\nJe ne trouve pas mon GeoServer\n\n\n\n\n\nPour relancer votre instance, vous pouvez :\n\nouvrir un terminal à la racine du dossier geonum_docker et taper la commande docker compose up -d\nouvrir l’application Docker Desktop, trouver la stack de containers geonum_docker et geonum_web et cliquer sur “Start”\n\nSi jamais votre instance tourne mais que vous ne trouvez pas votre GeoServer, il est peut-être à une adresse différente. Vérifiez le contenu de la ligne “ports” du fichier docker-compose.yml.\nports:\n  - \"8080:8080\"\nLe port de droite indique à quelle adresse est servi votre GeoServer. Le port de sortie peut être différent :\nports:\n  - \"8080:8081\"\nDans ce cas, vous trouverez votre GeoServer à l’adresse http://localhost:8081/geoserver/web/?0. Il peut être nécessaire de changer de port si vous avez déjà une application qui utilise le port 8080 sur votre machine.\n\n\n\nUne fois dans l’interface :\n\nEn haut à droite de l’écran, si ce n’est pas déjà le cas, sélectionnez le langage “fr” pour passer l’interface en français.\nConnectez vous avec l’identifiant admin et le mot de passe geoserver. Ce sont les identifiants par défaut quand vous créez une instance de GeoServer. Si vous mettiez votre application en ligne, il faudrait évidemment changer ça.\n\n\n\nSe familiariser avec notre jeu de données\nEnsuite, téléchargez le jeu de données land_matrix_mines. C’est celui qu’on utilisera pendant mes cours. Prenez quelques minutes pour vous familiariser avec dans QGIS avant de passer à la suite. Vous devriez pouvoir répondre aux questions suivantes :\n\nQuel est le format du jeu de données ?\nQuelles sont les couches présentes et à quoi correspondent-elles ?\nQuelle est leur géométrie (points, polygones…) ?\nQuels sont les attributs de chacune des couches ? Comment est-ce que je pourrais m’en servir pour styliser ma couche et créer une carte intéressante ?\n\n\n\nCréer un espace de travail et importer des données\nMaintenant que vous voyez mieux sur quelle donnée on va travailler, il est temps de l’importer dans GeoServer. Pour ça, on va créer un dossier geoserver/opt/data et y glisser le jeu de données.\n\nOuvrez votre gestionnaire de fichiers à la racine du projet (répertoire geonum_docker)\nDans geoserver &gt; opt, créez un nouveau répertoire data. Note : vous pouvez l’appeler comme vous voulez, on utilise juste une convention ici.\nVérifiez bien que data se trouve dans le même répertoire que styles, workspaces, etc.\nDéplacez le jeu de données land_matrix_mines dans le dossier data\n\n\n\n\n\n\n\nJe ne peux pas créer de nouveau dossier / déplacer mon fichier !\n\n\n\n\n\nSi vous ne pouvez pas créer de nouveau dossier, c’est que vous ne disposez pas des permissions suffisantes. Dans mon cas (sur Ubuntu), tous les dossiers appartenaient à l’utilisateur et au groupe root. Il faut utiliser la commande chown :\nsudo chown -R &lt;user&gt;:&lt;group&gt; /chemin/vers/mon/dossier\nPour changer les droits de mon dossier `/home/marie/Documents/GeoServer` j’ai donc tapé :\nsudo chown -R marie:marie /home/marie/Documents/GeoServer\nSi ça ne fonctionne pas, ne restez pas bloqués et appelez-moi, on règle ça ensemble.\n\n\n\nEnsuite, dans l’interface de GeoServer, nous devons créer un nouvel espace de travail. Ils servent à compartimenter la donnée. Dans un cas d’utilisation réelle, on aurait par exemple un espace de travail par projet. Il est possible de définir des droits utilisateurs spécifiques aux espaces de travail (par exemple, l’utilisateur “John” peut ajouter de la donnée dans l’espace “espaces_verts” mais pas dans “bassins_versants”).\n\nAllez dans “Espaces de travail” (à gauche)\nCliquez sur “Ajouter un nouvel espace de travail”\nDonnez lui comme nom et comme URI land_matrix\nVous devriez revenir à la liste de vos espaces de travail.\n\nOn doit ensuite définir notre Geopackage comme étant un nouvel entrepôt de données. Cela permet d’indiquer à GeoServer qu’il s’agit d’une source de données. C’est assez similaires aux connexions dans QGIS.\n\nAllez dans “Entrepôts” (à gauche)\nCliquez sur “Ajouter un nouvel entrepôt”\nChoisissez “GeoPackage”\nDonnez lui pour nom land_matrix_mines. Vous pouvez aussi lui donner une description.\nDans “Paramètres de connexion”, près de “database*”, cliquez sur “Parcourir…”. Vous devriez pouvoir accéder à data/ et y trouver land_matrix_mines.gpkg. Cliquez dessus.\nAllez tout en bas de la page et cliquez sur “Sauvegarder”.\n\nMaintenant, vous devriez voir la liste des couches présentes dans le GeoPackage.\nRetournez sur la page “Entrepôts”, vous devriez voir votre entrepôt “land_matrix_mines” associé à l’espace de travail “land_matrix”. On avance ! Maintenant, on veut publier et lire des couches.\n\nAllez dans “Couches” (à gauche)\nCliquez sur “Ajouter une nouvelle couche”.\nSélectionnez “land_matrix:land_matrix_mines”. Vous devriez voir apparaître une liste de couches.\nCliquez sur “Publier” à droite de la couche “deals”.\n\nL’onglet de publication de couche permet de configurer la couche et d’y ajouter de la métadonnée. Dans ce TP, on se concentrera sur les informations “cruciales” pour définir une couche, mais vous pourrez toujours allez plus loin en utilisant la documentation GeoServer sur les couches.\nLes trois choses à faire absolument à chaque fois dans l’onglet données sont :\n\nRenseigner les informations dans “Informations de base sur les donneés” comme le nom de la couche et un résumé. N’oubliez pas de laisser “Activé” et “Publié” cochés pour rendre la couche accessible depuis l’extérieur.\nVérifier le “Système de Référence de Coordonnées (SRC)” qui doit être pré-rempli en EPSG:4326 dans notre cas. Il correspond à la projection WGS84 utilisée dans la grande majorité des cas en cartographie web.\nDéfinir les “Emprises” qui se calculent automatiquement sur GeoServer en cliquant sur “Calculer depuis les limites du SRS” et “Calculées sur les emprises natives”.\n\nCliquez ensuite sur “Appliquer” pour sauvegarder vos changements et scrollez en haut de la page pour accéder à l’onglet “Publication”.\n\nDans “Paramètres de couche”, cochez Interrogeable et vérifiez que le style par défaut est bien “point”.\n\nCliquez sur “Sauvegarder”. La couche devrait maintenant apparaître au sommet du tableau. Cliquez simplement sur le nom de la couche (ici “deals”) pour la paramétrer à nouveau si besoin. Pour vérifier que tout a fonctionné, on peut prévisualiser la couche directement depuis GeoServer.\n\nAllez dans “Prévisualisation de la Couche” (à gauche)\nSur la ligne de la couche “deals”, sélectionnez “OpenLayers” (dans la colonne “Formats usuels”)\n\nVous devriez voir apparaître quelque chose comme ça, avec des informations supplémentaires si vous cliquez sur des points (possible car notre couche est interrogeable) :\n\n\n\n\n\nSi c’est bon, bravo, ça a fonctionné ! Si vous voyez des artefacts autour des points, c’est normal. Ce que vous regardez, ce ne sont pas des polygones mais une image produite à partir de notre couche et transmise comme un flux WMS par notre serveur. L’intérêt, c’est qu’on peut afficher rapidement des couches très lourdes de cette manière, là où un GeoJSON commencerait à ramer. Et on peut toujours zoomer et cliquer sur un point pour l’interroger. C’est super pratique ! Ce flux WMS est récupéré et lu par une petite appli OpenLayers, c’est comme ça que vous êtes capable de voir la couche sur votre page web (vous sentez venir la transition vers les prochains cours, là ?).\nBon, super, on a notre couche moche. Maintenant, on en fait quoi de tous ces points rouges ?\n\n\n\n\n\nFacile. On va d’abord la rendre un peu plus belle, puis on va la lire dans notre propre application OpenLayers et commencer à faire des trucs cools avec. Mais avant, comme vous avez tout compris à ce qu’on vient de faire, ajoutez toutes les autres couches du GeoPackage à votre espace de travail. Quand vous avez réussi à toutes les prévisualiser, créez un nouveau projet QGIS et importez aussi ces couches.\n\n\nStyliser mes couches\nDocumentation GeoServer “Styling”\nPour le moment, afficher notre couche “deals” va juste donner l’impression que notre carte a attrappé la varicelle. On va commencer par changer son apparence en faisant des points bien ronds et d’une couleur plus agréable. Pour ça, on va devoir créer un nouveau style.\n\nAllez dans “Styles” et cliquer sur “Ajouter un nouveau style”.\nNommez le style “deals” et choisissez l’espace de travail “land_matrix”. Conservez le format SLD, c’est le seul disponible sans ajouter d’extensions.\nPour nous aider, GeoServer propose de générer un SLD par défaut. Sélectionnez “Point” et cliquez sur “Générer…”. Vous devriez vous retrouver avec un fichier .xml décrivant la couche.\n\nOn pourrait aller lire en détail le SLD Cookbook de GeoServer pour écrire notre fichier manuellement, mais on est plus malins que ça. On a un super outil à disposition qui s’appelle QGIS.\n\nSi vous ne l’avez pas déjà fait, créez un projet QGIS et ajoutez les couches Land Matrix.\nDonnez un style sympa aux points de la couche deals. J’ai changé la couleur pour les rendre orange.\nAllez dans les propriétés de votre couche et dans “Symbologie”. Tout en bas, choisissez “Style” et “Enregistrer le style…”.\nChoisissez l’option “En tant que fichier SLD” et choisissez le chemin et le nom de votre fichier en cliquant sur “…” après “Fichier”. J’ai appelé le mien “deals.sld”\nAllez chercher votre fichier et ouvrez-le avec un éditeur de texte (Notepad, VSCode, peu importe).\nCopiez le contenu.\nRetournez sur votre page GeoServer, supprimez tout le contenu de la zone de texte et collez à la place le contenu de deals.sld. Voilà ce que ça donne pour moi :\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Deal&lt;/se:Name&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#ffd157&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;7&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\nVous pouvez prévisualiser la légende en cliquant sur “Aperçu de la légende”. Le bouton “Ajouter une légende” permet quand à lui d’ajouter une image customisée plutôt qu’une génération automatique. C’est pratique quand on a des légendes complexes, mais pas pour le moment. Ensuite, sauvegardez la légende quand elle vous convient.\n\n\n\n\n\n\nTip\n\n\n\nUne autre méthode pour charger le contenu d’un fichier de style .sld est de cliquer sur “Browse” en dessous de “Fichier de style”. Allez chercher votre fichier .sld et cliquez sur “Charger…” pour vous économiser quelques copier-coller par la suite !\n\n\nMaintenant, il faut dire à GeoServer qu’on veut utiliser ce style avec notre couche “deals”.\n\nAllez dans “Couches”.\nSélectionnez la couche “deals et allez dans l’onglet”Publication”.\nDans “Style par défaut”, sélectionnez “land_matrix:deals” et sauvegardez.\n\nMaintenant, vous pouvez de nouveau prévisualiser la couche “deals” et voilà ! Vous savez maintenant créer un nouveau style SLD depuis QGIS et l’ajouter à une couche dans GeoServer !\n\n\n\n\n\nNormalement, vous commencez à bien comprendre le fonctionnement de GeoServer et la publication des couches. Créez un style de couleur unique pour “deals_by_country” qu’on utilisera comme pseudo fond de carte. Ensuite, créez un style en cercles proportionnels pour “deals_by_country_centroid” en vous basant sur l’attribut “surface_ha”.\n\n\n\n\n\n\nAttention à la sémiologie\n\n\n\nJe ne veux pas voir de polygones “deals_by_country” de différentes couleurs. On n’utilise pas de carte choroplèthe pour représenter une valeur absolue, elles servent pour les valeurs relatives ou les catégories.\n\n\nUne fois que vous avez au moins ajouté votre style à “deals_by_country” dans GeoServer, vous pouvez passer à la suite. Si vous avez un train de retard, cliquez sur les boutons ci-dessous pour dérouler mes styles et les copier-coller dans votre GeoServer.\n\n\n\n\n\n\nSLD pour “deals_by_country”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals_by_country&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals_by_country&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Single symbol&lt;/se:Name&gt;\n          &lt;se:PolygonSymbolizer&gt;\n            &lt;se:Fill&gt;\n              &lt;se:SvgParameter name=\"fill\"&gt;#fdbf6f&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"fill-opacity\"&gt;0.35&lt;/se:SvgParameter&gt;\n            &lt;/se:Fill&gt;\n            &lt;se:Stroke&gt;\n              &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-width\"&gt;1&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-linejoin\"&gt;bevel&lt;/se:SvgParameter&gt;\n            &lt;/se:Stroke&gt;\n          &lt;/se:PolygonSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\n\n\n\n\nSLD pour “deals_by_country_centroid”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals_by_country_centroid&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals_by_country_centroid&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;201 - 5466&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;201 - 5466&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;200.81000000000000227&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThanOrEqualTo&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;4&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;5466 - 20413&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;5466 - 20413&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;10&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;20413 - 61376&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;20413 - 61376&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;16&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;61376 - 160220&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;61376 - 160220&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;22&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;160220 - 1509612&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;160220 - 1509612&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;1509612&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;29&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\nLire mes flux carto dans une autre application\nCourage, on touche au but. Vous aurez bientôt fait le tour du fonctionnement basique de GeoServer. Maintenant qu’on a nos couches, on veut pouvoir les lire.\nPour commencer, on va rapidement vérifier qu’on communique bien avec notre GeoServer en utilisant QGIS et la requête GetCapabilities du serveur. Cette requête, lorsqu’elle réussit, nous répond avec un fichier .xml qui explique à QGIS tout ce que le serveur est capable de faire, et notamment quelles couches peuvent être affichées.\n\nDans QGIS, cliquez sur “Ajouter une couche” et sélectionnez “WMS”.\nDans l’onglet “Couches”, cliquez sur “Nouveau”.\nAppelez la connexion “mon_geoserver” et collez l’url GetCapabilities dans “URL”. Elle devrait être identique à celle-ci :\n\nhttp://localhost:8080/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetCapabilities\n\n\n\n\n\n\nÇa ne fonctionne pas !\n\n\n\n\n\nPour vérifier que votre requête est bonne, allez dans GeoServer, affichez n’importe quelle couche en prévisualisation et copiez l’adresse.\nhttp://localhost:8080/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetMap&layers=land_matrix%3Adeals&bbox=-180.0%2C-90.0%2C180.0%2C90.0&width=768&height=384&srs=EPSG%3A4326&styles=&format=application/openlayers\nSupprimez tout ce qui se trouve après “request=” et ajoutez “GetCapabilities”.\nhttp://localhost/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetCapabilities\n\n\n\n\nCliquez ensuite sur “Connexion” et vérifiez qu’une liste de couche apparaît et qu’elle contient bien vos couches “deals”, etc.\n\nVous pouvez afficher la couche dans QGIS avec “Add” si vous le souhaitez. L’essentiel, c’est qu’on a vérifié que notre serveur émet bien des flux WMS pour nos couches et qu’on peut bien les lire.\nBien joué ! Vous maîtrisez maintenant les fonctionnalités basiques de GeoServer. Vous savez le déployer grâce à Docker, importer des couches de données, les styliser et les visualiser dans GeoServer et dans QGIS.\n\n\n\n\n\nLe prochain cours nous permettra d’apprendre à lire nos couches dans une application OpenLayers. D’ici-là, voici un petit récap de la journée :",
    "crumbs": [
      "GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/03_cours_geoserver.html#récap-sur-les-serveurs-carto",
    "href": "cours/geonum/03_cours_geoserver.html#récap-sur-les-serveurs-carto",
    "title": "GeoServer",
    "section": "Récap sur les serveurs carto",
    "text": "Récap sur les serveurs carto\n\nC’est quoi l’intérêt du serveur carto, déjà ?\n\nCentralisation de la donnée et mise à jour\nDistribution de la donnée\nGestion des droits\nBien quand on a une organisation et bcp de données, s’intègre très bien dans une IDG\nBien pour les couches Raster et les couches Vecteur lourdes qui peuvent être servies en tant qu’images (WMS)\nConnexion directe à une base de données PostgreSQL\nPossibilité d’écrire des requêtes SQL pour former les couches\nPossibilité de créer des styles complexes “à la QGIS”.\n\nEst-ce que j’en ai besoin pour mon projet GeoNum ?\n\nÇa dépend des données que vous utilisez et ce que vous en faites. Le mieux c’est d’en discuter avec les profs !",
    "crumbs": [
      "GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/04_cours_intro_openlayers.html",
    "href": "cours/geonum/04_cours_intro_openlayers.html",
    "title": "OpenLayers – introduction",
    "section": "",
    "text": "Comprendre à quoi sert NodeJS\nApprendre à créer une application OpenLayers avec NodeJS\nAfficher de la donnée dans mon application\n\nDurée : 1h30 à 2h",
    "crumbs": [
      "OpenLayers – introduction"
    ]
  },
  {
    "objectID": "cours/geonum/04_cours_intro_openlayers.html#objectifs-de-la-session",
    "href": "cours/geonum/04_cours_intro_openlayers.html#objectifs-de-la-session",
    "title": "OpenLayers – introduction",
    "section": "",
    "text": "Comprendre à quoi sert NodeJS\nApprendre à créer une application OpenLayers avec NodeJS\nAfficher de la donnée dans mon application\n\nDurée : 1h30 à 2h",
    "crumbs": [
      "OpenLayers – introduction"
    ]
  },
  {
    "objectID": "cours/geonum/04_cours_intro_openlayers.html#supports",
    "href": "cours/geonum/04_cours_intro_openlayers.html#supports",
    "title": "OpenLayers – introduction",
    "section": "Supports",
    "text": "Supports\nCours : Introduction à OpenLayers",
    "crumbs": [
      "OpenLayers – introduction"
    ]
  },
  {
    "objectID": "cours/geonum/04_cours_intro_openlayers.html#tp-mise-en-place-dune-application-openlayers-avec-nodejs",
    "href": "cours/geonum/04_cours_intro_openlayers.html#tp-mise-en-place-dune-application-openlayers-avec-nodejs",
    "title": "OpenLayers – introduction",
    "section": "TP – Mise en place d’une application OpenLayers avec NodeJS",
    "text": "TP – Mise en place d’une application OpenLayers avec NodeJS\n\nQuartier libre pour faire une première carte !\nComme vous avez des bases solides en Leaflet et que OpenLayers n’est pas si différent que ça, je vous propose de commencer par un petit exercice “libre” où vous essayez de vous approcher le plus possible de la consigne suivante :\nCréez une carte grâce à OpenLayers à l’échelle globale. Vous pouvez utiliser le fond de carte que vous voulez SAUF celui par défaut (si vous êtes en manque d’inspiration, je vous conseille un des fonds de Stamen Maps). Ensuite, en partant du jeu de données land_matrix_mines qu’on a utilisé la dernière fois, affichez la couche de votre choix sur la carte. Si vous avez besoin de la couche au format GeoJSON vous pouvez l’exporter comme telle depuis QGIS (pour rappel, on travaille en WGS84, il serait avisé d’exporter la couche dans ce système de projection). Enfin, si vous avez le temps, ajoutez un titre à votre carte.\nVous pouvez utiliser tous les outils à votre disposition sans restriction. Ça peut inclure les cours que je vous ai déjà faits, d’autres cours, de la documentation, des forums, des sites, des vidéos, des chatbots… comme on dit, tous les moyens sont bons pour coder !\nPendant que vous effectuez cet exercice, prenez des notes (mêmes très simples) sur ce que vous faites pour pouvoir retracer les étapes de votre développement. Il se peut que je vous demande ces notes en fin de séance, donc faites-le avec sérieux !\nVoilà un exemple de notes attendues (je vous l’ai dit, ça doit rester simple) :\n\n\nNouveau dossier pour créer appli\nChoisi d’utiliser NodeJS pour l’appli [ajoutez ici les commandes utilisées pour créer le projet si c’est le cas]\nCours Leaflet -&gt; importer un GeoJSON. Sauvegarde couche deals au format GeoJSON depuis QGIS (EPSG:3857).\n\n\nVous pouvez y ajouter quelques petits bouts de code ou de fonctions si vous le jugez pertinent. J’aimerais aussi y trouver les liens des ressources qui vous ont été utiles ou vos prompts si vous utilisez une IA (avec le nom de l’IA, évidemment). Si c’est un autre étudiant qui vous a donné un coup de main, indiquez-le moi aussi (ex: “Aide reçue pour niveau de zoom carte”, vous voyez l’idée).\n\n\n\n\n\n\nNote\n\n\n\nJe rappelle que cet exercice n’est pas noté. Recevoir de l’aide d’un autre étudiant ou de ma part n’est pas pénalisé. Utiliser Chat-GPT n’est pas pénalisé. Vous avez droit à toutes les ressources disponibles, j’ai juste besoin de savoir lesquelles vous avez utilisé.\nC’est bien si vous essayez d’aller le plus loin possible mais prenez quand-même votre temps et essayez de procéder par étapes.\nPar contre, si vous ne faites aucun effort pour avancer et pour comprendre ce que vous faites, ça va finir par se voir… et il y aura quelques points d’investissement dans mon cours sur la note finale, donc faites quand même un effort.\n\n\n\n\n\n\n\n\nÀ ouvrir après avoir fait un premier test (création de carte)\n\n\n\n\n\nSi vous ne savez vraiment pas par où commencer…\n\nLe premier réflexe que vous devriez avoir serait d’ouvrir le site officiel d’OpenLayers. Il existe toujours sur ces outils de développement une section “getting started”.\nOpenLayers ressemble beaucoup à Leaflet. Vraiment, vraiment beaucoup.\nN’oubliez pas d’utiliser F12 pour afficher la console de développement et d’abuser des console.log() pour trouver d’où viennent vos erreurs !\nLa structure de la page se trouve dans index.html. Le style se trouve dans style.css. Le code JavaScript se trouve dans main.js.\n\nSi ce n’était pas vraiment utile pour vous, alors c’est que vous êtes déjà sur la bonne voie.\n\n\n\n\n\n\n\n\n\nÀ ouvrir après avoir fait un premier test (GeoJSON)\n\n\n\n\n\nLà, c’est un peu plus technique alors je vous donne une astuce :\n\nDéjà, utilisez du GeoJSON si vous ne savez pas par où prendre le problème. C’est votre meilleure porte d’entrée. Vous pouvez exporter la couche de votre choix en GeoJSON depuis QGIS.\nOpenLayers utilise les fonctions ol/layer/Vector pour créer des couches au format vectoriel. C’est ce qu’il faut utiliser avec du GeoJSON.\nToujours si vous travaillez avec du GeoJSON, vous devriez regarder du côté de ol/format/GeoJSON.\n\n\n\n\n\n\nFin de session\nQuand tout le monde a terminé (peu probable) ou qu’on a déjà passé beaucoup de temps sur la question (très probable), on va prendre le temps de comparer nos résultats et les méthodes qui ont le mieux fonctionné pour afficher la carte attendue. L’idée est d’avoir un échange pendant quelques minutes, préparez-vous donc à parler des points suivants :\n\nPar quoi est-ce que j’ai commencé, quel a été mon premier réflexe ? Si c’est une recherche Google, qu’est-ce que j’ai tapé en premier ? Si c’est Chat-GPT, quel a été mon premier prompt ?\nComment est-ce que je me suis organisé⋅e, est-ce que j’ai découpé l’exercice en étapes ? Est-ce que j’ai réussi à tout faire d’un bloc ?\n\n\n\nQuelle ressource / site / outil m’a le plus aidé ?\nEst-ce que j’ai pensé à consulter la documentation officielle d’OpenLayers ? Est-ce que j’ai réussi à m’en servir ?\nSi j’ai utilisé l’IA, comment est-ce que j’ai raffiné mes prompts ? Est-ce que je lui ai demandé de générer du code ? De me donner des explications ?\nHTML, CSS, JavaScript… est-ce que je comprends la différence ? Est-ce que je sais où trouver le code de mon application, où aller pour ajouter une couche, où aller pour ajouter un titre sur ma carte ?\nEst-ce que je comprends les notions de “source” et de “layer” d’OpenLayers, ou bien est-ce que c’est encore trop flou même après cet exercice ?\n\nPendant la discussion, à la suite de vos notes, ajoutez les pistes que vous envisagez pour vous débloquer / pour améliorer votre carte.\nIl se peut que je vous demande de partager votre écran pour montrer l’état actuel de votre carte et votre code et en parler un peu, si la discussion s’y prête.\nSi jamais vous vous êtes laissés distraire, ce serait le bon moment pour fermer tous les onglets qui n’ont pas de rapport avec mon cours 👀",
    "crumbs": [
      "OpenLayers – introduction"
    ]
  },
  {
    "objectID": "cours/geonum/05_cours_openlayers_bases.html",
    "href": "cours/geonum/05_cours_openlayers_bases.html",
    "title": "OpenLayers – cycle de développement",
    "section": "",
    "text": "Discuter des outils de développement web et comment les utiliser\nAjouter une application OpenLayers à notre stack Docker\nBuild et “mettre en production” l’application, servie par un serveur Caddy\nComprendre la structure du code de l’application OpenLayers\nCréer un commit et héberger votre code sur GitHub",
    "crumbs": [
      "OpenLayers – cycle de développement"
    ]
  },
  {
    "objectID": "cours/geonum/05_cours_openlayers_bases.html#objectifs-de-la-session",
    "href": "cours/geonum/05_cours_openlayers_bases.html#objectifs-de-la-session",
    "title": "OpenLayers – cycle de développement",
    "section": "",
    "text": "Discuter des outils de développement web et comment les utiliser\nAjouter une application OpenLayers à notre stack Docker\nBuild et “mettre en production” l’application, servie par un serveur Caddy\nComprendre la structure du code de l’application OpenLayers\nCréer un commit et héberger votre code sur GitHub",
    "crumbs": [
      "OpenLayers – cycle de développement"
    ]
  },
  {
    "objectID": "cours/geonum/05_cours_openlayers_bases.html#supports",
    "href": "cours/geonum/05_cours_openlayers_bases.html#supports",
    "title": "OpenLayers – cycle de développement",
    "section": "Supports",
    "text": "Supports\nCours : Un point sur l’IA\nCours : Développer avec NodeJS et OpenLayers",
    "crumbs": [
      "OpenLayers – cycle de développement"
    ]
  },
  {
    "objectID": "cours/geonum/05_cours_openlayers_bases.html#tp-mise-en-place-dune-application-openlayers-avec-nodejs-mais-cette-fois-on-est-préparés",
    "href": "cours/geonum/05_cours_openlayers_bases.html#tp-mise-en-place-dune-application-openlayers-avec-nodejs-mais-cette-fois-on-est-préparés",
    "title": "OpenLayers – cycle de développement",
    "section": "TP – Mise en place d’une application OpenLayers avec NodeJS, mais cette fois on est préparés",
    "text": "TP – Mise en place d’une application OpenLayers avec NodeJS, mais cette fois on est préparés\n\nCréation de l’application en NodeJS\nOn va ajouter l’application dans notre stack existante. Pour ça, retournez dans le dossier dans lequel on a travaillé lors de la dernière séance (celui avec le GeoServer) qui devrait s’appeler geonum_docker.\nSi un dossier app existe déjà, supprimez-le. Allez-y, ne soyez pas timides !\nEnsuite, rendez-vous sur le site officiel d’OpenLayers et cherchez la section “Quick Start”. Prenez le temps de parcourir la page, elle contient toutes les informations dont vous avez besoin. Ensuite, ouvrez un terminal dans votre dossier geonum_docker et tapez la commande suivante :\nnpm create ol-app app\nNote : elle est un peu différente de celle qui vous est donné sur la page. Cherchez la différence, essayez de comprendre ce qui change.\nEnsuite, déplacez-vous dans le dossier app :\ncd app\nEnsuite, on doit build notre application pour que notre serveur de production (Caddy) puisse lire le contenu de l’application.\nnpm run build\n\n\n\n\n\n\nPoint diapos tous ensemble sur le cycle de développement\n\n\n\n\n\n\n\n\nLe cycle de développement\nComme on l’a vu à l’instant en cours, le développement d’une application est un cycle. Si on le simplifie, on a une boucle qui alterne développement &gt; tests &gt; production.\n\n\n\n\n\nflowchart LR\n    dev(\"Développement\") --&gt; tests\n    tests(\"Tests\") --&gt; dev\n    tests --&gt; prod(\"Production\")\n    prod --&gt; dev\n\n\n\n\n\n\n\nDéveloppement : on ajoute de nouveaux éléments à l’application.\nTests : on teste les nouvelles fonctionnalités. Si on trouve des bugs ou des choses à améliorer, on retourne à la phase de développement.\nProduction : si notre application a passé tous les tests, alors elle est prête à accueillir définitivement les nouveaux éléments qu’on a développés.\n\nPour accéder au serveur de développement (pour développer les nouveaux éléments et faire les tests) :\nnpm start\nPour build notre application qui est stable et prête à être mise en production :\nnpm run build\nPour rappel, si vous voulez voir le résultats de votre build, il faut lancer votre stack docker pour que votre serveur web (Caddy) puisse servir votre application.\ncd .. # Pour revenir à la racine de geonum_docker\ndocker compose up -d\nAccédez à votre http://localhost/ pour voir l’application en production.\n\n\nVersionner mon code en local avec un commit\nAvant d’aller plus loin dans la création de notre application, on va utiliser Git pour versionner notre projet et l’héberger en ligne.\nD’abord, retournez à la racine de votre projet geonum_docker :\ncd ..\nEnsuite, vérifiez que votre projet est bien versionné.\ngit status\nSi vous avez un message long qui fait peur, c’est bon signe. En fait, notre projet est déjà vesionné parce qu’on l’a récupéré sur mon GitHub. On a importé mes fichiers… mais aussi le git associé !\nSi jamais ce n’est pas le cas, alors vous devez initialiser votre dépôt :\ngit init\ngit status\nNote : toutes les étapes suivantes peuvent être faites en interface graphique si vous préférez. Moi je travaille en lignes de commande, et comme c’est ce qui est le plus universel c’est ce que je vous partage ici.\nNormalement, vous savez faire la suite, mais voilà quand même comment stage vos changements (autrement dit, les ajouter à votre prochain commit) :\ngit add .\nMaintenant, on crée notre commit avec un message qui indique ce que fait le code qu’on a ajouté depuis le dernier commit :\ngit commit -m \"Carte OpenLayers basique\"\n\n\nHéberger mon code sur GitHub\nEnsuite, vous pouvez créer un dépôt GitHub (ce sera plus sympa pour voir et partager votre application). Je pars du principe que vous avez tous un compte GitHub. Vous n’êtes pas obligé de le faire, mais ça reste vivement recommandé surtout que je vais vous demander un rendu sur GitHub… et que vous devrez aussi héberger vos projets GeoNum sur GitHub.\n\n\n\n\n\n\nAttention aux infos que vous mettez en ligne\n\n\n\nVous allez créer un dépôt qui sera visible en ligne. Bien évidemment, ne mettez aucune information sensible (mots de passe, etc.) ni rien d’autre que vous ne voulez pas partager. Avec Git, on peut même retrouver le commentaire dans votre code où vous avez écrit des mots pas très élégants parce que vous étiez frustré⋅e, donc n’écrivez pas n’importe quoi.\nOui, je parle d’expérience. Non, tous mes collègues n’ont pas ri.\n\n\n\nOuvrez GitHub\nCréez un nouveau Repository (Dépôt ?) en cliquand sur le bouton New (ou en allant directement sur https://github.com/new)\nDonnez un nom et une description à votre dépôt\nAssurez-vous de ne créer ni de readme ni de gitignore\nCliquez sur “create repository”\n\nEnsuite, suivez les instructions données par GitHub pour mettre en ligne votre dépôt. Commencez après la ligne git commit -m \"First commit\" (on a déjà créé notre commit juste avant).\n\n\n\n\n\n\nDouble authentification\n\n\n\n\n\nSi vous prenez la sécurité de vos comptes en ligne au sérieux et que vous avez activé la double-authentification en ligne, ce sera un petit peu plus compliqué de définir votre remote origin. Le lien “simple” vers votre dépôt ne suffit pas.\nPour accéder à votre code depuis votre PC, vous allez devoir créer un Personal access token depuis vos Developers settings (vous devez être connecté pour accéder au lien). En haut à droite, sélectionnez “Generate new token (classic)” et donnez vous au moins les droits de la section Repo. Ensuite, sauvegardez bien votre token quelque part (comme dans un gestionnaire de mots de passe) car vous ne pourrez plus le récupérer !\nMaintenant, retourner dans votre dossier geonum_docker et dans la ligne de commande, tapez en remplaçant les valeurs entre &lt;&gt; ;\ngit remote set-url origin https://oauth2:&lt;accesstoken1234&gt;@github.com/&lt;Username&gt;/&lt;repository_name&gt;\n\nPar exemple, si mon token est 123456789azerty, mon nom d’utilisateur GradelerM et mon dépôt geonum_docker, ça donne ça :\n\ngit remote set-url origin https://oauth2:123456789azerty@github.com/GradelerM/geonum_docker\nVous pouvez lancer à nouveau un git push !\n\n\n\nVoilà, normalement tout est prêt pour la suite !",
    "crumbs": [
      "OpenLayers – cycle de développement"
    ]
  },
  {
    "objectID": "cours/geonum/05_cours_openlayers_bases.html#tp-jajoute-ma-première-couche-à-lapplication",
    "href": "cours/geonum/05_cours_openlayers_bases.html#tp-jajoute-ma-première-couche-à-lapplication",
    "title": "OpenLayers – cycle de développement",
    "section": "TP – J’ajoute ma première couche à l’application",
    "text": "TP – J’ajoute ma première couche à l’application\nAvant d’aller plus loin, on va prendre le temps de comprendre comment est structuré le code de notre application et quels outils sont à notre disposition pour coder. Ensuite, on ajoutera la première couche de données ensemble.\nTous les éléments de ce TP se trouvent dans les diapos, alors soyez attentifs !",
    "crumbs": [
      "OpenLayers – cycle de développement"
    ]
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#sommaire",
    "href": "cours/geonum/05_diapos_node_openlayers.html#sommaire",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Sommaire",
    "text": "Sommaire\n\nLe cycle de développement (web)\nStructure de mon application OpenLayers\nSe familiariser avec le code de l’application\nConseils pour coder\n(Une) Méthode pour coder une application OpenLayers\nOn ajoute notre première couche ensemble"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#avant-toute-chose",
    "href": "cours/geonum/05_diapos_node_openlayers.html#avant-toute-chose",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Avant toute chose…",
    "text": "Avant toute chose…\nCommencez par suivre la section “Création de l’application en NodeJS” du TP avant de commencer le point sur le cycle de développement."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web",
    "href": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Le cycle du développement web",
    "text": "Le cycle du développement web\nLa version simpliste\nLe développement d’une application est un cycle. Si on le simplifie, on a une boucle entre le développement lui-même et la mise en production de l’application.\n\n\n\n\n\nflowchart LR\n  dev(\"Développement\") --&gt; prod(\"Production\")\n  prod --&gt; dev\n\n\n\n\n\n\n\nDéveloppement : on ajoute de nouveaux éléments à l’application. Le développement s’effectue en local (sur mon ordinateur), grâce à un serveur de développement (lancé avec npm start dans notre cas).\nProduction : on met en production ces nouveaux éléments. On build l’application avec npm run build et on met le résultat, le contenu du dossier dist/, dans notre serveur web. Dans notre cas, le Docker Compose s’occupe de connecter dist/ au serveur Caddy."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web-1",
    "href": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web-1",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Le cycle du développement web",
    "text": "Le cycle du développement web\nLe quality check pour mettre une nouvelle version en production : les tests\nDans la réalité, et vous l’avez déjà certainement appliqué sans vous en rendre compte, il faut vérifier que l’application est prête à être mise en production : en gros, que nos nouveaux éléments fonctionnent bien et qu’on ne rajoute pas de nouveaux bugs.\n\n\n\n\n\nflowchart LR\n    dev(\"Développement\") --&gt; tests\n    tests(\"Tests\") --&gt; dev\n    tests --&gt; prod(\"Production\")\n    prod --&gt; dev\n\n\n\n\n\n\n\nDéveloppement : on ajoute de nouveaux éléments à l’application.\nTests : on teste les nouvelles fonctionnalités. Si on trouve des bugs ou des choses à améliorer, on retourne à la phase de développement.\nProduction : si notre application a passé tous les tests, alors elle est prête à accueillir définitivement les nouveaux éléments qu’on a développés."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web-2",
    "href": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web-2",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Le cycle du développement web",
    "text": "Le cycle du développement web\nIntégration de Git\nComme vous savez utiliser Git pour versionner votre code, on peut complexifier ce schéma en intégrant la création de nouvelle branche, les commits et les fusions de branches (merge).\n\n\n\n\n\nflowchart LR\n  start{\"Start\"} --&gt; branch{{\"git branch\"}}\n  branch --&gt; dev(\"Développement\")\n  dev --&gt; build{{\"npm run build\"}}\n  build --&gt; tests(\"Tests\")\n  tests --&gt; dev\n  build --&gt; commit{{\"git commit\"}}\n  commit --&gt; merge{{\"git merge\"}}\n  merge --&gt; prod(\"Production\")\n  prod --&gt; stop{\"End\"}\n  stop --&gt; start\n\n\n\n\n\n\n\nJe crée une nouvelle branche (git branch) pour ma nouvelle feature / ma correction de bug, par exemple fond-carte-stamen.\nQuand je juge que le développement est terminé, je build mon application (npm run build) pour pouvoir tester la nouvelle version.\nSi je trouve des bugs, je continue le développement."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web-3",
    "href": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web-3",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Le cycle du développement web",
    "text": "Le cycle du développement web\nIntégration de Git\nComme vous savez utiliser Git pour versionner votre code, on peut complexifier ce schéma en intégrant la création de nouvelle branche, les commits et les fusions de branches (merge).\n\n\n\n\n\nflowchart LR\n  start{\"Start\"} --&gt; branch{{\"git branch\"}}\n  branch --&gt; dev(\"Développement\")\n  dev --&gt; build{{\"npm run build\"}}\n  build --&gt; tests(\"Tests\")\n  tests --&gt; dev\n  build --&gt; commit{{\"git commit\"}}\n  commit --&gt; merge{{\"git merge\"}}\n  merge --&gt; prod(\"Production\")\n  prod --&gt; stop{\"End\"}\n  stop --&gt; start\n\n\n\n\n\n\n\nSi mon build est prêt, je peux commit mes changements (git commit) et j’ajoute un message qui explique ce que fait le nouveau code que je viens commit. Si votre développement vous fait ajouter beaucoup de code pour une seule feature, vous pouvez (devez) faire plusieurs commits. Vous pouvez les voir comme des checkpoints dans votre développement — si vous cassez quelque chose, vous pouvez revenir au dernier commit, ou celui d’avant, etc."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web-4",
    "href": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web-4",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Le cycle du développement web",
    "text": "Le cycle du développement web\nIntégration de Git\n\n\n\n\n\nflowchart LR\n  start{\"Start\"} --&gt; branch{{\"git branch\"}}\n  branch --&gt; dev(\"Développement\")\n  dev --&gt; build{{\"npm run build\"}}\n  build --&gt; tests(\"Tests\")\n  tests --&gt; dev\n  build --&gt; commit{{\"git commit\"}}\n  commit --&gt; merge{{\"git merge\"}}\n  merge --&gt; prod(\"Production\")\n  prod --&gt; stop{\"End\"}\n  stop --&gt; start\n\n\n\n\n\n\n\nEnsuite, je dois merge le code de ma branche avec la branche prinicipale de mon code (généralement main) avec git merge.\nLa dernière étape est de mettre mon application en production. C’est très complexe et ce ne sera pas à vous de le faire. Le Docker Compose s’en charge pour vous."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web-5",
    "href": "cours/geonum/05_diapos_node_openlayers.html#le-cycle-du-développement-web-5",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Le cycle du développement web",
    "text": "Le cycle du développement web\nOn a vu une version très simplifiée de ce cycle, mais suffisante pour nos TPs ensemble (et pour votre projet GeoNum). Vous pouvez poursuivre le TP jusqu’à avoir réussi à héberger votre code sur GitHub. Ensuite, on reprendra les diapos pour apprendre à ajouter notre première couche à l’application !"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication",
    "href": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nNode JS crée beaucoup d’éléments mais voici ceux qu’on utilisera :\n\nindex.html\nstyle.css\nmain.js\n\nDeux autres explications à titre d’information :\n\nnode_modules/ contient notamment le code des librairies installées, c’est ici que vit le code source d’OpenLayers\ndist/ contient l’output du build du site, c’est les fichiers qui sont prêts à être servis par le serveur (pour nous, Caddy) pour mettre notre site en production"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication-1",
    "href": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication-1",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nindex.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"https://openlayers.org/favicon.ico\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Using OpenLayers with Vite&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication-2",
    "href": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication-2",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nindex.html\nUne référence pratique pour les balises html : W3schools.com"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication-3",
    "href": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication-3",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nstyle.css\n@import \"node_modules/ol/ol.css\";\n\nhtml, body {\n  margin: 0;\n  height: 100%;\n}\n#map {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n}"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication-4",
    "href": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication-4",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nstyle.css\nDes références pratiques pour écrire du CSS :\n\ncssreference.io pour la plupart des propriétés CSS\nW3schools.com pour les sélécteurs\nd’excellents guides sur css-tricks.com pour utiliser grid ou flexbox"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication-5",
    "href": "cours/geonum/05_diapos_node_openlayers.html#se-familiariser-avec-le-code-de-lapplication-5",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nmain.js\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nProblématiser\nLa première chose à faire est de découper le problème / la consigne en plus petits éléments à résoudre.\n\nCréez une carte grâce à OpenLayers à l’échelle globale. Vous pouvez utiliser le fond de carte que vous voulez SAUF celui par défaut (si vous êtes en manque d’inspiration, je vous conseille un des fonds de Stamen Maps). Ensuite, en partant du jeu de données land_matrix_mines qu’on a utilisé la dernière fois, affichez la couche de votre choix sur la carte. Si vous avez besoin de la couche au format GeoJSON vous pouvez l’exporter comme telle depuis QGIS (pour rappel, on travaille en WGS84, il serait avisé d’exporter la couche dans ce système de projection). Enfin, si vous avez le temps, ajoutez un titre à votre carte.\n\n\n\nCréer une application OpenLayers (aucune méthode n’est recommandée, j’ai le choix parmi les options disponibles)\nChanger le fond de carte (fonds Stamen recommandés)\nChercher comment importer un jeu de données au format vecteur dans une application OpenLayers (la consigne parle de GeoJSON)\nExporter une couche de land_matrix_mines en GeoJSON (WGS 84)\nImporter la donnée dans mon application\nAfficher la donnée sur la carte OpenLayers"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-1",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-1",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nRessources : la documentation\nD’abord, la documentation. C’est la bible d’OpenLayers et vous allez devoir apprendre à la comprendre, au moins en partie, ou vous allez avoir beaucoup de mal à comprendre ce que vous faites quand vous codez. Elle peut être trouvée à cette addresse : https://openlayers.org/en/latest/apidoc/"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-2",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-2",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nRessources : la documentation\nExemple d’utilisation de la documentation pour l’objet Map qui est créé dans main.js :\nTapez “Map” et cliquez sur le premier résultat (lien ici). On voit en haut de la page :\n\nComment importer cet objet Map\nUne description de ce qu’est cet objet Map\nUn exemple (“snippet”, petit morceau de code) qui montre comment utiliser Map"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-3",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-3",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nRessources : la documentation\nQuand on continue à défiler vers le bas, on voit plusieurs autres sections :\n\nLa définition de la fonction pour créer l’objet Map et les options qu’il prend (new Map(options))\nLes évènements qui peuvent être déclenchés (“fired”) par notre objet Map dans la section Fires:\nLes Méthodes de l’objet Map, donc les fonctions qui peuvent être déclenchées avec cet objet Map pour généralement le lire ou le modifier"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-4",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-4",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nLa documentation\n\n\n\n\n\nclassDiagram\n    class Map{\n        controls\n        pixelRatio\n        interactions\n        keyboardEventTarget\n        layers\n        maxTilesLoading\n        moveTolerance\n        overlays\n        target\n        view\n        +methods…()\n    }\n\n\n\n\n\n\nOK c’est un peu compliqué. Pour simplifier, on va prendre les éléments qui nous intéressent le plus."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-5",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-5",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nLa documentation\n\n\n\n\n\n\n\nclassDiagram\n    class Map{\n        target\n        layers\n        view\n        +addLayer()\n        +getlayers()\n        +getView()\n    }\n\n\n\n\n\n\n\nClasse : Map\nAttributs :\n\ntarget = l’id de ma &lt;div&gt; qui va contenir ma carte\nlayers = les couches créées avec OpenLayers qui doivent être ajoutées à ma carte\nview = les paramètres de la vue (centre, niveau de zoom) de ma carte lorsqu’elle est initialisée\n\nMéthodes :\n\naddLayer() = ajouter une couche créée avec OpenLayers à ma carte\ngetLayers() = récupérer les couches qui sont attachées à ma carte\ngetView() = récupérer les paramètres de la vue actuelle (centre, niveau de zoom)"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-6",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-6",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nLa documentation\nPour créer une carte sous OpenLayers, le point d’entrée principal est la galerie d’exemples. Je vous conseille vivement de toujours commencer par là avant d’aller voir d’autres ressources comme StackOverflow, etc. comme ce sont les exemples officiels qui sont maintenus à jour et respectent les bonnes pratiques d’utilisation du code OpenLayers.\nPar exemple, si vous souhaitez ajouter un flux WMS à votre carte, basez-vous sur le code de l’exemple Single Image WMS."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-7",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-7",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nLes extensions de l’IDE\nLes extensions présentes dans votre IDE (comme VSCode) vous donnent des indications sur les fonctions que vous utilisez.\n\nconsole.\nVSCode devrait vous proposer la liste des méthodes de console. Si vous commencez à taper la lettre l, il devrait vous proposer log en tête de liste. Il vous suffit d’appuyer sur “Entrée” pour valider l’autocomplétion.\n\n\nconsole.log()\nOuvrez les parenthèses et laissez votre curseur à l’intérieur. VSCode devrait vous afficher les arguments attendus (message), leur type (any), s’il y a des arguments optionnels possibles (oui)… et quelques exemples."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-8",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-8",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nLa console de développement\nLes outils de développeurs, et particulièrement la console, sont indispensables pour développer une application web. Pour y accéder, ouvrez votre application dans votre navigateur et appuyez sur la touche F12.\n\nLa console vous montre les messages d’erreur et vous indique à quel ligne l’erreur a lieu. Apprenez à l’utiliser pour corriger plus facilement vos bugs.\n\n\nUtilisez la fonction console.log() pour afficher les éléments de votre choix dans votre application. Essayez !\nconst a = 10;\n\nconsole.log(\"=== AFFICHAGE VARIABLE a ===\");\nconsole.log(a);\n=== AFFICHAGE VARIABLE a ===\n10"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-9",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-9",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nMaintenant qu’on a vu les ressources officielles d’OpenLayers et comment utiliser notre IDE, on va regarder ce qu’il y a d’autre."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-10",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-10",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nLes tutoriels pour bien démarrer\nÇa fonctionne peut-être moins bien en salle de classe, mais les tutoriels vidéo restent un très bon moyen d’apprendre à utiliser une librairie. Pensez à vérifier que la vidéo est assez récente (regardez la date de publication).\n\nVous pouvez aussi trouver des tutoriels au format écrit comme des articles de blog — blogs privés, Medium, etc.\nComme pour les vidéos, regardez la date de publication et essayez de choisir du contenu récent. Il serait dommage de suivre un tutoriel datant d’OpenLayers 5 en était sous OpenLayers 7+."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-11",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-11",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nLes forums pour résoudre ses problèmes\nLes sources de discussion les plus connues pour parler de code sont StackOverflow et StackExchange.\n\nLes Stack sont des forums spécialisés où les utilisateurs posent des questions, généralement liées à l’utilisation d’un logiciel, au développement en se basant sur une certaine librairie…\n\n\nPas la peine de taper votre recherche dans StackOverflow ou StackExchange. Si vous avez un bug, faites une recherche Google… ils sont généralement dans les premiers résultats.\nEssayez avec : “openlayers layer not showing”\n\n\nIl existe d’autres ressources pour communiquer avec d’autres utilisateurs et poser ses questions. Certains utilisent Reddit, d’autres des forums spécialisés pour leur application, des serveurs Discord…"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-12",
    "href": "cours/geonum/05_diapos_node_openlayers.html#conseils-pour-coder-12",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\nL’IA générative pour m’aider un peu partout\nNormalement, on en a déjà parlé au cours précédent. L’IA générative peut intervenir à chaque étape du processus.\nRéférez-vous au cours sur le sujet pour savoir comment optimiser vos prompts et vous en servir plus efficacement."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#une-méthode-pour-aborder-les-problèmes-en-développement-web",
    "href": "cours/geonum/05_diapos_node_openlayers.html#une-méthode-pour-aborder-les-problèmes-en-développement-web",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "(Une) Méthode pour aborder les problèmes en développement web",
    "text": "(Une) Méthode pour aborder les problèmes en développement web\nMéthode proposée\n\nDécouper le problème (la consigne, la demande du client…) en plusieurs petites étapes.\nChercher des tutoriels, des exemples pour chaque étape pour savoir où et comment commencer.\nCommencer à coder en se basant sur les tutoriels / exemples. Partir de quelque chose qui fonctionne et adapter le code petit à petit à notre problème. Quand on a du mal à comprendre ce qu’on écrit, utiliser d’abord l’IDE et la documentation.\nAux premiers problèmes, bugs, etc. chercher la source avec la console de développement en abusant des console.log().\nUne fois la source du bug identifiée, utiliser la documentation, les forums, les tutoriels, etc. pour corriger le bug.\nQuand votre nouvelle feature fonctionne (par exemple une couche qui s’affiche bien), recommencer la boucle pour la feature suivante."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nMaintenant, on va ajouter notre première couche WMS ensemble. Ouvrez geonum_docker dans votre IDE préféré et c’est parti !"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-1",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-1",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nProblématisation\nPremière étape : on problématise.\n\nAjoutez une couche de données à votre application OpenLayers à partir d’un flux WMS.\n\n\nIl me faut une application OpenLayers =&gt; check\nComment est-ce que OpenLayers peut lire les flux WMS ? Est-ce que la librairie est équipée pour ça ? =&gt; documentation, exemples officiels, recherches Google\nTrouver et importer un flux WMS\nL’afficher sur la carte"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-2",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-2",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nÀ la recherche d’un exemple\n\nDepuis le site officiel d’OpenLayers, accédez à la référence de l’API (et choisissez la dernière version). Essayez de voir si vous trouvez quelque chose en rapport avec des flux “WMS”.\nSuper, on dirait qu’OpenLayers est prévu pour pouvoir lire des flux WMS ! Pour voir comment ça fonctionne, plutôt que de s’arracher les cheveux sur la documentation de l’API, allez dans “Exemples” et tapez “WMS” dans la barre de recherche.\nExercice : on sait qu’on a à disposition un serveur GeoServer. Parmi les exemples OpenLayers, cherchez-en un qui lit de la donnée depuis un GeoServer.\nQuand on a trouvé notre exemple, on peut passer à la suite."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-3",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-3",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nPréparer mon environnement de développement\nOuvrez votre projet dans VSCode (ou votre IDE préféré). Si votre serveur de développement tourne encore, vous pouvez l’arrêter pour le moment (ctrl + C).\nComme on va développer un nouvel élément pour notre application, on va créer une nouvelle branche sur Git.\n\nRegardez si vous avez des changements sur votre branche. Si c’est le cas, on va les stage (ajouter aux modifications) puis les commit (valider les modifications) et enfin les push (pour mettre la branche à jour sur notre GitHub.\nEnsuite, on va créer une nouvelle branche. On lui donne un nom clair, comme couche-wms-exemple… quelque chose qui permet de rapidement comprendre ce que vous ajoutez à votre application.\nOn n’oublie pas de se déplacer sur cette nouvelle branche ! Quand vous codez, vérifiez que vous n’êtes pas sur “main” (ou “master”)."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-4",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-4",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nMaintenant qu’on est prêts, on peut reprendre notre exemple et commencer à coder. On utilisera donc l’exemple “Single image WMS” d’OpenLayers qui nous permet d’ajouter une couche WMS depuis un GeoServer à notre application.\nGardez cet exemple ouvert dans votre nagivateur, on va le détailler ensemble."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-5",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-5",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n🤔 Qu’est-ce qui est différent dans index.html ?\n\n\nle style n’est pas dans style.css mais dans une balise de &lt;style&gt;. Nous on a déjà un fichier de style qui fonctionne très bien et la carte en plein écran nous plait, on ne change rien.\n\n\n\n\nla balise &lt;div id=\"map\"&gt; a aussi une classe de style class = \"map\". Cela permet d’appliquer le même style à toutes les cartes avec la classe map. Nous on a une seule carte dans notre application, donc on s’en moque.\n\n\n\nEn gros, on n’a rien à modifier dans index.html ni dans le fichier de style style.css. On peut passer au gros morceau : le fichier de script main.js."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-6",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-6",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n🤔 Qu’est-ce qui est différent dans main.js ?\n\n👆 Mon conseil : au début, ignorez toute la section import qui peut sembler un peu floue et concentrez vous sur les variables qui sont définies dans le code, puis sur les objets OpenLayers.\n\n\n\n\nNotre code :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-7",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-7",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n\n\nNotre code :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-8",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-8",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n\n\nNotre code :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-9",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-9",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n\n\nNotre code :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-10",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-10",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n\n\nNotre code :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-11",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-11",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-12",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-12",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nDe quoi j’ai besoin pour ajouter une couche WMS à ma carte ?\n\nIl nous faut une source pour le flux WMS qu’on crée avec l’objet ImageWMS (documentation)\nIl nous faut un objet ImageLayer pour créer notre couche à partir de notre source\nIl nous faut un objet Map (déjà créé dans notre cas) auquel ajouter la couche\n\n\nMa proposition de code pour créer une couche (en retirant les éléments superflus pour simplifier) :\nconst ma_source = new ImageWMS({\n  url: '&lt;lien_vers_mon_serveur&gt;',\n  params: {'LAYERS': '&lt;espace&gt;:&lt;couche&gt;'},\n  serverType: 'geoserver',\n});\n\nconst ma_couche = new ImageLayer({\n  source: ma_source,\n});\n\n\nOn pourrait aussi l’écrire en imbriquant tout comme dans l’exemple, mais je préfère séparer les éléments, je trouve ça moins confus (surtout quand on apprend).\nconst ma_couche = new ImageLayer({\n  source: new ImageWMS({\n    url: '&lt;lien_vers_mon_serveur&gt;',\n    params: {'LAYERS': '&lt;espace&gt;:&lt;couche&gt;'},\n    serverType: 'geoserver',\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-13",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-13",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nIl nous manque un dernier détail : les imports. Si vous utilisez le code tel quel, vous allez avoir des messages d’erreur indiquant que les fonctions ne sont pas trouvées. Vous pouvez trouver les imports de trois manières :\n\nvous regardez les imports dans l’exemple OpenLayers et vous récupérez ceux dont vous avez besoin (lien)\nvous allez voir la documentation de ImageWMS par exemple et la première ligne vous indique comment importer le module dans votre code (lien)\nsi votre éditeur de code est bien fichu, il peut lui-même ajouter un import quand vous appelez un constructeur ou une méthode dans votre code\n\n👆 D’ailleurs, n’oubliez pas que les import doivent toujours être déclarés tout en haut du document !"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-14",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-14",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nVoici mon résultat pour importer la couche de l’exemple d’OpenLayers :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport { ImageWMS } from 'ol/source';\nimport TileLayer from 'ol/layer/Tile';\nimport ImageLayer from 'ol/layer/Image';\nimport OSM from 'ol/source/OSM';\n\nconst couche_osm = new TileLayer({ source: new OSM() });\n\nconst ma_source = new ImageWMS({\n  url: 'https://ahocevar.com/geoserver/wms',\n  params: { 'LAYERS' : 'topp:states' },\n  serverType: 'geoserver',\n});\n\nconst ma_couche = new ImageLayer({\n  source: ma_source,\n});\n\nconst map = new Map({\n  target: 'map',\n  layers: [ couche_osm, ma_couche ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-15",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-15",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nEnsuite, on doit tester notre application en conditions de déploiement — autrement dit, on teste son build.\n\nOuvrez un terminal dans le répertoire geonum_docker/app et lancez la commande npm run build\nSi ce n’est pas fait, lancez votre stack server geonum_docker (depuis Docker desktop ou avec docker compose up -d depuis la racine de votre projet geonum_docker)\nOuvrez votre localhost et vérifiez que vous voyez bien la nouvelle feature sur votre application !\n\n\nQuand vous estimez que votre nouvelle feature est prête (tout fonctionne dans la version build, vous avez ajouté les éléments que vous vouliez, etc.), on va pouvoir la merge dans notre branche principale et la mettre en production !"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-16",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-16",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nVous commencez à connaître les étapes.\n\nstage le nouveau code (dans l’IDE ou avec git add .)\ncommit sans oublier votre message (dans l’IDE ou avec git commit -m \"mon message\")\npush les changements sur votre GitHub (dans l’IDE ou avec git push)\n\n\nEnsuite, il faut qu’on merge le code de notre branche de développement dans la branche principale. On pourrait le faire localement, mais on va utiliser GitHub pour ça — vous allez sans doute l’utiliser pour collaborer pendant le projet GéoNum donc autant pratiquer maintenant."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-17",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-17",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nGitHub devrait vous indiquer que vous avez push une branche il y a quelques secondes et vous proposer de faire une merge request.\n\n\n\n\n\n\nTip\n\n\nPour rappel, une merge request et une “demande de merge une branche dans une autre”. Ici, on veut ajouter notre nouvelle feature (branche couche-WMS-exemple) dans la branche principale de notre application (branche main ou master).\n\n\n\n\nEnsuite, vous pouvez affiner ce qu’il doit se passer pendant le merge. Par exemple, vous pouvez choisir de supprimer la branche couche-WMS-exemple à la fin du merge. Je vous le déconseille pour le moment, on la supprimera manuellement.\nMaintenant, lancez le merge !"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-18",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-18",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nCe qu’on vient de faire, c’est mettre à jour le code de main (ou master) dans notre dépôt GitHub en y intégrant le code de notre nouvelle branche couche-WMS-exemple.\nIl ne nous reste plus qu’à récupérer le code sur notre machine et vérifier que tout s’affiche correctement !\n\nDéplacez-vous sur votre branche principale (dans l’IDE ou avec un git checkout main)\nEffectuez un git pull (dans l’IDE ou avec git pull)\nAllez dans geonum_docker/app et utiliser npm run build pour build votre application\nRelancez votre stack Docker si jamais vous l’aviez arrêtée\nOuvrez votre localhost et vérifiez que tout fonctionne"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-19",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-ajoute-notre-première-couche-ensemble-19",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nEt voilà ! Bravo, vous venez de compléter un cycle de développement."
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#on-récapitule-rapidement",
    "href": "cours/geonum/05_diapos_node_openlayers.html#on-récapitule-rapidement",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "On récapitule rapidement ?",
    "text": "On récapitule rapidement ?\nVous savez maintenant :\n\nProblématiser en découpant vos besoins en petites étapes ;\nChercher par où commencer chaque étape dans la documentation et les exemples officiels ;\nVous servir de votre IDE, des forums et autres outils à disposition pour vous appuyer ;\nCompléter un cycle de développement de votre nouvelle feature depuis la création de branch à la merge request sans oublier de build votre application.\n\nMaintenant, vous êtes parés pour la suite !"
  },
  {
    "objectID": "cours/geonum/05_diapos_node_openlayers.html#à-vous",
    "href": "cours/geonum/05_diapos_node_openlayers.html#à-vous",
    "title": "Développer avec NodeJS et OpenLayers",
    "section": "À vous !",
    "text": "À vous !\nVous allez pouvoir commencer le TP suivant pour commencer à ajouter vos couches dans votre application OpenLayers.\nC’est parti !"
  },
  {
    "objectID": "cours/geonum/07_cours_interactions.html",
    "href": "cours/geonum/07_cours_interactions.html",
    "title": "Interactions carte-interface",
    "section": "",
    "text": "Comprendre les évènements du navigateurs\nUtiliser les évènements pour créer de l’interaction entre HTML, CSS et JavaScript\nApprendre à identifier les évènements spécifiques à OpenLayers\nUtiliser les évènements pour ajouter de l’interaction entre la carte et le reste de la page\nCréer un menu d’affichage/masquage des couches",
    "crumbs": [
      "Interactions carte-interface"
    ]
  },
  {
    "objectID": "cours/geonum/07_cours_interactions.html#objectifs-de-la-session",
    "href": "cours/geonum/07_cours_interactions.html#objectifs-de-la-session",
    "title": "Interactions carte-interface",
    "section": "",
    "text": "Comprendre les évènements du navigateurs\nUtiliser les évènements pour créer de l’interaction entre HTML, CSS et JavaScript\nApprendre à identifier les évènements spécifiques à OpenLayers\nUtiliser les évènements pour ajouter de l’interaction entre la carte et le reste de la page\nCréer un menu d’affichage/masquage des couches",
    "crumbs": [
      "Interactions carte-interface"
    ]
  },
  {
    "objectID": "cours/geonum/07_cours_interactions.html#supports",
    "href": "cours/geonum/07_cours_interactions.html#supports",
    "title": "Interactions carte-interface",
    "section": "Supports",
    "text": "Supports\nCours : Ajouter des interactions à ma carte",
    "crumbs": [
      "Interactions carte-interface"
    ]
  },
  {
    "objectID": "cours/geonum/07_cours_interactions.html#tp-gérer-laffichage-de-mes-couches-et-ajouter-une-table-attributaire",
    "href": "cours/geonum/07_cours_interactions.html#tp-gérer-laffichage-de-mes-couches-et-ajouter-une-table-attributaire",
    "title": "Interactions carte-interface",
    "section": "TP – Gérer l’affichage de mes couches et ajouter une table attributaire",
    "text": "TP – Gérer l’affichage de mes couches et ajouter une table attributaire\n\n\n\n\n\n\nAvant de commencer le TP\n\n\n\nCe TP suppose que vous avez déjà ajouté les couches du jeu de données Land Matrix dans votre GeoServer et que vous pouvez les récupérer dans votre application. Si ce n’est pas le cas, veuillez vous référer aux étapes précédentes, sinon vous allez être un peu perdus.\n\n\nPour référence, je vous mets ici le contenu de mon code au démarrage de ce TP. Ça veut dire qu’il manque les éléments qu’on a ajoutés pendant le cours, alors repartez plutôt du votre !\nindex.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"https://openlayers.org/favicon.ico\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Transition Minerals&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\nstyle.css\n@import \"node_modules/ol/ol.css\";\n\nhtml, body {\n  margin: 0;\n  height: 100%;\n}\n#map {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n}\nmain.js\nimport './style.css';\nimport {Map, View} from 'ol';\nimport { ImageWMS } from 'ol/source';\nimport TileLayer from 'ol/layer/Tile';\nimport ImageLayer from 'ol/layer/Image';\nimport OSM from 'ol/source/OSM';\n\n// WMS de mon GeoServer\nconst geoserverWms = 'http://localhost:8080/geoserver/land_matrix/wms'\n\n// Layer: Fond de carte OSM\nconst layerOsm = new TileLayer({ source: new OSM() });\n\n// Layer: deals by country\nconst layerDealsByCountry = new ImageLayer({\n  source: new ImageWMS({\n    url: geoserverWms,\n    params: { 'LAYERS' : 'land_matrix:deals_by_country' },\n    serverType: 'geoserver',\n  })\n});\n\n// Layer: deals\nconst sourceDeals = new ImageWMS({\n  url: geoserverWms,\n  params: { 'LAYERS' : 'land_matrix:deals' },\n  serverType: 'geoserver',\n});\n\nconst layerDeals = new ImageLayer({\n  source: sourceDeals\n});\n\n// Map\nconst map = new Map({\n  target: 'map',\n  layers: [ layerOsm, layerDealsByCountry, layerDeals ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nCréer un menu d’affichage de couches\nOn souhaite maintenant créer un menu avec des cases de type “checkbox” qui vont nous permettre de choisir si on veut afficher ou masquer une couche. On doit commencer par créer cet élément dans l’interface en modifiant index.html.\n\nDéfinissez une &lt;div&gt; dans laquelle on souhaite afficher notre menu de couches et positionnez-la avec du CSS\nAjoutez à l’intérieur un input de type checkbox avec la balise &lt;input type=\"checkbox\"/&gt; et donnez lui un label avec le nom de la couche\n\nComme c’est la première fois qu’on doit écrire du HTML ensemble, je vous guide pas à pas. Commencez par ouvrir index.html et ajouter sous la div de votre carte (la div map) une autre div, comme ceci :\n&lt;div id=\"layers\" class=\"menu\"&gt;&lt;/div&gt;\nOn crée une nouvelle div dont l’identifiant est layers, ce qui nous permettra de la retrouver par la suite. On lui a aussi ajouté une classe qu’on appelle menu et qui nous permettra d’appliquer un seul style à tous nos éléments de menu. Si c’est un peu flou maintenant, vous comprendrez plus tard en ajoutant d’autres menus.\nComme notre div est vide, on ne la voit pas. Ça va être difficile de la positionner ailleurs sur la carte. J’ai l’habitude de mettre un peu n’importe quoi à l’intérieur, juste le temps de régler mon CSS correctement. Ma div ressemble donc à :\n&lt;div id=\"layers\" class=\"menu\"&gt;cthulhu fhtagn&lt;/div&gt;\nOn pourra retirer le texte après. Vous remarquerez qu’on ne voit (probablement) toujours pas notre texte. Essayez de rafraîchir la page - sauf si vous avez déjà modifié votre CSS, vous devriez le voir tout en haut à gauche de l’écran avant que la carte ne le recouvre ! C’est normal, nous n’avons pas “positionné” notre élément. Ce n’est pas un cours de CSS donc on ne rentrera pas dans les détails. Ouvrez styles.css et ajoutez le code suivant :\n.menu {\n  position: absolute;\n}\nOn sélectionne toutes les balises HTML avec la classe menu et on leur applique un positionnement absolu. Sauvegardez et vous devriez voir apparaître le texte. Super ! Mais… c’est moche et ça ne ressemble pas DU TOUT à un menu. Pas de souci, on y arrive. Ajoutez les éléments suivants (j’ai commenté le code pour vous aider à comprendre) :\n.menu {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  right: 20px;\n\n  /* Padding */\n  padding: 8px;\n\n  /* Dimensions minimales */\n  min-height: 80px;\n  min-width: 160px;\n\n  /* Rectangle blanc avec coins arrondis */\n  background-color: white;\n  border-radius: 8px;\n}\nAh, c’est déjà plus sympa ! On va même pouvoir supprimer le texte de notre balise HTML dans index.html. En gros, voilà ce que je fais avec ce code CSS :\n\nJ’indique que l’élément a une position absolue dans le body (donc pas relative à un élément) et qu’il doit se trouver à 20 pixels du haut (top) et 20 pixels de la droite (right) de l’écran.\nJe donne un padding, une marge intérieure, à mon élément de menu. Pour mieux comprendre, essayez de supprimer/commenter cette ligne et regardez ce qui change.\nJe donne une hauteur et une largeur minimales à mon élément pour éviter qu’il ne disparaîsse quand il est vide. Par défaut, mon élément aurait grandi et rétréci avec son contenu.\nJ’ai donné un peu de style à mon menu en lui donnant un fond blanc et des coins arrondis.\n\nVoilà globalement le niveau maximum de difficulté du CSS que je vais vous demander pour styliser votre application, mais vous pouvez évidemment allez plus loin !\nMaintenant qu’on a un menu, il va falloir ajouter la checkbox qui permettra d’afficher ou masquer ma couche. Retournez dans index.html et ajoutez la balise &lt;input&gt; et son &lt;label&gt; dans notre &lt;div id=\"layers&gt;, comme ceci :\n&lt;div id=\"layers\" class=\"menu\"&gt;\n  &lt;input type=\"checkbox\" id=\"checkbox-countries\" name=\"checkbox-countries\" checked /&gt;\n  &lt;label for=\"checkbox-countries\"&gt;Deals by countries&lt;/label&gt;\n&lt;/div&gt;\nVérifiez que vous pouvez cliquer sur la checkbox pour la cocher/décocher. L’interface est prête ! Il faut maintenant qu’on parvienne à dire à notre application qu’il faut afficher ou masquer la couche deals_by_country en fonction.\n\n\n\n\n\n\nAttention à bien différencier ajouter/retirer une couche et modifier sa visibilité\n\n\n\nDans les diapos, on a vu que addLayer() et removeLayer() permettent d’ajouter/retirer une couche de la carte. C’est pratique dans plein de cas, mais pas vraiment dans celui d’un menu d’affichage. En effet, quand on rajoute, une couche, elle viendra forcément se placer par-dessus les autres.\nPour conserver l’ordre de nos couches (défini par l’ordre dans lequel on les a ajoutées à la carte), on va plutôt les rendre visibles ou les masquer.\n\n\n\n\n\n\n\n🤔 On doit d’abord se demander comment s’y prendre pour masquer une couche dans OpenLayers.\nOn va se servir des méthodes qui sont disponibles pour tous les objets Layer de OpenLayers. La documentation nous apprend l’existence de la méthode setVisible(). Voilà ce qu’on nous en dit :\n\n\n\n\n\nLa méthode setVisible() prend un argument visible. Cet argument est de type “boolean”, il peut donc prendre la valeur true ou false. On va faire le test et utiliser cette fonction pour faire disparaître notre couche. Allez dans main.js et ajouter cette ligne à la fin de votre script.\nAttention ! layerDealsByCountry est le nom de la variable dans laquelle j’ai créé ma couche “deals_by_country”. Si vous avez nommé votre couche différemment, n’oubliez pas de changer le nom !\nlayerDealsByCountry.setVisible(false);\nNormalement, la couche ne devrait plus être visible sur la carte. Super, la méthode a fonctionné ! Il ne nous reste plus qu’à “connecter” cette méthode à notre élément checkbox.\nOn a déjà vu qu’il est possible de trouver un élément HTML et de le modifier en utilisant du JavaScript. Pour trouver un élément, le plus facile est de rechercher son identifiant id. Ajoutez en bas de main.js :\nconst checkboxCountries = document.getElementById('checkbox-countries');\nconsole.log(checkboxCountries);\nSauvegardez et allez dans la console de votre navigateur. Vous devriez voir apparaître votre tag &lt;input&gt; dans la console. Si vous le survolez avec la souris, la checkbox devrait être passée en surbrillance. Si ça fonctionne, parfait ! Ça veut dire qu’on arrive bien à récupérer notre élément de checkbox. Maintenant, on souhaite exécuter du code lorsque son statut “checked” change. Pour cela, on doit “écouter” la checkbox pour savoir si l’évènement “change” a eu lieu.\nconst checkboxCountries = document.getElementById('checkbox-countries');\n\ncheckboxCountries.addEventListener('change', (event) =&gt; {\n  if (event.currentTarget.checked) {\n    // On fait des trucs quand la checkbox est checkée\n    console.log(\"Checked\");\n  } else {\n    // On fait des trucs quand la checkbox n’est PAS checkée\n    console.log(\"Pas checked\");\n  }\n});\n\naddEventListener indique qu’on souhaite “écouter” les évènements de notre checkbox. On précise le type d’évènement avec le premier paramètre, 'change'.\nLa condition if vérifie si notre checkbox est checkée ou non. On récupère cette information grâce à event.current.checked. Si cette condition est true, on affiche “Checked” dans la console. Si cette condition est false, on affiche “Pas checked”.\n\nEssayez ! Cliquez sur la checkbox et surveillez votre console. On voit bien s’afficher les messages. On y est presque ! Maintenant, au lieu d’afficher du texte, on souhaite afficher la couche quand la condition est true et la masquer quand la condition est false.\nconst checkboxCountries = document.getElementById('checkbox-countries');\n\ncheckboxCountries.addEventListener('change', (event) =&gt; {\n  if (event.currentTarget.checked) {\n    // On fait des trucs quand la checkbox est checkée\n    layer_deals_by_country.setVisible(true);\n  } else {\n    // On fait des trucs quand la checkbox n’est PAS checkée\n    layer_deals_by_country.setVisible(false);\n  }\n});\n\n\n\n\n\n\nPensez bien à…\n\n\n\n\nChanger le nom de la couche layerDealsByCountry si vous n’avez pas appelé votre couche comme ça.\nSupprimer la ligne layerDealsByCountry.setVisible(false); toute seule au dessus ou votre couche sera masquée par défaut au moment de charger la carte.\n\n\n\nVoilà, on peut désormais afficher et masquer la couche à volonté !\n\n\n\n\n\nÀ vous ! Créez une autre checkbox qui permet d’afficher ou masquer la couche deals. J’aimerais que cette checkbox soit au-dessus de la première !\n\n\n\n\n\n\nTip\n\n\n\nSauf indication contraire (via du CSS), les éléments HTML sont affichés dans l’ordre dans lequel ils sont déclarés.\n&lt;div id=\"2\"&gt;&lt;/div&gt;\n&lt;div id=\"1\"&gt;&lt;/div&gt;\nDans cet exemple, ma div 1 sera plus bas que ma div 2. Ça devrait vous aider !\n\n\n\n\nInterroger une couche WMS et afficher les résultats\nOn souhaite maintenant interroger la couche deals en cliquant dessus. Cette étape est plus compliquée que la précédente car elle va nous demander d’utiliser fetch(). Normalement vous l’avez déjà abordé dans un autre cours, mais on va procéder petit à petit pour bien comprendre ce qu’on fait. Ouvrez l’exemple OpenLayers WMS GetFeatureInfo (Image Layer).\nCommençons par s’intéresser à cette partie du code :\nmap.on('singleclick', function (evt) {\n  document.getElementById('info').innerHTML = '';\n  const viewResolution = /** @type {number} */ (view.getResolution());\n  const url = wmsSource.getFeatureInfoUrl(\n    evt.coordinate,\n    viewResolution,\n    'EPSG:3857',\n    {'INFO_FORMAT': 'text/html'},\n  );\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((html) =&gt; {\n        document.getElementById('info').innerHTML = html;\n      });\n  }\n});\n\n.on('singleclick') permet d’exécuter une fonction lorsqu’on clique sur la carte.\ndocument.getElementById() récupère l’élément ‘info’ dans lequel ils affichent leurs résultats.\nOn récupère la résolution de la vue de la carte grâce à la méthode dans viewResolution. On a besoin de passer cette résolution dans la fonction suivante.\nOn récupère l’url qui contient les informations de l’élément cliqué avec la méthode getFeatureInfoUrl() de la source de données.\nSi notre url est définie, alors on utilise la fonction fetch() pour récupérer la donnée à partir de cette adresse.\ndocument.getElementById() récupère à nouveau l’élément ‘info’ et définir la valeur de son innerHTML pour pouvoir afficher les résultats.\n\nCompliqué ? Non, ça va aller ! On va tranquillement réécrire cette fonction pour la couche deals. Pour rappel, voici comment j’appelle la couche deals dans mon code :\nconst sourceDeals = new ImageWMS({\n  url: geoserverWms,\n  params: { 'LAYERS' : 'land_matrix:deals' },\n  serverType: 'geoserver',\n});\n\nconst layerDeals = new ImageLayer({\n  source: sourceDeals\n});\nJe commence donc par exécuter une fonction lorsque je clique sur la carte :\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"J’ai cliqué sur la carte !\");\n});\nSauvegardez, gardez la console de votre navigateur ouverte et cliquez sur la carte pour vérifier que le message apparaît bien. Si c’est bon, on vient d’apprendre comment exécuter des fonctions en cliquant sur la carte ! On sait ensuite que dans l’exemple ils utilisent la méthode getFeatureInfoUrl() de leur source de données pour récupérer les informations des features. Ouvrez la documentation de ImageWMS, on va en avoir besoin. Voilà ce qu’elle nous dit au sujet de la méthode getFeatureInfoUrl() :\n\n\n\n\n\nLa méthode prend plusieurs paramètres :\n\ncoordinate, les coordonnées visées par le clic de l’utilisateur (on les a appelées dans l’exemple du cours)\nresolution, la résolution de la carte (liée à la view de ma carte)\nprojection, le système de projection de la carte : “EPSG:3857’”\nparams, un objet contenant plusieurs paramètres comme le format désiré du résultat ou encore les couches qu’on souhaite interroger\n\nRécupérons ces éléments dans l’ordre en commençant par les coordonnées. Dans l’exemple, ils référencent directement la source de coordonnées evt.coordinate dans la fonction… mais ça va un peu vite. Pour mieux comprendre, on va stocker les coordonnées de notre évènement (= notre clic) dans une constante.\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"J’ai cliqué sur la carte !\");\n  \n  const coord = event.coordinate;\n});\nEn fait, l’évènement ‘singleclick’ de la carte map permet de récupérer les coordonnées du clic en accédant à sa propriété coordinate. On écrit donc event.coordinate.\n\n\n\n\n\n\nPourquoi on a “event” et pas “evt” ?\n\n\n\n\n\nJ’ai fait exprès de changer le nom du paramètre pour appeler tous les évènements “event” dans notre code et pour ajouter cette petite note. En fait, quand on crée une fonction, on peut nommer notre paramètre comme on veut. Par exemple, dans le code suivant :\nmap.on('singleclick', (event) =&gt; {\n  const coord = event.coordinate;\n});\n… la variable coordinates a la même valeur que si j’écris :\nmap.on('singleclick', (evt) =&gt; {\n  const coord = evt.coordinate;\n});\n… ou encore :\nmap.on('singleclick', (monEvenementQuiVientDeMaCarteQuandJeClique) =&gt; {\n  const coord = monEvenementQuiVientDeMaCarteQuandJeClique.coordinate;\n});\nBien sûr, si vous ne vous sentez pas encore trop en confiance, inutile de renommer ce genre d’éléments pour uniformiser le code. Vous pouvez garder ce que vous voyez dans le code OpenLayers.\n\n\n\nAprès les coordonnées, on récupère la résolution. On sait qu’on lit la résolution depuis la vue de la carte, donc on peut d’abord récupérer cette vue PUIS lire sa résolution (toujours dans notre fonction, pas à l’extérieur !) :\nconst view = map.getView();\nconst res = view.getResolution();\nOn peut aussi enchaîner les méthodes comme ceci :\nconst res = map.getView().getResolution();\n\n\n\n\n\n\nPourquoi on ne reprend pas le /** @type */ du code original ?\n\n\n\n\n\nParce qu’on n’en est pas à faire du TypeScript ! Ils ont fait un excès de zèle dans cet exemple. Cette syntaxe étrange signifie que le type de la constante est de type “number”, donc un nombre. C’est une info qu’on retrouve aussi dans la documentation.\n\n\n\nOn est à mi-chemin et le reste est très simple. La projection doit être indiquée par une chaîne de caractères :\nconst proj = 'EPSG:3857';\nEt on reprend les paramètres de l’exemple pour indiquer qu’on veut récupérer notre réponse au format HTML. Par défaut, GeoServer renverra la table attributaire de l’élément sous forme d’un tableau en HTML.\nconst parametres = {'INFO_FORMAT': 'text/html'};\nOn a tous nos éléments, il ne nous reste qu’à appeler la méthode getFeatureInfoUrl() sur notre source de données (attention, pas la couche !) pour générer l’url qui nous permettra de récupérer la réponse. La documentation nous indique que les paramètres doivent être renseignés dans l’ordre suivant :\n\ncoordinate\nresolution\nprojection\nparams\n\nconst url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\nOu encore, pour ressembler à l’exemple :\nconst url = sourceDeals.getFeatureInfoUrl(\n  coord,\n  res,\n  proj,\n  parametres\n);\nPour récapituler, voilà à quoi ressemble ma fonction pour le moment. J’ai ajouté un console.log() pour voir l’url s’afficher dans ma console et donc bien vérifier que j’arrive à générer cette adresse.\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"J’ai cliqué sur la carte !\");\n\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n  const parametres = {'INFO_FORMAT': 'text/html'};\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  console.log(url);\n});\nAttention, voilà la partie plus compliquée : maintenant qu’on a une addresse, on doit utilier la fonction fetch() pour récupérer la donnée. C’est une fonction bien particulière. Elle est dite “asynchrone” car elle ne bloque pas le reste du code lorsqu’elle tourne, contrairement aux autres fonctions “synchrones”. Si j’écris une fonction reboursSynchrone(), l’exécution de mon code et donc mon application est bloquée pendant que la fonction de mon compte à rebours s’exécute. Si c’est quasiment instantané, ça ne pose pas de problème. Si c’est quelque chose de plus lent, par exemple un compte à rebours de dix secondes ou bien attendre la réponse d’un serveur dans le cas de notre fetch, notre application est bloquée et on est bien embêtés. Au contraire, si j’écris une fonction reboursAsynchrone() l’application n’attendra pas que la fonction ait terminé son compte à rebours pour pouvoir continuer de faire des trucs.\nDu coup, l’asynchrone, c’est très pratique ! Par contre, comme c’est particulier et qu’il est plus difficile de prévoir quand elle va terminer son exécution et si elle va rencontrer des erreurs ou non, on va devoir lui réserver un traitement particulier. Reprenons le code de l’exemple pour l’expliquer petit à petit.\nfetch(url)\n  .then((response) =&gt; response.text())\n  .then((html) =&gt; {\n    // J’ai modifié la ligne suivante pour simplifier, on s’intéressera à elle un peu plus tard\n    console.log(\"C’est une réussite !\");\n  });\nVous noterez l’utilisation de méthodes .then() qui contiennent des fonctions. Ce sont les fonctions à exécuter quand le maillon précédent de la chaîne a fini de se résoudre. Si on devait écrire en langage courant ce que signifie ce code, voilà ce que ça donnerait :\n\nfetch(url) → “Récupère les informations qui sont disponibles à cette adresse”\n.then((response) =&gt; response.text()) → “Ensuite (”then”), quand tu as réussi à récupérer la réponse, stocke-la dans une variable que j’appelle “response” puis utilise sa méthode .text() pour récupérer du texte au format HTML”\n.then((html) =&gt; { console.log(\"C’est une réussite !\"); }) → “Ensuite, quand tu as réussi l’étape précédente, stocke le texte au format HTML de l’étape précédente dans une variable que j’appelle”html” et affiche un message dans ma console”\n\nVous noterez que j’ai précisé que .then() s’exécute si l’étape précédente a réussi. Si ce n’est pas le cas, l’exécution de notre chaîne de méthodes fetch() s’arrête et un message d’erreur s’affiche dans la console. Comme on a plutôt confiance en notre GeoServer, on peut se lancer et exécuter ce fetch() mais attention, seulement si on a bien une addresse à interroger ! Si la variable url est undefined, notre application risque de péter les plombs. On ajoute une condition autour du fetch() pour éviter les erreurs :\nif (url) {\n  fetch(url)\n    .then((response) =&gt; response.text())\n    .then((html) =&gt; {\n      console.log(\"C’est une réussite !\");\n      console.log(html);\n    });\n}\nVous pouvez tester les console.log(). Le HTML qu’on obtient n’est pas très gracieux tel quel, il vaudrait mieux l’afficher dans l’interface de l’application !\n\n\n\n\n\n\nAu secours, je n’ai toujours pas compris fetch()\n\n\n\n\n\n\n\n\n\n\nSi votre cerveau est un peu comme ça quand on parle de fetch(), n’hésitez pas à m’appeler pour avoir une nouvelle explication. J’ai peur de ne pas pouvoir faire mieux par écrit. La notion de fonction asynchrone est complexe et j’ai mis pas mal de temps à la comprendre, donc en deux minutes en plein milieu d’un TP c’est encore pire.\nSinon, vous pouvez continuer le TP, on aura d’autres occasions d’utiliser fetch(). Peut-être que les autres exemples seront plus clairs !\n\n\n\nQuand on doit afficher un nouvel élément dans l’interface, il faut toujours penser à créer une nouvelle balise HTML (souvent une &lt;div&gt;) pour le mettre à l’intérieur. Comme pour l’exemple précédent, on crée une div dans le HTML. Je place la mienne après &lt;div id=\"layers\"&gt; et je remets n’importe quoi dedans juste pour la voir dans mon interface.\n&lt;div id=\"attributes\" class=\"menu\"&gt;cthulhu ftaghn&lt;/div&gt;\nSauvegardez et regardez l’application. Et là, horreur ! Notre menu de couches est remplacé par la nouvelle div qu’on vient de créer ! C’est normal, elles ont le même style car on a aussi appelé class=\"menu\" dans la div. Le problème, c’est que dans styles.css, on voit que tous nos menus sont positionnés au même endroit : regardez top et right.\n.menu {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  right: 20px;\n\n  /* Padding */\n  padding: 8px;\n\n  /* Dimensions minimales */\n  min-height: 80px;\n  min-width: 160px;\n\n  /* Rectangle blanc avec coins arrondis */\n  background-color: white;\n  border-radius: 8px;\n}\nOn va donc devoir positionner nos deux &lt;div&gt; indépendamment l’une de l’autre. Pour les sélectionner individuellement, on peut utiliser le sélecteur # qui permet de chercher par id. Voilà mon code :\n.menu {\n  /* Padding */\n  padding: 8px;\n\n  /* Dimensions minimales */\n  min-height: 80px;\n  min-width: 160px;\n\n  /* Rectangle blanc avec coins arrondis */\n  background-color: white;\n  border-radius: 8px;\n}\n\n#layers {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  right: 20px;\n}\n\n#attributes {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  left: 20px;\n}\nVoilà, maintenant .menu me permet de définir un padding, des dimensions minimales, une couleur de background et des coins arrondis pour tous mes éléments avec la classe class=\"menu\", mais par contre j’ai bien positionné indépendamment mon menu de layers et ma nouvelle div attributes.\nMaintenant, modifiez le style de #attributes pour l’afficher en bas de la carte et sur toute la largeur de l’écran. Il nous faut beaucoup d’espace pour afficher notre table.\nC’est bon, vous avez une &lt;div id=\"attributes\"&gt; qui vous plaît ? Vous pouvez supprimer le texte qui était dans la div, on n’en aura plus besoin. Maintenant, on cherche à dire à notre application : “Prends le texte HTML que je récupère grâce à ma fonction et mets-le dans ma div Attributes”. On a formulé notre idée en langage naturel, on va maintenant pouvoir l’écrire en JavaScript. D’abord, on se demande à quel endroit dans notre code on récupère ce HTML. Souvenez-vous :\n// Interroger la couche deals et afficher les résultats\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"J’ai cliqué sur la carte !\");\n\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n  const parametres = {'INFO_FORMAT': 'text/html'};\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((html) =&gt; {\n        // Dans cette fonction, on a accès à notre \"html\" !\n        console.log(\"C’est une réussite !\");\n        console.log(html);\n      });\n  }\n});\nVous voyez mon commentaire ? C’est dans cette fonction qu’on va écrire notre code. Zoomons sur cette petite partie :\n      .then((html) =&gt; {\n        // Dans cette fonction, on a accès à notre \"html\" !\n        console.log(\"C’est une réussite !\");\n        console.log(html);\n      });\nSi je traduis le texte précédent en langage naturel, pour rappel, ça fait :\n\nQuand tu as réussi l’étape précédente (souvenez-vous de then), alors stocke le résultat dans une variable html et :\nAffiche “C’est une réussite !” dans ma console, puis :\nAffiche le contenu du HTML dans ma console\n\nOn aimerait remplacer les deux dernières étapes par “affiche le HTML dans mon interface”. Pour cela, on utilise la ligne de code suivante (à ajouter au bon endroit dans la fonction, à vous de jouer) :\ndocument.getElementById('attributes').innerHTML = html;\nSuper, vous savez maintenant requêter une couche WMS ! Le résultat est un peu moche pour le moment mais vous pourrez revenir plus tard pour l’affiner.\n\n\nFiltrer des couches WMS\nOn a vu dans l’étape précédente qu’il était possible de requêter une couche WMS. Vous ne serez donc pas surpris d’apprendre qu’il est aussi possible de filtrer ces couches ! Les flux WMS ont beau nous renvoyer une image, on sait maintenant qu’elles ne manquent pas d’interactivité.\nGeoServer permet d’ajouter des filtres écrits au format SQL à la requête pour lui dire “applique ce filtre à ma couche avant de m’envoyer le résultat”. Le filtrage se fait donc du côté du serveur. Vous pouvez trouver les spécifications WMS avec cql_filter ici et le tutoriel de filtrage là mais comme c’est une notion un peu complexe à appliquer seul, on va une fois de plus procéder étape par étape ensemble.\nDans votre GeoServer, prévisualisez la couche deals et cliquez sur les ... bleus en haut à gauche de la carte. Vous devriez voir plusieurs nouvelles options apparaître dont une qui s’appelle “Filter:”. L’option “CQL” devrait déjà être sélectionnée, gardez-la. C’est ce qu’on va utiliser pour la suite.\n\n\n\n\n\nCollez le texte suivant dans le champ CQL et cliquez sur “Appliquer” :\ndeal_size &gt; 10000\nNormalement, vous avez vu certains points disparaître. Il ne vous reste plus que les deals de plus de 10 000 hectares. Si vous avez un doute, vous pouvez vérifier en cliquant sur les points pour afficher leurs attributs. C’est facile, non ? Essayez les filtres suivant et essayez de comprendre à quoi ils peuvent servir :\nsilver = true\ntarget_country = 'Argentina'\ntarget_country = 'Argentina' OR target_country = 'Philippines'\n\n\n\n\n\n\nImportant\n\n\n\nQuand vous écrivez des chaînes de caractères (“string”) dans un filtre CQL, il faut impérativement utiliser les guillemets simples 'my_string' et pas les doubles \"my_string\".\nNe me demandez pas pourquoi, ce n’est pas expliqué, il faut juste l’accepter et vivre avec.\n\n\nBien, vous savez maintenant écrire un filtre simple en CQL, mais comment est-ce qu’on fait pour filtrer la couche depuis notre application OpenLayers ? Voici mon code pour appliquer à ma couche deals un filtre qui va uniquement récupérer les mines qui se trouvent en Argentine (Argentina) ou aux Philippines (Philippines). Comparez ce snippet avec votre code pour comprendre où mettre ce code et ce qu’il fait :\nconst sourceDeals = new ImageWMS({\n  url: geoserverWms,\n  params: {\n    'LAYERS' : 'land_matrix:deals',\n    \"CQL_FILTER\" : \"target_country = 'Argentina' OR target_country = 'Philippines'\",\n  },\n  serverType: 'geoserver',\n});\n\n\n\n\n\n\nImportant\n\n\n\nSi vous vous êtes contenté de copier-coller tout ça dans votre code, c’est sûrement raté ! Il faut regarder mon snippet de code pour comprendre ce que vous devez ajouter à votre code existant !\n\n\nSauvegardez et regardez votre carte. Si vous avez compris ce que fait mon CQL, vous devriez rapidement être capables de dire si le filtre a fonctionné ou non. Vous voyez, filtrer un flux WMS, c’est facile !\nMaintenant, modifiez votre code pour afficher uniquement des mines qui produisent de l’or. Je vous donne deux indices : regardez la table attributaire de la couche deals et souvenez vous que “or” se dit “Gold” en anglais. Pour ceux qui ont eu des consoles portables, il y a une licence vidéoludique bien pratique pour retenir des noms de minéraux en anglais :\n\n\n\n\n\n(Si vous êtes capable d’entendre ce GIF juste en le regardant, vous commencez à être vieux aussi, désolée. Quoi qu’il en soit, j’espère que les interruptions GIFs vous font un peu décompresser.)\nMaintenant que vous savez filtrer la couche, vous pouvez ajouter un peu plus d’interactivité à votre carte. On va afficher un menu avec des boutons de type “radio” pour sélectionner des filtres. Je vous fais un schéma moche à la main pour vous aider à comprendre.\n\n\n\n\n\nVous voyez où on veut en venir ? Comme on commence à avoir l’habitude de faire des menus, je vous laisse créer et positionner celui-ci avec un peu de HTML et de CSS et on passe directement à l’ajout des boutons. On va devoir mettre dans notre élément &lt;div&gt; plusieurs boutons radio avec la balise &lt;input type=\"radio\"&gt;. Voilà le code pour les éléments “Or” et “Argent” :\n    &lt;!-- Radio button menu - production --&gt;\n    &lt;div id=\"production\" class=\"menu\"&gt;\n  \n      &lt;div&gt;\n        &lt;input type=\"radio\" id=\"button-gold\" name=\"produce\" value=\"gold\" /&gt;\n        &lt;label for=\"gold\"&gt;Or&lt;/label&gt;\n      &lt;/div&gt;\n  \n\n      &lt;div&gt;\n        &lt;input type=\"radio\" id=\"button-silver\" name=\"produce\" value=\"silver\" /&gt;\n        &lt;label for=\"silver\"&gt;Argent&lt;/label&gt;\n      &lt;/div&gt;\n\n    &lt;/div&gt;\nVous noterez plusieurs choses :\n\n&lt;input&gt; et &lt;label&gt; vont par paires\nla balise &lt;label&gt; contient le nom en français de mon élément, c’est ce qui s’affiche dans l’application\ntoutes les balises &lt;input&gt; on la même propriété name=\"produce\", on dirait donc qu’il vaut mieux continuer dans ce sens\non a une propriété id unique à chaque &lt;input&gt; qui nous permettra, au besoin, d’aller les chercher avec du JavaScript\nla propriété value de mes &lt;input&gt; semble correspondre à des colonnes de la table attributaire de ma couche\n\nAvec ces éléments, ajoutez les boutons pour Charbon, Lithium et Cobalt comme indiqués sur mon schéma plus haut. Attention à bien mettre Charbon en haut, comme sur l’exemple ! Quand c’est terminé, allez sur votre carte et cliquez un peu sur ces boutons radio. Normalement, vous ne pouvez pas sélectionner plus d’un seul élément à la fois au sein du groupe. Votre application sait que tous ces boutons font partie du même groupe car vous leur avez tous donné la même valeur name=\"produce\". Si vous commencez à modifier cette valeur, votre carte va commencer à se comportez bizarrement.\nUne fois que votre menu est prêt, bien positionné sur la carte et que vos cinq boutons radio fonctionnent, on va pouvoir passer au JavaScript. Comme d’habitude, on va exprimer notre besoin en langage naturel : “Lorsque je sélectionne un minéral, je souhaite modifier le filtre de ma couche deals pour récupérer uniquement les deals qui produisent les minéraux sélectionnés”.\nPour rappel, voici les éléments dont on dispose :\n\non a des boutons radio avec une valeur value qui correspond à une colonne de la table attributaire\nvous avez déjà une couche qui filtre les deals qui produisent de l’or avec un filtre CQL\nle filtre CQL est tout simplement une chaîne de caractères (string)\n\nLe résultat auquel on voudrait arriver, c’est donc : “Mon CQL dans les params de la source de ma couche deals change dès que je sélectionne un nouveau minéral”.\nÇa tombe bien ! La documentation de la source ImageWMS (celle qu’on utilise pour notre couche) nous apprend qu’il existe une méthode .updateParams() qui permet de mettre à jour les paramètres d’une couche.\nCommencez par ajouter ces deux éléments en bas de main.js. Souvenez-vous de la manière dont on a “écouté” notre checkbox du premier exercice de ce TP. Le code ressemble beaucoup, non ?\nconst buttonGold = document.getElementById('button-gold');\n\nbuttonGold.addEventListener('change', () =&gt; {\n  console.log(\"Test\");\n});\nVoici ce que font les deux éléments du code :\n\nla première ligne récupère mon bouton radio qui grâce à son identifiant en utilisant la méthode .getElementById() que vous avons déjà vue précédemment\nles trois lignes suivantes nous permettent d’écouter notre bouton radio grâce à .addEventListener() et d’exécuter une fonction quand le bouton radio est coché, et la fonction affiche “Test” dans la console de développement\n\nOn y est presque. On arrive à exécuter quelque chose quand on sélectionne “Or” dans notre carte, mais ça ne nous permet pas de filtrer la couche. On va retirer notre console.log() et demander à JavaScript de modifier les paramètres de la source de notre couche deals grâce à la ligne suivante :\nsourceDeals.updateParams({ 'CQL_FILTER' : 'gold=true' });\nPour rappel, la source de mes deals est stockée dans la variable sourceDeals mais attention, il est possible que la votre porte un autre nom. Pensez à vérifier !\nHistoire de pouvoir tester au moins avec les boutons “Or” et “Argent”, je vous donne un snippet de code plus complet.\n// Or\nconst buttonGold = document.getElementById('button-gold');\nbuttonGold.addEventListener('change', () =&gt; {\n  // Quand l’utilisateur clique sur le bouton \"Or\", je mets à jour mon filtre CQL\n  sourceDeals.updateParams({ 'CQL_FILTER' : 'gold=true' });\n});\n\n// Argent\nconst buttonSilver = document.getElementById('button-silver');\nbuttonSilver.addEventListener('change', () =&gt; {\n  sourceDeals.updateParams({ 'CQL_FILTER' : 'silver=true' });\n});\nTestez l’application en cliquant alternativement sur les boutons radio de Or et Argent. Si les deux couches sont différentes, super, ça fonctionne !\nMaintenant que vous avez compris comment faire, faites la même chose pour toutes les autres options de filtrage de vos boutons radio.\nQuand vous avez terminé, rajoutez une option “Tous” avec la valeur value=\"all\" et faites en sorte qu’il affiche tous les deals (je vous ai mis des indices ci-dessous si vous avez du mal mais essayez d’abord de réfléchir sans)\n\n\n\n\n\n\nIndice 1 - ajouter l’option “Tous” dans mon menu\n\n\n\n\n\nSouvenez vous : si vous voulez ajouter un élément à l’interface, commencez par index.html.\n\n\n\n\n\n\n\n\n\nIndice 2 - filtrer “Tous”\n\n\n\n\n\nComme on écrit du code JavaScript, on doit le faire dans main.js. Comme pour les autres options, vous pouvez récupérer le bouton radio avec .getElementById() puis l’écouter avec .addEventListener().\nPour ce qui est du filtre CQL : si on veut tous les deals, il suffit que notre filtre soit vide. Donc vous devriez avoir quelque part une chaîne de caractères (string) vide.\n\n\n\nUne fois que c’est terminé, bravo ! Vous avez un super menu fonctionnel pour votre couche. Vous avez maintenant un bon bagage pour comprendre comment ajouter de l’interaction entre votre application, les flux qu’elle lit et l’interface. C’est donc la fin de ce TP, merci pour votre attention !",
    "crumbs": [
      "Interactions carte-interface"
    ]
  },
  {
    "objectID": "cours/geonum/08_cours_enrichir_ma_carte.html",
    "href": "cours/geonum/08_cours_enrichir_ma_carte.html",
    "title": "Enrichir ma carte",
    "section": "",
    "text": "Cette fois, c’est nous qui définissions les objectifs petit à petit en fonction de nos besoins.",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "cours/geonum/08_cours_enrichir_ma_carte.html#objectifs-de-la-session",
    "href": "cours/geonum/08_cours_enrichir_ma_carte.html#objectifs-de-la-session",
    "title": "Enrichir ma carte",
    "section": "",
    "text": "Cette fois, c’est nous qui définissions les objectifs petit à petit en fonction de nos besoins.",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "cours/geonum/08_cours_enrichir_ma_carte.html#supports",
    "href": "cours/geonum/08_cours_enrichir_ma_carte.html#supports",
    "title": "Enrichir ma carte",
    "section": "Supports",
    "text": "Supports\nAujourd’hui, c’est de la pratique. M’entendre parler pendant des heures, c’est fini !",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "cours/geonum/08_cours_enrichir_ma_carte.html#tp-ajouter-une-table-attributaire-personnalisée",
    "href": "cours/geonum/08_cours_enrichir_ma_carte.html#tp-ajouter-une-table-attributaire-personnalisée",
    "title": "Enrichir ma carte",
    "section": "TP – Ajouter une table attributaire personnalisée",
    "text": "TP – Ajouter une table attributaire personnalisée\n\n\n\n\n\n\nPour bien démarrer le TP…\n\n\n\nCe TP part du principe que vous avez suivi les précédents. Si ce n’est pas le cas, il manquera des éléments importants dans votre code. Les exercices suivants partent du principe que vous avez déjà affiché vos couches, il faudrait donc au moins que celles-ci soient fonctionnelles pour la suite !\n\n\nOn va se réintéresser à notre couche WMS “deals” et à sa table attributaire (session “Interactions carte-interface). Je vous remets notre code ici pour vous rappeler quels éléments permettent de récupérer la table attributaire. Attention au nom de vos couches et de vos sources, ce ne sont peut-être pas les mêmes que les miens !\nmap.on('singleclick', (event) =&gt; {\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n  const parametres = {'INFO_FORMAT': 'text/html'};\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((html) =&gt; {\n        document.getElementById('attributes').innerHTML = html;\n       });\n  }\n});\nFaites attention à cet élément :\nconst parametres = {'INFO_FORMAT': 'text/html'};\nNotez qu’on demande en fait à notre GeoServer de nous donner la réponse de notre requête au format text/html. C’est sympathique, mais difficile à customiser et surtout pas super pratique quand la table attribuaire est LONGUE. Heureusement, on peut récupérer le résultat au format JSON qui sera bien pratique pour customiser notre table.\nComme toujours, quand on souhaite ajouter un nouvel élément à notre carte, il faut qu’on commence par écrire du HTML. On va modifier notre div id=\"attributes\" pour y ajouter une table. Récupérez le code ci-dessous et regardez la différence, vous allez comprendre.\n&lt;div id=\"attributes\" class=\"menu\"&gt;\n    &lt;!-- Je crée une table --&gt;\n    &lt;table&gt;\n&lt;!-- On utilise l’élément tr pour créer une ligne : tr = table row --&gt;\n&lt;tr&gt;\n&lt;!-- On utilise les éléments th (table header) pour créer les headers de nos trois colonnes --&gt;\n&lt;th&gt;Deal ID&lt;/th&gt;\n&lt;th&gt;Creation date&lt;/th&gt;\n&lt;th&gt;Country&lt;/th&gt;\n&lt;/tr&gt;\n&lt;!-- On utilise l’élément tr pour créer une AUTRE ligne : tr = table row --&gt;\n&lt;tr&gt;\n&lt;!-- On crée trois colonnes vides avec td --&gt;\n&lt;td&gt;…&lt;/td&gt;\n&lt;td&gt;…&lt;/td&gt;\n&lt;td&gt;…&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n&lt;/div&gt;\nVous devriez maintenant voir apparaître une table dans votre div. Elle est austère, d’accord, mais vous pourrez la styliser après. Pour le moment, on va faire avec. Regardez bien mes commentaires pour comprendre comment est structuré le code ainsi que ces trois éléments :\n      &lt;td&gt;…&lt;/td&gt;\n      &lt;td&gt;…&lt;/td&gt;\n      &lt;td&gt;…&lt;/td&gt;\nVous comprenez sûrement qu’on souhaite remplacer ces “…” par des valeurs lorsqu’on clique sur un point de la couche. Il va donc falloir modifier cet élément HTML avec nos fonctions JavaScript. Souvenez-vous qu’on utilise les identifiants pour retrouver les éléments HTML avec .getElementById(). Donc :\n      &lt;td id=\"table-deal-id\"&gt;…&lt;/td&gt;\n      &lt;td id=\"table-creation-date\"&gt;…&lt;/td&gt;\n      &lt;td id=\"table-country\"&gt;…&lt;/td&gt;\nMaintenant qu’on a nos éléments, il va falloir les remplir. Retournez chercher votre méthode map.on() dans votre code, on va devoir l’améliorer un peu.\nmap.on('singleclick', (event) =&gt; {\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n\n  const parametres = { 'INFO_FORMAT': 'application/json' } // On a changé un truc ici\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((json) =&gt; { // On a aussi changé un truc ici et dans la fonction\n        const obj = JSON.parse(json);\n        console.log(obj);\n      });\n  }\n});\nTestez votre couche et regardez le résultat dans la console. Si tout a fonctionné, vous devriez voir un objet JavaScript ! Prenez le temps de l’explorer dans votre console pour comprendre ce que vous regardez. L‘information qui nous intéresse est quelque part dans features. Voilà ce qu’on doit faire avec la donnée :\n\nvérifier qu’on a bien cliqué sur une feature sur la carte (en JavaScript, ça demande de vérifier qu’on a bien de la donnée dans features)\nrécupérer la feature sur laquelle j’ai cliqué pour pouvoir accéder à ses properties\nrécupérer mes cellules pour remplacer leur contenu\nremplacer le contenu des cellules de ma table avec les properties\n\nOn va procéder petit à petit. D’abord, on vérifie qu’on a bien une feature dans feature :\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((json) =&gt; { // On a aussi changé un truc ici et dans la fonction\n        const obj = JSON.parse(json);\n        if (obj.features[0]) {\n          console.log(\"J’ai cliqué sur une feature !\");\n        } else {\n          console.log(\"J’ai cliqué à côté…\");\n        }\n      });\n  }\nOn utilise une condition if pour tester la présence d’une feature dans obj. obj.features[0] peut se traduire par : “Récupère mon tableau feature de mon obj et prends le premier élément”. La condition regarde simplement si feature[0] est vide ou non. Si ce n’est pas vide, on a reçu quelque chose, on a donc cliqué sur une feature. Au contraire, si c’est vide, c’est qu’on a cliqué à côté. Testez la fonction avant de passer à la suite.\nSi on a bien récupéré une feature, cela veut dire qu’on peut récupérer ses properties. Il suffit d’ajouter au bon endroit de la fonction les deux lignes suivantes :\nconst properties = obj.features[0].properties;\nconsole.log(properties);\nVous commencez à comprendre comment on accède à un élément dans un objet JavaScript. Il suffit d’appeler la propriété qu’on veut avec .&lt;propriété&gt;. Regardez comment est structuré votre objet properties dans la console du navigateur. Maintenant, modifiez la ligne console.log(properties); pour afficher la propriété target_country. Quand c’est réussi, passez à la suite !\nTrès bien, on sait maintenant récupérer des propriétés. Il ne nous reste plus qu’à modifier le HTML de notre document en conséquence en utilisant .innerHTML ! Je vous donne le code pour la colonne deal_id et je vous laisse compléter le code pour les deux autres colonnes.\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((json) =&gt; {\n        const obj = JSON.parse(json);\n        if (obj.features[0]) {\n          console.log(\"J’ai cliqué sur une feature !\");\n          const properties = obj.features[0].properties;\n          console.log(properties);\n          // On affiche deal_id dans notre table\n          document.getElementById('table-deal-id').innerHTML = properties.deal_id;\n        } else {\n          console.log(\"J’ai cliqué à côté…\");\n          // On a cliqué \"nulle part\" donc on remet des … dans la colonne \"deal_id\"\n          document.getElementById('table-deal-id').innerHTML = \"\";\n        }\n      });\n  }\nTestez votre application. Normalement, ça marche ! Quand vous cliquez sur une feature, vous devriez récupérer son ID. Voilà comment on crée une table customisée pour interroger une couche ! Maintenant, à vous de compléter les deux autres colonnes. Une fois que vous avez réussi, ajoutez une colonne qui montre la valeur de mineral_resources pour le deal sur lequel vous cliquez. Et quand ça aussi ça fonctionne, prenez quelques minutes pour styliser votre table !\n\n\n\nSi vous vous sentez comme ça après cet exercice, c’est normal. Vous venez de passer un très gros morceau, bien joué à vous ! Peu importe l’heure, vous avez gagné le droit d’aller vous chercher le café de la victoire pour vous reposer un peu les neurones.",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "cours/geonum/08_cours_enrichir_ma_carte.html#tp-ajouter-une-échelle",
    "href": "cours/geonum/08_cours_enrichir_ma_carte.html#tp-ajouter-une-échelle",
    "title": "Enrichir ma carte",
    "section": "TP – Ajouter une échelle",
    "text": "TP – Ajouter une échelle\nAllez, on va faire quelque chose qui demande moins de lignes de code pour s’aérer un peu la tête. Je vous colle quelques éléments pour vous aider ici sans trop vous guider, j’estime que vous devriez pouvoir trouver comment faire assez facilement.\nD’abord, voilà un import OpenLayers fort utile :\nimport ScaleLine from 'ol/control/ScaleLine.js';\nUn autre morceau, pour créer l’objet “échelle” :\nconst scaleline = new ScaleLine();\nEt enfin, trouvez comment ajouter ça à votre code existant :\nconst map = new Map({\n  controls: [scaleline],\n});\nEt voilà !\n\n\n\nEt en préparant ce TP, j’ai pu découvrir que la montée d’échelle est un sport qui existe. À vous d’être aussi efficaces avec votre code !",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "cours/geonum/08_cours_enrichir_ma_carte.html#tp-ajouter-un-marqueur-custom",
    "href": "cours/geonum/08_cours_enrichir_ma_carte.html#tp-ajouter-un-marqueur-custom",
    "title": "Enrichir ma carte",
    "section": "TP — Ajouter un marqueur custom",
    "text": "TP — Ajouter un marqueur custom\n…",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "cours/geonum/08_cours_enrichir_ma_carte.html#tp-ajouter-une-popup-ou-un-tooltip",
    "href": "cours/geonum/08_cours_enrichir_ma_carte.html#tp-ajouter-une-popup-ou-un-tooltip",
    "title": "Enrichir ma carte",
    "section": "TP — Ajouter une popup (ou un tooltip)",
    "text": "TP — Ajouter une popup (ou un tooltip)\n…\n\nLa suite est en cours de rédaction. Si vous êtes arrivé⋅e ici, déjà, vous êtes bien curieux⋅se ! Ensuite, profitez-en pour réfléchir à ce dont vous auriez besoin dans votre projet GeoNum pour me demander de préparer de nouveaux exercices.\nSi vous avez déjà des idées, vous pouvez aussi vous lancer ! Je reste disponible pour aider sur quelque chose qui n’a pas forcément été préparé dans mon TP 😃",
    "crumbs": [
      "Enrichir ma carte"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Accueil",
    "section": "",
    "text": "Bienvenue sur mon site en cours de construction. Si vous avez trouvé cette page, vous êtes sûrement un étudiant en master GeoNum. Les ressources pour les TD, c’est par ici !"
  }
]