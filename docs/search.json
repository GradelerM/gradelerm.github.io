[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Dummy blog post TWO\n\n\n\n\n\nSome dummy blog post for pages config\n\n\n\n\n\n1 min\n\n\n\n\n\n\n\nFigures layout\n\n\n\n\n\n\nR\n\n\ntmap\n\n\n\nLayout des figures dans les articles avec Quarto.\n\n\n\n\n\nMar 10, 2025\n\n\nMarie Gradeler\n\n\n1 min\n\n\n\n\n\n\n\nDummy blog post\n\n\n\n\n\n\nR\n\n\ndataviz\n\n\n\nSome dummy blog post for pages config\n\n\n\n\n\nOct 10, 2024\n\n\nMarie Gradeler\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/maps_package.html",
    "href": "posts/maps_package.html",
    "title": "Figures layout",
    "section": "",
    "text": "Classique, on n’ajoute rien.\n\n\n\n\n\n\n\n\n\nOn utilise plus d’espace pour afficher une figure en plus large.\n\n\n\n\n\n\n\n\n\nOn peut aussi afficher les figures dans la marge, il semblerait."
  },
  {
    "objectID": "posts/maps_package.html#test-des-layouts",
    "href": "posts/maps_package.html#test-des-layouts",
    "title": "Figures layout",
    "section": "",
    "text": "Classique, on n’ajoute rien.\n\n\n\n\n\n\n\n\n\nOn utilise plus d’espace pour afficher une figure en plus large.\n\n\n\n\n\n\n\n\n\nOn peut aussi afficher les figures dans la marge, il semblerait."
  },
  {
    "objectID": "cours/geonum/archi_web.html",
    "href": "cours/geonum/archi_web.html",
    "title": "Architecture web",
    "section": "",
    "text": "Comprendre le fonctionnement d’une architecture web classique, la notion de client et de serveur et le fonctionnement d’une requête.\nComprendre la notion de dockerisation et être capable de démarrer des containers avec Docker.\nDécouvrir Docker Compose, un service de Docker pour articuler facilement plusieurs containers entre eux, et savoir faire tourner l’architecture web OpenLayers (Node JS) + GeoServer fournie.",
    "crumbs": [
      "Architecture web"
    ]
  },
  {
    "objectID": "cours/geonum/archi_web.html#objectifs",
    "href": "cours/geonum/archi_web.html#objectifs",
    "title": "Architecture web",
    "section": "",
    "text": "Comprendre le fonctionnement d’une architecture web classique, la notion de client et de serveur et le fonctionnement d’une requête.\nComprendre la notion de dockerisation et être capable de démarrer des containers avec Docker.\nDécouvrir Docker Compose, un service de Docker pour articuler facilement plusieurs containers entre eux, et savoir faire tourner l’architecture web OpenLayers (Node JS) + GeoServer fournie.",
    "crumbs": [
      "Architecture web"
    ]
  },
  {
    "objectID": "cours/geonum/archi_web.html#cours",
    "href": "cours/geonum/archi_web.html#cours",
    "title": "Architecture web",
    "section": "Cours",
    "text": "Cours\nEn cours de rédaction…",
    "crumbs": [
      "Architecture web"
    ]
  },
  {
    "objectID": "cours/geonum/archi_web.html#tp---architecture-de-webcarto-avec-docker",
    "href": "cours/geonum/archi_web.html#tp---architecture-de-webcarto-avec-docker",
    "title": "Architecture web",
    "section": "TP - Architecture de webcarto avec Docker",
    "text": "TP - Architecture de webcarto avec Docker\nEn cours de rédaction…",
    "crumbs": [
      "Architecture web"
    ]
  },
  {
    "objectID": "cours/geonum/slides_cours_1.html#oh-non-cest-vide",
    "href": "cours/geonum/slides_cours_1.html#oh-non-cest-vide",
    "title": "Serveurs Cartographiques",
    "section": "Oh non, c’est vide !",
    "text": "Oh non, c’est vide !\nPas de panique, je suis en train de terminer les slides. Une version complète sera mise en ligne avec la prochaine mise à jour du site."
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html",
    "href": "cours/geonum/serveurs_carto.html",
    "title": "Serveurs cartographiques",
    "section": "",
    "text": "Comprendre ce qu’est un serveur cartographique et ce que sont les flux WMS, WFS, etc.\nConnaître les principaux serveurs cartographiques avec un focus sur GeoServer, un serveur cartographique Open-Source.\nApprendre à déployer une instance de GeoServer à l’aide de Docker.\nPublier des couches avec GeoServer et les styliser en passant par QGIS.\nLire les flux WMS de mon GeoServer dans une application OpenLayers basique.\nÊtre capable de déterminer dans quelles situations on a besoin d’un serveur cartographique.",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#objectifs",
    "href": "cours/geonum/serveurs_carto.html#objectifs",
    "title": "Serveurs cartographiques",
    "section": "",
    "text": "Comprendre ce qu’est un serveur cartographique et ce que sont les flux WMS, WFS, etc.\nConnaître les principaux serveurs cartographiques avec un focus sur GeoServer, un serveur cartographique Open-Source.\nApprendre à déployer une instance de GeoServer à l’aide de Docker.\nPublier des couches avec GeoServer et les styliser en passant par QGIS.\nLire les flux WMS de mon GeoServer dans une application OpenLayers basique.\nÊtre capable de déterminer dans quelles situations on a besoin d’un serveur cartographique.",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#cours",
    "href": "cours/geonum/serveurs_carto.html#cours",
    "title": "Serveurs cartographiques",
    "section": "Cours",
    "text": "Cours\nSlides : Serveurs Cartographiques",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#tp---prise-en-main-de-geoserver",
    "href": "cours/geonum/serveurs_carto.html#tp---prise-en-main-de-geoserver",
    "title": "Serveurs cartographiques",
    "section": "️TP - Prise en main de GeoServer",
    "text": "️TP - Prise en main de GeoServer\n\nDéploiement de GeoServer à l’aide de Docker\nDocumentation GeoServer - Dépôt de l’image Docker\n\n\n\n\n\n\nImportant\n\n\n\nCe TP suppose que Docker est installé sur la machine. Il a été écrit pour une machine Linux, certains chemins et lignes de commande peuvent donc être différents sur une machine Windows ou Mac.\n\n\nUne fois que Docker est installé, lancez la commande suivante pour télécharger une image de GeoServer en version 2.26.0 :\ndocker pull docker.osgeo.org/geoserver:2.26.0\nPuis, pour construire un container à partir de l’image de GeoServer :\ndocker run -it -p 80:8080 docker.osgeo.org/geoserver:2.26.0\nSi vous n’avez pas eu de message d’erreur, rendez-vous sur http://localhost/geoserver et connectez-vous avec l’identifiant admin et le mot de passe geoserver. Si l’authentification a fonctionné, félicitations, vous avez réussi à faire tourner un container avec GeoServer !\n\n\n\n\n\n\nAttends, attends… des containers, des images ? Hein ?\n\n\n\n\n\n\n\n\n\n\nPas de panique ! On n’a pas besoin de savoir exactement comment fonctionne Docker pour ce TP. Si on veut simplifier :\n\nDocker permet de faire tourner des services dans des containers créés à partir d’images.\nUne image est une recette à suivre pour créer mon container. Elle demande à Docker de créer un container basé sur Debian, d’y installer GeoServer ou bien une base PostgreSQL avec l’extension postGIS, etc.\nUn container est le produit d’une image. C’est un peu le plat cuisiné à partir de la recette. C’est à l’intérieur du container que tourne mon service comme ma base de données ou mon serveur web. On peut connecter plusieurs containers entre eux, pratique si on veut un site web et une base de données qui fonctionnent ensemble !\nUn service est généralement une base de données (ex. PostgreSQL), un serveur de site web (ex. Apache), un serveur cartographique (ex. GeoServer), etc. Comme les bonnes pratiques demandent d’avoir un seul service par container, on va parler du “container GeoServer” pour dire “le container qui contient mon service GeoServer”, ça va plus vite.\n\nSi ce n’est encore pas clair et que ça vous gêne pour la compréhension de la suite du TP, hop, on lève la main et on demande des explications, je suis là pour ça ! Et si vous voulez aller plus loin, rendez-vous sur la documentation officelle de Docker.\n\n\n\nPour vérifier que tout fonctionne, on va faire une petite manip rapide.\n\nEn haut à droite de l’écran, si ce n’est pas déjà le cas, sélectionnez le langage “fr” pour passer l’interface en français.\nAllez dans “Espaces de travail” (menu à gauche de l’écran) et cliquez sur le bouton “Ajouter un nouvel espace de travail”.\nAppelez-le “mon_espace” et donnez lui un URI mon_espace.\nVérfiez qu’il apparaît bien dans la liste de vos espaces (normalement, au-dessus de “ne”).\n\nEnsuite, on va arrêter notre container Docker. Commencez par utiliser la commande suivante :\ndocker ps\nVous devriez voir apparaître une ligne avec l’ID de votre container dans la colonne CONTAINER ID, l’image utilisée pour le construire dans la colonne IMAGE, d’autres informations qui ne nous servent pas dans ce TP et son nom dans la colonne NAME. La commande docker ps permet de lister les containers actifs en ce moment. On souhaite arrêter notre container avec la commande docker stop &lt;container_name&gt;. Pour cela, il faut utiliser le nom du container à la place de &lt;container_name&gt;. Par exemple, voici les informations de mon container :\nCONTAINER ID   IMAGE                               COMMAND                  CREATED         STATUS                            PORTS                                     NAMES\n0a885cadf11d   docker.osgeo.org/geoserver:2.26.0   \"bash /opt/startup.sh\"   8 seconds ago   Up 7 seconds (health: starting)   0.0.0.0:80-&gt;8080/tcp, [::]:80-&gt;8080/tcp   charming_pare\nLe nom de mon container est donc charming_pare. Pour arrêter mon container, je dois taper la commande suivante :\ndocker stop charming_pare\n\n\n\n\n\n\nTip\n\n\n\nQuand on tape des lignes de commande en bash, utilisez la touche tab pour auto-compléter la commande. Par exemple, ici, j’ai seulement tapé docker stop ch puis appuyé sur tab qui a complété le nom de mon container. Pratique, non ? N’hésitez pas à en abuser. Si l’auto-complete ne fonctionne pas, c’est qu’il ne trouve rien OU plusieurs résultats. Dans ce cas, continuez à écrire la commande à la main et réessayez.\n\n\nUtilisez à nouveau la commande docker ps pour vérifier que ce container n’apparaît plus dans la liste. Normalement, si vous actualisez la page GeoServer, vous devriez avoir une erreur du type “localhost refused to connect”.\nAlors, c’est bien sympa tout ça, mais en l’état, on ne va pas pouvoir ajouter de données dans notre container. Il faudrait pouvoir accéder au dossier /data de GeoServer. Heureusement, pour nous simplifier la vie, on peut utiliser Docker pour “connecter” deux dossiers en eux (monter, mount en anglais). Pour ça, il faut créer sur notre ordinateur un nouveau dossier dans lequel on mettra tout ce qu’on veut retrouver dans le /data de notre GeoServer. Promis, c’est la dernière étape aussi technique, ensuite je me détends et j’arrête de vous faire taper autant de lignes de commande.\n\n\n\n\n\nD’abord, on supprime notre container. On va en créer un nouveau dans les étapes suivantes.\ndocker rm &lt;nom_du_container&gt;\nEnsuite, on va créer un dossier à monter sur le /data de notre container.\n\nAllez dans Documents et créer un nouveau dossier “GeoServer”.\nCopiez le chemin ABSOLU vers ce dossier. Par exemple, chez moi (Ubuntu), ça donne ça : /home/marie/Documents/GeoServer\nRemplacez \"/absolute/path/on/host\" dans la commande suivante et copiez-collez la quelque part, on ne sait jamais.\n\ndocker run -it -p 80:8080 \\\n  --mount src=\"/absolute/path/on/host\",target=/opt/geoserver_data/,type=bind \\\n  docker.osgeo.org/geoserver:2.26.0\n\nExécutez la ligne de commande.\n\nMaintenant, on va ajouter notre jeu de données land_matrix_mines à notre dossier /data.\n\nTéléchargez le jeu de données land_matrix_mines.\nDans l’explorateur de fichiers de votre ordinateur, ouvrez votre dossier GeoServer. Normalement, vous auriez du voir apparaître plusieurs nouveaux dossiers. Allez dans /data et créez un nouveau dossier geopackage.\nGlissez le fichier land_matrix_mines.gpkg dans le dossier geopackage.\n\n\n\n\n\n\n\nJe ne peux pas créer de nouveau dossier / déplacer mon fichier !\n\n\n\n\n\nSi vous ne pouvez pas créer de nouveau dossier, c’est que vous ne disposez pas des permissions suffisantes. Dans mon cas (sur Ubuntu), tous les dossiers appartenaient à l’utilisateur et au groupe root. Il faut utiliser la commande chown :\nsudo chown -R &lt;user&gt;:&lt;group&gt; /chemin/vers/mon/dossier\nPour changer les droits de mon dossier `/home/marie/Documents/GeoServer` j’ai donc tapé :\nsudo chown -R marie:marie /home/marie/Documents/GeoServer\nSi ça ne fonctionne pas, ne restez pas bloqués et appelez-moi, on règle ça ensemble.\n\n\n\nC’est bon, ça fonctionne ? Parfait ! Les règles pour arrêter et démarrer son container restent les mêmes. Tout ce qu’il faut retenir, c’est qu’il ne faut pas supprimer ou déplacer votre dossier GeoServer sous peine de tout casser. Pour le reste, tout devrait fonctionner tranquillement.\n\n\n\n\n\n\nRappel des commandes principales\n\n\n\n\n\n# Lister les containers actifs\ndocker ps\n\n# Lister tous les containers, même arrêtés\ndocker ps -a\n\n# Démarrer mon container\ndocker start &lt;nom_du_container&gt;\n\n# Arrêter mon container\ndocker stop &lt;nom_du_container&gt;\n\n# /!\\ Supprimer mon container\ndocker rm &lt;nom_du_container&gt;\n\n\n\nVous avez survécu au déploiement du GeoServer, bien joué ! Prenez un moment pour souffler, allez vous chercher un café. La suite sera beaucoup moins prise de tête, c’est promis !\n\n\n\n\n\n\n\nEspaces de travail, Entrepôts et Couches\nCréer un espace de travail, c’est facile, on vient de le faire. Maintenant, on va créer un nouveau dépôt par défaut qu’on appellera land_matrix et dans lequel on ajoutera notre geopackage.\n\nAllez dans “Espaces de travail” et cliquez sur “Ajouter un nouvel espace de travail”.\nNommez l’espace de travail “land_matrix” et donnez lui l’URI “land_matrix”.\nCochez “Espace de travail par défaut”.\nCiquez sur “Sauvegarder”.\n\nSi tout va bien, on voit maintenant notre espace “land_matrix” dans la liste. On va pouvoir ajouter un entrepôt de données dans notre espace.\n\nAllez dans “Entrepôts” et cliquez sur “Ajouter un nouvel entrepôt”. Vous allez voir une liste de tous les types d’entrepôts de données qui peuvent être ajoutés à votre espace de travail, par exempe du GeoPackage, une base PostGIS, un Shapefile ou encore un flux WMS distant.\nSélectionnez “GeoPackage”.\nNommez la source de données “land_matrix_mines” et ajoutez une petite description, par exemple “Transactions minières de la Land Matrix, 2024”.\nDans “Paramètres de connexion” cliquez sur “Parcourir…” à droite de “database *”.\nAllez dans data/geopackage/ et cliquez sur le jeu de données land_matrix_mines.gpkg.\nVidez le champ “passwd”.\nCliquez sur “Sauvegarder”.\n\nUne fois de retour sur la page “Entrepôts”, vous devriez voir votre entrepôt “land_matrix_mines” associé à l’espace de travail “land_matrix”. On avance ! Maintenant, on veut publier et lire des couches.\n\nAllez dans “Couches” et cliquez sur “Ajouter une nouvelle couche”.\nSélectionnez “land_matrix:land_matrix_mines”. Vous devriez voir apparaître une liste de couches.\nCliquez sur “Publier” à droite de la couche “deals”.\n\nL’onglet de publication de couche permet de configurer la couche et d’y ajouter de la métadonnée. Dans ce TP, on se concentrera sur les informations “cruciales” pour définir une couche, mais vous pourrez toujours allez plus loin en utilisant la documentation GeoServer sur les couches.\nLes trois choses à faire absolument à chaque fois dans l’onglet données sont :\n\nRenseigner les informations dans “Informations de base sur les donneés” comme le nom de la couche et un résumé. N’oubliez pas de laisser “Activé” et “Publié” cochés pour rendre la couche accessible depuis l’extérieur.\nVérifier le “Système de Référence de Coordonnées (SRC)” qui doit être pré-rempli en EPSG:4326 dans notre cas. Il correspond à la projection WGS84 utilisée dans la grande majorité des cas en cartographie web.\nDéfinir les “Emprises” qui se calculent automatiquement sur GeoServer en cliquant sur “Calculer depuis les limites du SRS” et “Calculées sur les emprises natives”.\n\nCliquez ensuite sur “Appliquer” pour sauvegarder vos changements et scrollez en haut de la page pour accéder à l’onglet “Publication”.\n\nDans “Paramètres de couche”, cochez Interrogeable et vérifiez que le style par défaut est bien “point”.\n\nCliquez sur “Sauvegarder”. La couche devrait maintenant apparaître au sommet du tableau. Cliquez simplement sur le nom de la couche (ici “deals”) pour la paramétrer à nouveau si besoin. Pour vérifier que tout a fonctionné, on peut prévisualiser la couche directement depuis GeoServer.\n\nAllez dans “Prévisualisation de la Couche” (menu à gauche de l’écran).\nSur la ligne de la couche “deals”, sélectionnez “OpenLayers”.\n\nVous devriez voir apparaître quelque chose comme ça, avec des informations supplémentaires si vous cliquez sur des points (possible car notre couche est interrogeable) :\n\n\n\n\n\nSi c’est bon, bravo, ça a fonctionné ! Si vous voyez des artefacts autour des points, c’est normal. Ce que vous regardez, ce ne sont pas des polygones mais une image produite à partir de notre couche et transmise comme un flux WMS par notre serveur. L’intérêt, c’est qu’on peut afficher rapidement des couches très lourdes de cette manière, là où un GeoJSON commencerait à ramer. Et on peut toujours zoomer et cliquer sur un point pour l’interroger. C’est super pratique ! Ce flux WMS est récupéré et lu par une petite appli OpenLayers, c’est comme ça que vous êtes capable de voir la couche sur votre page web (vous sentez venir la transition vers les prochains cours, là ?).\nBon, super, on a notre couche moche. Maintenant, on en fait quoi de tous ces points rouges ?\n\n\n\n\n\nFacile. On va d’abord la rendre un peu plus belle, puis on va la lire dans notre propre application OpenLayers et commencer à faire des trucs cools avec. Mais avant, comme vous avez tout compris à ce qu’on vient de faire, ajoutez toutes les autres couches du geopackage à votre espace de travail. Quand vous avez réussi à toutes les prévisualiser (et pleuré devant leur style austère), créez un nouveau projet QGIS et importez aussi ces couches.\n\n\nStyliser mes couches\nDocumentation GeoServer “Styling”\nPour le moment, afficher notre couche “deals” va juste donner l’impression que notre carte a attrappé la varicelle. On va commencer par changer son apparence en faisant des points bien ronds et d’une couleur qui crie moins “DANGER !!!”. Pour ça, on va devoir créer un nouveau style.\n\nAllez dans “Styles” et cliquer sur “Ajouter un nouveau style”.\nNommez le style “deals” et choisissez l’espace de travail “land_matrix”. Conservez le format SLD, c’est le seul disponible sans ajouter d’extensions.\nPour nous aider, GeoServer propose de générer un SLD par défaut. Sélectionnez “Point” et cliquez sur “Générer…”. Vous devriez vous retrouver avec un fichier .xml décrivant la couche.\n\nOn pourrait aller lire en détail le SLD Cookbook de GeoServer pour écrire notre fichier manuellement, mais on est plus malins que ça. On a un super outil à disposition qui s’appelle QGIS.\n\nSi vous ne l’avez pas déjà fait, créez un projet QGIS et ajoutez les couches Land Matrix.\nDonnez un style sympa aux points de la couche deals. J’ai changé la couleur pour les rendre orange.\nAllez dans les propriétés de votre couche et dans “Symbologie”. Tout en bas, choisissez “Style” et “Enregistrer le style…”.\nChoisissez l’option “En tant que fichier SLD” et choisissez le chemin et le nom de votre fichier en cliquant sur “…” après “Fichier”. J’ai appelé le mien “deals.sld”\nAllez chercher votre fichier et ouvrez-le avec un éditeur de texte (Notepad, VSCode, peu importe).\nCopiez le contenu.\nRetournez sur votre page GeoServer, supprimez tout le contenu de la zone de texte et collez à la place le contenu de deals.sld. Renommez le contenu de la balise &lt;se:Name&gt; en Deal. Voilà ce que ça donne pour moi :\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Deal&lt;/se:Name&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#ffd157&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;7&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\nVous pouvez prévisualiser la légende en cliquant sur “Aperçu de la légende”. Le bouton “Ajouter une légende” permet quand à lui d’ajouter une image customisée plutôt qu’une génération automatique. C’est pratique quand on a des légendes complexes, mais pas pour le moment. Ensuite, sauvegardez la légende quand elle vous convient.\n\n\n\n\n\n\nTip\n\n\n\nUne autre méthode pour charger le contenu d’un fichier de style .sld est de cliquer sur “Browse” en dessous de “Fichier de style”. Allez chercher votre fichier .sld et cliquez sur “Charger…” pour vous économiser quelques copier-coller par la suite !\n\n\nMaintenant, il faut dire à GeoServer qu’on veut utiliser ce style avec notre couche “deals”.\n\nAllez dans “Couches”.\nSélectionnez la couche “deals et allez dans l’onglet”Publication”.\nDans “Style par défaut”, sélectionnez “land_matrix:deals” et Sauvegardez.\n\nMaintenant, vous pouvez de nouveau prévisualiser la couche “deals” et voilà ! Nos points sont ronds et jaunes. Vous savez maintenant créer un nouveau style SLD depuis QGIS et l’ajouter à une couche dans GeoServer !\n\n\n\n\n\nNormalement, vous commencez à bien comprendre le fonctionnement de GeoServer et la publication des couches. Créez un style de couleur unique pour “deals_by_country” qu’on utilisera comme pseudo fond de carte. Ensuite, créez un style en cercles proportionnels pour “deals_by_country_centroid” en vous basant sur l’attribut “surface_ha”.\n\n\n\n\n\n\nAttention à la sémiologie\n\n\n\nJe ne veux pas voir de polygones “deals_by_country” de différentes couleurs. On n’utilise pas de carte choroplèthe pour représenter une valeur absolue, elles servent pour les valeurs relatives ou les catégories.\n\n\n\n\n\n\n\nUne fois que vous avez au moins ajouté votre style à “deals_by_country” dans GeoServer, vous pouvez passer à la suite. Si vous avez un train de retard, cliquez sur les boutons ci-dessous pour dérouler mes styles et les copier-coller dans votre GeoServer.\n\n\n\n\n\n\nSLD pour “deals_by_country”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals_by_country&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals_by_country&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Single symbol&lt;/se:Name&gt;\n          &lt;se:PolygonSymbolizer&gt;\n            &lt;se:Fill&gt;\n              &lt;se:SvgParameter name=\"fill\"&gt;#fdbf6f&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"fill-opacity\"&gt;0.35&lt;/se:SvgParameter&gt;\n            &lt;/se:Fill&gt;\n            &lt;se:Stroke&gt;\n              &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-width\"&gt;1&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-linejoin\"&gt;bevel&lt;/se:SvgParameter&gt;\n            &lt;/se:Stroke&gt;\n          &lt;/se:PolygonSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\n\n\n\n\nSLD pour “deals_by_country_centroid”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals_by_country_centroid&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals_by_country_centroid&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;201 - 5466&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;201 - 5466&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;200.81000000000000227&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThanOrEqualTo&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;4&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;5466 - 20413&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;5466 - 20413&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;10&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;20413 - 61376&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;20413 - 61376&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;16&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;61376 - 160220&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;61376 - 160220&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;22&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;160220 - 1509612&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;160220 - 1509612&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;1509612&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;29&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\nLire mes flux dans une autre application\nCourage, on touche au but. Vous aurez bientôt fait le tour du fonctionnement basique de GeoServer. Maintenant qu’on a nos couches, on veut pouvoir les lire.\nPour commencer, on va rapidement vérifier qu’on communique bien avec notre GeoServer en utilisant QGIS et la requête GetCapabilities du serveur. Cette requête, lorsqu’elle réussit, nous répond avec un fichier .xml qui explique à QGIS tout ce que le serveur est capable de faire, et notamment quelles couches peuvent être affichées.\n\nDans QGIS, cliquez sur “Ajouter une couche” et sélectionnez “WMS”.\nDans l’onglet “Couches”, cliquez sur “Nouveau”.\nAppelez la connexion “mon_geoserver” et collez l’url GetCapabilities dans “URL”. Elle devrait être identique à celle-ci :\n\nhttp://localhost/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetCapabilities\n\n\n\n\n\n\nÇa ne fonctionne pas !\n\n\n\n\n\nPour vérifier que votre requête est bonne, allez dans GeoServer, affichez n’importe quelle couche en prévisualisation et copiez l’adresse.\nhttp://localhost/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetMap&layers=land_matrix%3Adeals&bbox=-180.0%2C-90.0%2C180.0%2C90.0&width=768&height=384&srs=EPSG%3A4326&styles=&format=application/openlayers\nSupprimez tout ce qui se trouve après “request=” et ajoutez “GetCapabilities”.\nhttp://localhost/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetCapabilities\n\n\n\n\nCliquez ensuite sur “Connexion” et vérifiez qu’une liste de couche apparaît et qu’elle contient bien vos couches “deals”, etc.\n\nVous pouvez afficher la couche dans QGIS avec “Add” si vous le souhaitez. L’essentiel, c’est qu’on a vérifier que notre serveur émet bien des flux WMS pour nos couches et qu’on peut bien les lire. On va maintenant faire la même chose dans une application OpenLayers. Comme on n’a pas encore commencé les cours, je vous donne le code. Vous verrez, ça ressemble beaucoup à Leaflet. Dans le dossier de votre choix, créez un document index.html et collez le contenu suivant :\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;GeoServer + OpenLayers&lt;/title&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width\"&gt;\n\n        &lt;!-- CSS --&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/ol.css\" /&gt;\n        &lt;style&gt;\n        #map {\n            height: 500px;\n            width: 800px;\n        }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;GeoServer + OpenLayers&lt;/h1&gt;\n\n        &lt;div id=\"map\"&gt;&lt;/div&gt;\n\n        &lt;!-- OpenLayers JS--&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/dist/ol.js\"&gt;&lt;/script&gt;\n\n        &lt;!-- App code --&gt;\n        &lt;script&gt;\n            // OSM layer and source\n            var source_osm = new ol.source.OSM()\n            var layer_osm = new ol.layer.Tile({ source: source_osm })\n\n            // GeoServer layer and source\n\n            // Map\n            var map = new ol.Map({\n                target: 'map',\n                layers: [ layer_osm ],\n                view: new ol.View({\n                center: ol.proj.fromLonLat([2.1833, 41.3833]),\n                zoom: 2\n                })\n            });\n        &lt;/script&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\nDouble-cliquez sur index.html pour l’ouvrir dans le navigateur. Vous devriez voir apparaître une carte avec un fond OSM. On va ajouter nos couches GeoServer à cette carte.\n\n\n\n\n\nSous la section commentée “GeoServer Layer and source”, ajoutez les lignes suivantes :\nvar url_geoserver = 'http://localhost/geoserver/land_matrix/wms'\nvar source_geoserver = new ol.source.ImageWMS({\n    url: url_geoserver,\n    params: {'LAYERS': 'land_matrix:deals'},\n    serverType: 'geoserver',\n})\nvar layer_geoserver = new ol.layer.Image({ source: source_geoserver })\nEt ajoutez layer_geoserver à la liste de couches de map :\n// Map\nvar map = new ol.Map({\n    target: 'map',\n    layers: [ layer_osm, layer_geoserver ],\n    view: new ol.View({\n    center: ol.proj.fromLonLat([2.1833, 41.3833]),\n    zoom: 2\n    })\n});\nActualisez la carte. Vous devriez maintenant voir apparaître la couche “deals” de l’entrepôt “land_matrix” ! Décortiquons rapidement ces lignes de code.\nvar url_geoserver = 'http://localhost/geoserver/land_matrix/wms'\nOn récupère l’url de notre serveur. Si vous ne la trouvez pas, allez dans votre GeoServer et prévisualisez n’importe quelle couche. Récupérez l’url et coupez tout après “wms”. land_matrix est l’URI que nous avons donné à notre espace de travail (voir la section Espaces de travail du TP).\nvar source_geoserver = new ol.source.ImageWMS({\n    url: url_geoserver,\n    params: {'LAYERS': 'land_matrix:deals'},\n    serverType: 'geoserver',\n})\nOn crée ensuite une nouvelle source de données de type ImageWMS. On indique l’url de la source, à savoir l’url de notre espace de données GeoServer stocké dans la variable url_geoserver. L’image prend aussi un ou plusieurs paramètres. On indique dans ‘LAYERS’ la couche qu’on souhaite afficher. Celle ligne s’écrit toujours sous la forme :\n'LAYERS' : '&lt;entrepôt&gt;:&lt;couche&gt;'\nSi vous avez un doute, allez dans “Prévisualisation de la couche” et regardez le contenu de la colonne “Nom”. C’est la valeur à donner à ‘LAYERS’.\nEnfin, on renseigne le type du serveur, ici ‘geoserver’. Ce paramètre permet à OpenLayers de communiquer plus facilement avec GeoServer lorsque vous utiliserez des fonctionnalités plus avancées. De manière générale, cela vous permet aussi de vous souvenir du type de serveur avec lequel vous communiquez.\nChouette, après tout ça on a enfin réussi à créer, lire et afficher un flux WMS ! Sauf que, il manque encore quelque chose… la légende ! Et là vous me dites “pitié, j’en peux plus, j’ai la tête qui va exploser”. Allez, encore un petit effort. On a vu que GeoServer est capable de générer tout seul une légende, il nous suffit donc de la récupérer. Pour ça, rien de plus facile ! Le serveur distribue les images comme il distribue les couches de données. Il nous suffit de récupérer l’image en question et l’afficher dans une nouvelle &lt;div&gt; sur notre carte.\nOn reviendra en détail sur le fonctionnement des légendes dans le TP sur OpenLayers. Commencez par créer une &lt;div&gt; pour la légende sous &lt;div id=\"map\"&gt;&lt;/div&gt; :\n&lt;div id=\"map\"&gt;&lt;/div&gt;\n&lt;div&gt;&lt;img id=\"legend\" /&gt;&lt;/div&gt;\nNotre script permettra de modifier la source de l’image legend en interrogeant GeoServer à chaque fois qu’on fera changer la résolution de la carte. Dans le tag &lt;script&gt;, en dessous du code de la carte “Map”, ajoutez les lignes suivantes :\n&lt;!-- App code --&gt;\n&lt;script&gt;\n    //…\n\n    // Function to update the legend    \n    function updateLegend(resolution) {\n        const graphicUrl = source_geoserver.getLegendUrl(resolution, { 'LEGEND_OPTIONS' : 'forceLabels:on' });\n        const img = document.getElementById('legend');\n        img.src = graphicUrl;\n    };\n\n    // Initial legend\n    const resolution = map.getView().getResolution();\n    updateLegend(resolution);\n\n    // Update legend when resolution changes\n    map.getView().on('change:resolution', function (event) {\n        const resolution = event.target.getResolution();\n        updateLegend(resolution);\n    });\n\n&lt;/script&gt;\nEn résumé :\n\nLa fonction updateLegend() permet de récupérer l’url de la légende depuis notre source GeoServer source_geoserver en utilisant la méthode getLegendUrl(). On modifie ensuite la source de notre image &lt;img id=\"legend\" /&gt; sur l’url de la légende.\nLa fonction getLegendUrl() a besoin de connaître la résolution de la carte pour fonctionner.\nLorsque la carte est créée pour la première fois, on stocke sa résolution dans la variable resolution. La méthode getView() de l’objet map permet de récupérer la valeur de cette résolution. Ensuite, on exécute notre fonction updateLegend() pour récupérer la légende une première fois.\nPour mettre à jour la légende lorsque la résolution change, on écoute les évènements change:resolution de la map. À chaque fois que la résolution change, on va récupérer à nouveau cette résolution et exécuter la fonction updateLegend().\n\n\n\n\n\n\n\nCode complet de l’application\n\n\n\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;GeoServer + OpenLayers&lt;/title&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width\"&gt;\n\n        &lt;!-- CSS --&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/ol.css\" /&gt;\n        &lt;style&gt;\n        #map {\n            height: 500px;\n            width: 800px;\n        }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;GeoServer + OpenLayers&lt;/h1&gt;\n\n        &lt;div id=\"map\"&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;img id=\"legend\" /&gt;&lt;/div&gt;\n\n        &lt;!-- OpenLayers JS--&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/dist/ol.js\"&gt;&lt;/script&gt;\n\n        &lt;!-- App code --&gt;\n        &lt;script&gt;\n            // OSM layer and source\n            var source_osm = new ol.source.OSM()\n            var layer_osm = new ol.layer.Tile({ source: source_osm })\n\n            // GeoServer layer and source\n            var url_geoserver = 'http://localhost/geoserver/land_matrix/wms'\n            var source_geoserver = new ol.source.ImageWMS({\n                url: url_geoserver,\n                params: {'LAYERS': 'land_matrix:deals'},\n                serverType: 'geoserver',\n            })\n            var layer_geoserver = new ol.layer.Image({ source: source_geoserver })\n\n            // Map\n            var map = new ol.Map({\n                target: 'map',\n                layers: [ layer_osm, layer_geoserver ],\n                view: new ol.View({\n                center: ol.proj.fromLonLat([2.1833, 41.3833]),\n                zoom: 2\n                })\n            });\n\n            // Function to update the legend    \n            function updateLegend(resolution) {\n                const graphicUrl = source_geoserver.getLegendUrl(resolution, { 'LEGEND_OPTIONS' : 'forceLabels:on' });\n                const img = document.getElementById('legend');\n                img.src = graphicUrl;\n            };\n\n            // Initial legend\n            const resolution = map.getView().getResolution();\n            updateLegend(resolution);\n\n            // Update legend when resolution changes\n            map.getView().on('change:resolution', function (event) {\n                const resolution = event.target.getResolution();\n                updateLegend(resolution);\n            });\n\n        &lt;/script&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\n\n\n\nOuf ! On a enfin une légende. Pour ceux qui ont encore le temps et l’énergie, je vous propose d’afficher les autres couches et leur légende sur la carte, au moins “deals_by_country_centroids” pour avoir nos cercles proportionnels. C’est parti !",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#conclusions",
    "href": "cours/geonum/serveurs_carto.html#conclusions",
    "title": "Serveurs cartographiques",
    "section": "Conclusion(s)",
    "text": "Conclusion(s)\n\nC’est quoi l’intérêt du serveur carto, déjà ?\n\nCentralisation de la donnée et mise à jour\nDistribution de la donnée\nGestion des droits\nBien quand on a une organisation et bcp de données, s’intègre très bien dans une IDG\nBien pour les couches Raster et les couches Vecteur lourdes qui peuvent être servies en tant qu’images (WMS)\nConnexion directe à une base de données PostgreSQL\nPossibilité d’écrire des requêtes SQL pour former les couches\nPossibilité de créer des styles complexes “à la QGIS”.\n\nEst-ce que j’en ai besoin pour mon projet GeoNum ?\n\nÇa dépend des données que vous utilisez et ce que vous en faites. Le mieux c’est d’en discuter avec les profs !\n\nJe n’utilise pas de connexion à une base de données, je préfère juste afficher des couches avec un style complexe. Ce serait pas plus simple si on pouvait directement importer les couches d’un projet QGIS ?",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#tp---qgis-server-avec-lizmap",
    "href": "cours/geonum/serveurs_carto.html#tp---qgis-server-avec-lizmap",
    "title": "Serveurs cartographiques",
    "section": "TP - QGIS Server avec LizMap",
    "text": "TP - QGIS Server avec LizMap\nEn cours de rédaction, revenez plus tard !",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/introduction.html",
    "href": "cours/geonum/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Slides : Introduction",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Accueil",
    "section": "",
    "text": "Bienvenue sur mon site en cours de construction. Si vous avez trouvé cette page, vous êtes sûrement un étudiant en master GeoNum. Les ressources pour les TD, c’est par ici !"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#oh-non-cest-vide",
    "href": "cours/geonum/slides_serveurs_carto.html#oh-non-cest-vide",
    "title": "Serveurs Cartographiques",
    "section": "Oh non, c’est vide !",
    "text": "Oh non, c’est vide !\nPas de panique, je suis en train de terminer les slides. Une version complète sera mise en ligne avec la prochaine mise à jour du site.\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#intervenante",
    "href": "cours/geonum/slides_introduction.html#intervenante",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Intervenante",
    "text": "Intervenante\nMarie Gradeler\n⛰️ Licence de Géologie\n🤠 Master d’Archéologie du Paysage (SIG, télédec, stats)\n🤷 Pas de sous en archéo donc galère de trouver du travail\n🗺️ Master GeoNum (arrivée en M2)\n💻 Stage AgroParisTech dans le cadre du Master : développement d’une appli de cartographie web\n💻 Contrat de 6 mois au CIRAD pour terminer la production de l’appli carto du stage\n💻 Depuis, je travaille comme consultante IFAD sur le project Land Matrix (création d’indicateurs, stats avec R, beaucoup de dataviz et développement Web)"
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#les-cours",
    "href": "cours/geonum/slides_introduction.html#les-cours",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Les cours",
    "text": "Les cours\n\nJeudi 21 Nov : 9h - 12h\nMercredi 27 Nov : 9h - 12h\nJeudi 28 Nov : 9h - 12h\nJeudi 28 Nov : 13h30 - 16h30\n\nOn va beaucoup travailler sur les serveurs cartographiques, notamment GeoServer, mais aussi sur la librairie de cartographie OpenLayers. Cela va nous demander de savoir écrire du code en JavaScript, d’être capable d’exécuter une ou deux lignes de commandes en Bash et de comprendre l’architecture client-serveur du web.\nJe vous recommande d’être bien attentifs aux cours de Leaflet (entre autres) qui sont complémentaires de celui-ci. Si vous connaissez Leaflet, vous connaissez presque déjà OpenLayers."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#les-ressources",
    "href": "cours/geonum/slides_introduction.html#les-ressources",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Les ressources",
    "text": "Les ressources\n💻 Mon site internet : https://gradelerm.github.io\nIl est en cours de construction mais suffit déjà à héberger les ressources pour le cours. Vous y trouverez tout le reste !\nMoi : marie.gradeler@gmail.com\nN’hésitez pas à me contacter. Mes cours sont condensés sur 2 semaines. Si quelque chose ne va pas, je dois le savoir dès la première séance. Je serai aussi disponible pour vous accompagner durant les projets GeoNum si vous avez besoin d’aide sur l’une des notions abordées en cours."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#comment-ça-se-passe",
    "href": "cours/geonum/slides_introduction.html#comment-ça-se-passe",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Comment ça se passe",
    "text": "Comment ça se passe\nOrganisation des cours\n\nPas mal de mise en pratique\nOn m’appelle si on est perdu, je suis là pour vous aider (ne me laissez pas faire mon cours dans le vide parce que vous avez abandonné tout espoir de raccrocher les wagons, ça ne sert à rien)\nSi on doit ralentir parce que j’ai trop prévu de choses techniques, on ralentit et puis c’est tout, j’adapterai l’évaluation à ce qu’on a eu le temps de voir en cours\nPas d’IA pour écrire le code ! Je donne généralement les corrigés dans le TP, vous n’en aurez même pas besoin. Pour apprendre, le mieux, c’est de faire soi-même, et ça ne m’intéresse pas trop de venir faire cours à Chat-GPT ou Gemini de toute façon.\nJe sais que c’est difficile mais on lâche son téléphone pendant le cours (ou cet onglet mal planqué) et on se concentre sur le cours. WhatsApp et les ouvertures de boosters attendront la pause café."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#évaluation",
    "href": "cours/geonum/slides_introduction.html#évaluation",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Évaluation",
    "text": "Évaluation\nProjet à rendre basé sur une petite architecture web que je vous fournirai (et qui pourrait éventuellement servir de base pour une archi de projet GeoNum, je dis ça je dis rien…). Dans les grandes lignes, ce qui vous sera demandé :\n🛠️ Publication de couches sur un GeoServer\n🗺️ Lecture des flux WMS sur une petite appli OpenLayers\n💻 Déploiement (rudimentaire) de votre serveur GeoServer + application OpenLayers en s’appuyant sur l’architecture web fournie\nJe vais recalibrer l’évaluation suivant la vitesse à laquelle on avance et le niveau moyen de la promo en dev. Du coup, vous aurez les consignes pendant le dernier cours."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#comment-ça-se-passe-1",
    "href": "cours/geonum/slides_introduction.html#comment-ça-se-passe-1",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Comment ça se passe",
    "text": "Comment ça se passe\nPendant le cours\n\nPas d’IA pour écrire le code ! Je donne généralement les corrigés dans le TP, vous n’en aurez même pas besoin. Pour apprendre, le mieux, c’est de faire soi-même, et ça ne m’intéresse pas trop de venir faire cours à Chat-GPT ou Gemini de toute façon.\nJe sais que c’est difficile mais on lâche son téléphone (ou cet onglet mal planqué) et on se concentre sur le cours. Les notifications Instagram et les ouvertures de boosters attendront la pause café. On en aura, c’est promis."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#cest-parti",
    "href": "cours/geonum/slides_introduction.html#cest-parti",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "C’est parti !",
    "text": "C’est parti !\nPrêts à encore entendre parler de serveurs, clients, requêtes, variables et fonctions ?\n\n\n\n\n\nCourage. Promis, ça va nous permettre de faire des trucs cools qui seront très utiles pour les projets GeoNum et si vous faites de la webcarto ou des IDGs plus tard.\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#section",
    "href": "cours/geonum/slides_serveurs_carto.html#section",
    "title": "Serveurs Cartographiques",
    "section": "",
    "text": "Formation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#sommaire",
    "href": "cours/geonum/slides_serveurs_carto.html#sommaire",
    "title": "Serveurs Cartographiques",
    "section": "Sommaire",
    "text": "Sommaire\n\nQu’est-ce qu’un serveur carto ?\nLes standards OGC\nPourquoi utiliser un serveur carto ?\nExemples de serveurs carto\nGeoServer\nTP - Mise en pratique"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto",
    "title": "Serveurs Cartographiques",
    "section": "Qu’est-ce qu’un serveur carto ?",
    "text": "Qu’est-ce qu’un serveur carto ?\nRappels sur ce qu’est un serveur\nLe serveur matériel (hardware) : Une ou plusieurs machines physiques reliées entre elles et et sur lesquelles fonctionnent un ou plusieurs logiciels.\nSource : Ionos\nDans ce TP, notre serveur physique sera notre ordinateur. En pratique, cela ressemble plus souvent à ça (serveurs WikiMedia foundation) :"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-1",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-1",
    "title": "Serveurs Cartographiques",
    "section": "Qu’est-ce qu’un serveur carto ?",
    "text": "Qu’est-ce qu’un serveur carto ?\nRappels sur ce qu’est un serveur\nLe serveur (software) : Un programme effectuant des interactions en réseau avec d’autres programmes appelés logiciels clients. Le service apporté dépend du logiciel serveur.\nSource : Ionos\nUn logiciel serveur peut-être un serveur Web (Apache, Nginx), un serveur email, un serveur de bases de données (PostgreSQL), un serveur cartographique (GeoServer), etc. Un logiciel client est par exemple un navigateur internet pour afficher un site web (Firefox, Google Chrome), un client mail (Thunderbird), et plus généralement une machine cliente."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-2",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-2",
    "title": "Serveurs Cartographiques",
    "section": "Qu’est-ce qu’un serveur carto ?",
    "text": "Qu’est-ce qu’un serveur carto ?\nComment le serveur communique-t-il avec les clients ?\nDans le cas des serveurs web et cartographiques, le client (par exemple notre Firefox) va envoyer des requêtes au serveur (par exemple GeoServer). Le serveur va lire la requête et renvoyer une réponse. Cette réponse peut-être une page web, un JSON, un flux cartographique, mais aussi un message d’erreur comme le fameux 404 not found.\n\nSource : codegym.cc"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-3",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-3",
    "title": "Serveurs Cartographiques",
    "section": "Qu’est-ce qu’un serveur carto ?",
    "text": "Qu’est-ce qu’un serveur carto ?\nComment le serveur communique-t-il avec la source de donnée ?\nEn réalité, la plupart des applications fonctionnent de la manière suivante : le client envoie des requêtes au serveur. Le serveur va communiquer avec la base de données, traiter le résultat et renvoyer une réponse au client.\nExemple :\n- Client = mon application Firefox\n- Serveur = les serveurs de Google\n- Database = la base de données de Google\n- Requête = cherche les sites qui correspondent à la requête “apprendre le JavaScript”\n- Réponse = liste des sites qui correspondent à la requête “apprendre le JavaScript”\n\nSource : codegym.cc"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-4",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-4",
    "title": "Serveurs Cartographiques",
    "section": "Qu’est-ce qu’un serveur carto ?",
    "text": "Qu’est-ce qu’un serveur carto ?\nLa spécificité du serveur carto\nUn serveur cartographique va servir - sans surprise - de la donnée cartographique sous forme de vecteur ou de raster, tuilée ou non. Il le fait selon des standards OGC bien définis comme le WMS (Web Map Service) et le WFS (Web Feature Service) qui vont définir la structure de la donnée récupérée et les interactions possibles avec cette couche de d‘information.\n\n\n\nSource : hansongis.com/blog/"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nLes spécifications OGC suivantes définissent ce qu’on appelle des interfaces (ou API) pour requêter des cartes géoréférencées d’un serveur.\nPas de panique - “interface” est un joli mot pour expliquer comment on doit structurer notre requête et ce qu’on recevra en réponse. Par exemple, quand on commande une glace, on sait qu’il faut indiquer pot ou cornet, le nombre de boules et le parfum de chacune. En échange, on obtiendra une glace bien structurée, prête à être dégustée. Si on veut beaucoup simplifier, l’interface fait le lien entre ce que le client aimerait et ce que le cuisinier peut lui donner en encadrant la question posée par le client et les réponses possibles du cuisinier.\nSource : Documentation GeoServer"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-1",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-1",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Map Service (WMS)\n\nLa spécification WMS fournit une interface standard pour requêter une image géoréférencée et sa légende. Le client reçoit une image géoréférencée.\nC’est le plus couramment utilisé car il est plus rapide que le WFS lorsqu’il s’agit de représenter beaucoup d’éléments.\nLa requête GetMap permet de récupérer une carte.\nLa requête GetFeatureInfo permet de récupérer la géométrie et les valeurs d’un pixel.\nLa requête GetLegendGraphic permet de récupérer la légende.\n\nSource : GeoServer WMS reference - Source : QGISserver WMS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-2",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-2",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Feature Service (WFS)\n\nLa spécification WFS fournit une interface standard pour créer, modifier et requêter de l’information géographique au format vecteur. Le client reçoit de la donnée au format GML.\nC’est celui qu’il faut utiliser dans le cas de la manipulation de vecteurs (pour les requêtes attributaires, le WMS suffit).\nLa requête GetFeature retourne une sélection de features avec leur géométrie et la valeur de leurs attributs.\nLa requête Transaction permet d’éditer une feature existante en utilisant “create”, “update” ou “delete”.\n\nSource : GeoServer WFS reference - Source : QGISserver WFS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-3",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-3",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Feature Service (WCS)\n\nLa spécification WCS fournit une interface pour accéder à de la donnée raster. On peut le voir comme le WMS pour du raster.\nLa requête DescribeCoverage retourne un document XML qui décrit la couverture du pixel sélectionné.\nLa requête GetCoverage retourne un résultat similaire à la requête GetMap du flux WMS mais avec des extensions additionnelles pour supporter la récupération de données raster.\n\nSource : GeoServer WCS reference - Source : QGISserver WCS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-4",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-4",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Map Tile Service (WMTS)\n\nLa spécification WMTS fournit une interface pour requêter des images tuilées. Il s’agit plus ou moins de la même chose que WMS mais qui permet d’utiliser des couches tuilées.\nLa requête GetTile retourne une tuile.\nLa requête GetFeatureInfo permet de récupérer la géométrie et les valeurs d’un pixel (comme dans le cas du flux WMS).\n\nSource : QGISserver WMTS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-5",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-5",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nDans ce TP, nous allons utiliser les flux les plus communs, WMS puis WFS."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto",
    "href": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto",
    "title": "Serveurs Cartographiques",
    "section": "Pourquoi utiliser un serveur carto",
    "text": "Pourquoi utiliser un serveur carto\n\nPermet de rester à jour - quand la donnée est mise à jour sur le serveur, toutes les applications clientes (comme une application Leaflet ou OpenLayers (OL)) récupèrent aussi la donnée à jour. C’est pratique quand on a une IDG.\nPermet de servir de la donnée depuis une base de données PostgreSQL. Au lieu de requêter la donnée en SQL, de l’exporter en JSON et de l’importer dans l’application Leaflet/OL, et de refaire ça à chaque fois que la donnée change, on peut simplement utiliser GeoServer pour générer une couche à partir de SQL.\nPermet de gérer et communiquer les métadonnées. GeoServer permet par exemple d’uploader des fiches de métadonnées pour chaque couche qu’il émet.\nLes serveurs cartographiques sont au cœur des IDG, il faut donc savoir les utiliser. Par exemple, geOrchestra propose GeoServer comme module de serveur cartographique."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto-1",
    "href": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto-1",
    "title": "Serveurs Cartographiques",
    "section": "Pourquoi utiliser un serveur carto",
    "text": "Pourquoi utiliser un serveur carto\nEn résumé\nOn peut se passer d’un serveur cartographique quand on a “juste” quelques features en JSON à afficher. Dès qu’on commence à avoir des couches souvent mises à jour, besoin d’accéder aux métadonnées, de plus nombreuses couches, d’importer des couches stylisées dans QGIS, de créer des couches à partir d’une base de données PostgreSQL… dans ce cas l’utilisation d’un serveur cartographique nous facilite grandement la vie.\n\nExemple 1 : data.grandlyon.com qui permet de lire directement ses couches de données en passant par son API.\nExemple 2 : les fonds de carte OMS (WMS)"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques",
    "href": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques",
    "title": "Serveurs Cartographiques",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nMapServer\nLien vers MapServer\nPlateforme Open Source pour la publication de donnée géospatiale. (J’ai peu de choses à dire dessus, je ne l’ai jamais utilisée).\nMapServer continue à exister dans les organisations qui s’en servent déjà mais ce n’est plus forcément la solution la plus populaire lorsqu’il faut partir de zéro."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer",
    "text": "GeoServer\nGeoServer\nServeur Java gratuit et Open Source qui permet aux utilisateurs de visualiser et éditer de la donnée géospatiale. La librairie OpenLayers est intégrée à GeoServer pour générer rapidement des cartes. Les capacités du serveur peuvent être étendues via l’installation d’extensions divserses.\nGeoServer est le plus simple à mettre en place. Il n’est pas forcément conçu pour fonctionner avec QGIS mais aussi directement avec des bases de données comme PostgreSQL - l’équipe le décrit comme étant “designé pour l’interopérabilité. GeoServer est plus complexe à configurer mais le plus adaptable aux besoins utilisateur, notamment grâce à la gestion fine des droits utilisateurs et l’utilisation de plugins pour enrichir les possibilités.\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-1",
    "href": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-1",
    "title": "Serveurs Cartographiques",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nGeoServer\nLien vers GeoServer\nServeur Java gratuit et Open Source qui permet aux utilisateurs de visualiser et éditer de la donnée géospatiale. La librairie OpenLayers est intégrée à GeoServer pour générer rapidement des cartes. Les capacités du serveur peuvent être étendues via l’installation d’extensions divserses.\nGeoServer est le plus simple à mettre en place. Il n’est pas forcément conçu pour fonctionner avec QGIS mais aussi directement avec des bases de données comme PostgreSQL - l’équipe le décrit comme étant “designé pour l’interopérabilité. GeoServer est plus complexe à configurer mais le plus adaptable aux besoins utilisateur, notamment grâce à la gestion fine des droits utilisateurs et l’utilisation de plugins pour enrichir les possibilités."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-2",
    "href": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-2",
    "title": "Serveurs Cartographiques",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nQGIS Server\nLien vers QGIS Server Guide Manual\nAPI gratuite et Open Source qui permet aussi d’implanter des éléments cartographiques avancés pour créer des cartes thématiques. Elle fonctionne avec un serveur web (Apache ou Nginx).\nQGIS Server est plus difficile à mettre en place (on utilisera une application tierce comme LizMap) mais est le plus compatible avec la publication de projets via QGIS. C’est la meilleure solution pour publier rapidement un projet QGIS. On la présentera rapidement à la fin du TP."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - Introduction",
    "text": "GeoServer - Introduction\n\nGeoServer est un serveur Open Source écrit en Java qui permet aux utilisateurs de partager et éditer de la donnée géospatiale.\nIl a été designé pour maximisé son interopérabilité, permettant de publier de la donnée des sources de données les plus courantes en utilisant des standards ouverts.\nGeoServer est un projet développé, testé et soutenu par sa communauté - comme dans le cas de QGIS.\nGeoServer est une référence dans l’implementation des standards WFS, WMS et WCS de l’OGC.\n\nSource : GeoServer Overview"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction-1",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction-1",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - Introduction",
    "text": "GeoServer - Introduction\n\nLe projet a débuté en 2001 avec le Open Planning Project (TOPP), un organisme à but non lucratif basé à New York et qui a créé une suite d’outils pour promouvoir la transparence de la donnée. Leur premier outil, GeoServer, avait pour objectif de permettre aux citoyens d’accéder aux documents de planification urbaine du gouvernement en partageant la donnée spatiale.\nAvec le temps, le projet GeoTools a été ajouté avec la possibilité de supporter les Shapefiles, les bases de données Oracle, etc.\nD’autres projets ouverts ont continué à enrichir GeoServer et ses fonctionnalités comme le développement de PostGIS (par Refractions Reseach) qui a permis de connecter GeoServer à une base de données gratuite (PostgreSQL).\nLicence : la GNU General Public License, mais contient aussi des logiciels Apache donc dépend de la Apache Software Foundation ainsi que le la Eclipse Public License, qui sont toutes très permissives.\n\nSource : GeoServer Overview"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvénients",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvénients",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - avantages et inconvénients",
    "text": "GeoServer - avantages et inconvénients\nAvantages\n\nSolution très bien documentée\nNombreux plugins qui sont bien maintenus\nPeut lire de multiple sources de données (shapefile, geopackage, connexion à une base PostgreSQL)\nOutil activement maintenu et communauté réactive\nPas difficile à déployer (comparé à d’autres)\nDocumentation riche\nUn outil en tout bien solide sur le long terme"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvénients-1",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvénients-1",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - avantages et inconvénients",
    "text": "GeoServer - avantages et inconvénients\nInconvénients\n\nDifficile à prendre en main au début (gestion des droits, différencier les couches et les dépôts, etc.)\nL’interface est un peu vieille et pas super intuitive\nLa grande majorité des ressources est uniquement disponible en anglais (mais ça ne devrait pas vous faire trop peur !)\nVous allez parfois vous arracher les cheveux sur des fichiers de style complexes"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---comment-utiliser-la-documentation",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---comment-utiliser-la-documentation",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - Comment utiliser la documentation",
    "text": "GeoServer - Comment utiliser la documentation\nhttps://geoserver.org/"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#mise-en-pratique",
    "href": "cours/geonum/slides_serveurs_carto.html#mise-en-pratique",
    "title": "Serveurs Cartographiques",
    "section": "Mise en pratique",
    "text": "Mise en pratique\nPage du TP\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  }
]