[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Dummy blog post TWO\n\n\n\n\n\nSome dummy blog post for pages config\n\n\n\n\n\n1 min\n\n\n\n\n\n\n\nFigures layout\n\n\n\n\n\n\nR\n\n\ntmap\n\n\n\nLayout des figures dans les articles avec Quarto.\n\n\n\n\n\nMar 10, 2025\n\n\nMarie Gradeler\n\n\n1 min\n\n\n\n\n\n\n\nDummy blog post\n\n\n\n\n\n\nR\n\n\ndataviz\n\n\n\nSome dummy blog post for pages config\n\n\n\n\n\nOct 10, 2024\n\n\nMarie Gradeler\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/maps_package.html",
    "href": "posts/maps_package.html",
    "title": "Figures layout",
    "section": "",
    "text": "Classique, on n’ajoute rien.\n\n\n\n\n\n\n\n\n\nOn utilise plus d’espace pour afficher une figure en plus large.\n\n\n\n\n\n\n\n\n\nOn peut aussi afficher les figures dans la marge, il semblerait."
  },
  {
    "objectID": "posts/maps_package.html#test-des-layouts",
    "href": "posts/maps_package.html#test-des-layouts",
    "title": "Figures layout",
    "section": "",
    "text": "Classique, on n’ajoute rien.\n\n\n\n\n\n\n\n\n\nOn utilise plus d’espace pour afficher une figure en plus large.\n\n\n\n\n\n\n\n\n\nOn peut aussi afficher les figures dans la marge, il semblerait."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#sommaire",
    "href": "cours/geonum/slides_serveurs_carto.html#sommaire",
    "title": "Serveurs Cartographiques",
    "section": "Sommaire",
    "text": "Sommaire\n\nQu’est-ce qu’un serveur carto ?\nLes standards OGC\nPourquoi utiliser un serveur carto ?\nExemples de serveurs carto\nGeoServer\nTP - Mise en pratique"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto",
    "title": "Serveurs Cartographiques",
    "section": "Qu’est-ce qu’un serveur carto ?",
    "text": "Qu’est-ce qu’un serveur carto ?\nRappels sur ce qu’est un serveur\nLe serveur matériel (hardware) : Une ou plusieurs machines physiques reliées entre elles et et sur lesquelles fonctionnent un ou plusieurs logiciels.\nSource : Ionos\nDans ce TP, notre serveur physique sera notre ordinateur. En pratique, cela ressemble plus souvent à ça (serveurs WikiMedia foundation) :"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-1",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-1",
    "title": "Serveurs Cartographiques",
    "section": "Qu’est-ce qu’un serveur carto ?",
    "text": "Qu’est-ce qu’un serveur carto ?\nRappels sur ce qu’est un serveur\nLe serveur (software) : Un programme effectuant des interactions en réseau avec d’autres programmes appelés logiciels clients. Le service apporté dépend du logiciel serveur.\nSource : Ionos\nUn logiciel serveur peut-être un serveur Web (Apache, Nginx), un serveur email, un serveur de bases de données (PostgreSQL), un serveur cartographique (GeoServer), etc. Un logiciel client est par exemple un navigateur internet pour afficher un site web (Firefox, Google Chrome), un client mail (Thunderbird), et plus généralement une machine cliente."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-2",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-2",
    "title": "Serveurs Cartographiques",
    "section": "Qu’est-ce qu’un serveur carto ?",
    "text": "Qu’est-ce qu’un serveur carto ?\nComment le serveur communique-t-il avec les clients ?\nDans le cas des serveurs web et cartographiques, le client (par exemple notre Firefox) va envoyer des requêtes au serveur (par exemple GeoServer). Le serveur va lire la requête et renvoyer une réponse. Cette réponse peut-être une page web, un JSON, un flux cartographique, mais aussi un message d’erreur comme le fameux 404 not found.\n\nSource : codegym.cc"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-3",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-3",
    "title": "Serveurs Cartographiques",
    "section": "Qu’est-ce qu’un serveur carto ?",
    "text": "Qu’est-ce qu’un serveur carto ?\nComment le serveur communique-t-il avec la source de donnée ?\nEn réalité, la plupart des applications fonctionnent de la manière suivante : le client envoie des requêtes au serveur. Le serveur va communiquer avec la base de données, traiter le résultat et renvoyer une réponse au client.\nExemple :\n- Client = mon application Firefox\n- Serveur = les serveurs de Google\n- Database = la base de données de Google\n- Requête = cherche les sites qui correspondent à la requête “apprendre le JavaScript”\n- Réponse = liste des sites qui correspondent à la requête “apprendre le JavaScript”\n\nSource : codegym.cc"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-4",
    "href": "cours/geonum/slides_serveurs_carto.html#quest-ce-quun-serveur-carto-4",
    "title": "Serveurs Cartographiques",
    "section": "Qu’est-ce qu’un serveur carto ?",
    "text": "Qu’est-ce qu’un serveur carto ?\nLa spécificité du serveur carto\nUn serveur cartographique va servir - sans surprise - de la donnée cartographique sous forme de vecteur ou de raster, tuilée ou non. Il le fait selon des standards OGC bien définis comme le WMS (Web Map Service) et le WFS (Web Feature Service) qui vont définir la structure de la donnée récupérée et les interactions possibles avec cette couche de d‘information.\n\n\n\nSource : hansongis.com/blog/"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nLes spécifications OGC suivantes définissent ce qu’on appelle des interfaces (ou API) pour requêter des cartes géoréférencées d’un serveur.\nPas de panique - “interface” est un joli mot pour expliquer comment on doit structurer notre requête et ce qu’on recevra en réponse. Par exemple, quand on commande une glace, on sait qu’il faut indiquer pot ou cornet, le nombre de boules et le parfum de chacune. En échange, on obtiendra une glace bien structurée, prête à être dégustée. Si on veut beaucoup simplifier, l’interface fait le lien entre ce que le client aimerait et ce que le cuisinier peut lui donner en encadrant la question posée par le client et les réponses possibles du cuisinier.\nSource : Documentation GeoServer"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-1",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-1",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Map Service (WMS)\n\nLa spécification WMS fournit une interface standard pour requêter une image géoréférencée et sa légende. Le client reçoit une image géoréférencée.\nC’est le plus couramment utilisé car il est plus rapide que le WFS lorsqu’il s’agit de représenter beaucoup d’éléments.\nLa requête GetMap permet de récupérer une carte.\nLa requête GetFeatureInfo permet de récupérer la géométrie et les valeurs d’un pixel.\nLa requête GetLegendGraphic permet de récupérer la légende.\n\nSource : GeoServer WMS reference - Source : QGISserver WMS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-2",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-2",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Feature Service (WFS)\n\nLa spécification WFS fournit une interface standard pour créer, modifier et requêter de l’information géographique au format vecteur. Le client reçoit de la donnée au format GML.\nC’est celui qu’il faut utiliser dans le cas de la manipulation de vecteurs (pour les requêtes attributaires, le WMS suffit).\nLa requête GetFeature retourne une sélection de features avec leur géométrie et la valeur de leurs attributs.\nLa requête Transaction permet d’éditer une feature existante en utilisant “create”, “update” ou “delete”.\n\nSource : GeoServer WFS reference - Source : QGISserver WFS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-3",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-3",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Coverage Service (WCS)\n\nLa spécification WCS fournit une interface pour accéder à de la donnée raster. On peut le voir comme le WMS pour du raster.\nLa requête DescribeCoverage retourne un document XML qui décrit la couverture du pixel sélectionné.\nLa requête GetCoverage retourne un résultat similaire à la requête GetMap du flux WMS mais avec des extensions additionnelles pour supporter la récupération de données raster.\n\nSource : GeoServer WCS reference - Source : QGISserver WCS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-4",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-4",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nWeb Map Tile Service (WMTS)\n\nLa spécification WMTS fournit une interface pour requêter des images tuilées. Il s’agit plus ou moins de la même chose que WMS mais qui permet d’utiliser des couches tuilées.\nLa requête GetTile retourne une tuile.\nLa requête GetFeatureInfo permet de récupérer la géométrie et les valeurs d’un pixel (comme dans le cas du flux WMS).\n\nSource : QGISserver WMTS reference"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-5",
    "href": "cours/geonum/slides_serveurs_carto.html#les-standards-ogc-5",
    "title": "Serveurs Cartographiques",
    "section": "Les standards OGC",
    "text": "Les standards OGC\nDans ce TP, nous allons utiliser les flux les plus communs, WMS puis WFS."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto",
    "href": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto",
    "title": "Serveurs Cartographiques",
    "section": "Pourquoi utiliser un serveur carto",
    "text": "Pourquoi utiliser un serveur carto\n\nPermet de rester à jour - quand la donnée est mise à jour sur le serveur, toutes les applications clientes (comme une application Leaflet ou OpenLayers (OL)) récupèrent aussi la donnée à jour. C’est pratique quand on a une IDG.\nPermet de servir de la donnée depuis une base de données PostgreSQL. Au lieu de requêter la donnée en SQL, de l’exporter en JSON et de l’importer dans l’application Leaflet/OL, et de refaire ça à chaque fois que la donnée change, on peut simplement utiliser GeoServer pour générer une couche à partir de SQL.\nPermet de gérer et communiquer les métadonnées. GeoServer permet par exemple d’uploader des fiches de métadonnées pour chaque couche qu’il émet.\nLes serveurs cartographiques sont au cœur des IDG, il faut donc savoir les utiliser. Par exemple, geOrchestra propose GeoServer comme module de serveur cartographique."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto-1",
    "href": "cours/geonum/slides_serveurs_carto.html#pourquoi-utiliser-un-serveur-carto-1",
    "title": "Serveurs Cartographiques",
    "section": "Pourquoi utiliser un serveur carto",
    "text": "Pourquoi utiliser un serveur carto\nEn résumé\nOn peut se passer d’un serveur cartographique quand on a “juste” quelques features en JSON à afficher. Dès qu’on commence à avoir des couches souvent mises à jour, besoin d’accéder aux métadonnées, de plus nombreuses couches, d’importer des couches stylisées dans QGIS, de créer des couches à partir d’une base de données PostgreSQL… dans ce cas l’utilisation d’un serveur cartographique nous facilite grandement la vie.\n\nExemple 1 : data.grandlyon.com qui permet de lire directement ses couches de données en passant par son API.\nExemple 2 : les fonds de carte OMS (WMS)"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques",
    "href": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques",
    "title": "Serveurs Cartographiques",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nMapServer\nLien vers MapServer\nPlateforme Open Source pour la publication de donnée géospatiale. (J’ai peu de choses à dire dessus, je ne l’ai jamais utilisée).\nMapServer continue à exister dans les organisations qui s’en servent déjà mais ce n’est plus forcément la solution la plus populaire lorsqu’il faut partir de zéro."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-1",
    "href": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-1",
    "title": "Serveurs Cartographiques",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nGeoServer\nLien vers GeoServer\nServeur Java gratuit et Open Source qui permet aux utilisateurs de visualiser et éditer de la donnée géospatiale. La librairie OpenLayers est intégrée à GeoServer pour générer rapidement des cartes. Les capacités du serveur peuvent être étendues via l’installation d’extensions divserses.\nGeoServer est le plus simple à déployer. Il peut aussi directement se connecter avec des bases de données comme PostgreSQL - l’équipe le décrit comme étant “designé pour l’interopérabilité”. GeoServer est assez complexe à configurer mais le plus adaptable aux besoins utilisateur, notamment grâce à la gestion fine des droits utilisateurs et l’utilisation de plugins pour enrichir les possibilités."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-2",
    "href": "cours/geonum/slides_serveurs_carto.html#exemples-de-serveurs-cartographiques-2",
    "title": "Serveurs Cartographiques",
    "section": "Exemples de serveurs cartographiques",
    "text": "Exemples de serveurs cartographiques\nQGIS Server\nLien vers QGIS Server Guide Manual\nAPI gratuite et Open Source qui permet aussi d’implanter des éléments cartographiques avancés pour créer des cartes thématiques. Elle fonctionne avec un serveur web (Apache ou Nginx).\nQGIS Server est plus difficile à mettre en place (on utilisera une application tierce comme LizMap) mais est le plus compatible avec la publication de projets via QGIS. C’est la meilleure solution pour publier rapidement un projet QGIS. On le présentera rapidement dans un des TP."
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - Introduction",
    "text": "GeoServer - Introduction\n\nGeoServer est un serveur Open Source écrit en Java qui permet aux utilisateurs de partager et éditer de la donnée géospatiale.\nIl a été designé pour maximisé son interopérabilité, permettant de publier de la donnée des sources de données les plus courantes en utilisant des standards ouverts.\nGeoServer est un projet développé, testé et soutenu par sa communauté - comme dans le cas de QGIS.\nGeoServer est une référence dans l’implementation des standards WFS, WMS et WCS de l’OGC.\n\n\nSource : hansongis.com/blog/Source : GeoServer Overview"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction-1",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---introduction-1",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - Introduction",
    "text": "GeoServer - Introduction\n\nLe projet a débuté en 2001 avec le Open Planning Project (TOPP), un organisme à but non lucratif basé à New York et qui a créé une suite d’outils pour promouvoir la transparence de la donnée. Leur premier outil, GeoServer, avait pour objectif de permettre aux citoyens d’accéder aux documents de planification urbaine du gouvernement en partageant la donnée spatiale.\nAvec le temps, le projet GeoTools a été ajouté avec la possibilité de supporter les Shapefiles, les bases de données Oracle, etc.\nD’autres projets ouverts ont continué à enrichir GeoServer et ses fonctionnalités comme le développement de PostGIS (par Refractions Reseach) qui a permis de connecter GeoServer à une base de données gratuite (PostgreSQL).\nLicence : la GNU General Public License, mais contient aussi des logiciels Apache donc dépend de la Apache Software Foundation ainsi que le la Eclipse Public License, qui sont toutes très permissives.\n\nSource : GeoServer Overview"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvénients",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvénients",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - avantages et inconvénients",
    "text": "GeoServer - avantages et inconvénients\nAvantages\n\nSolution très bien documentée\nNombreux plugins qui sont bien maintenus\nPeut lire de multiple sources de données (shapefile, geopackage, connexion à une base PostgreSQL)\nOutil activement maintenu et communauté réactive\nPas difficile à déployer (comparé à d’autres)\nDocumentation riche\nUn outil en tout bien solide sur le long terme"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvénients-1",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---avantages-et-inconvénients-1",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - avantages et inconvénients",
    "text": "GeoServer - avantages et inconvénients\nInconvénients\n\nDifficile à prendre en main au début (gestion des droits, différencier les couches et les dépôts, etc.)\nL’interface est un peu vieille et pas super intuitive\nLa grande majorité des ressources est uniquement disponible en anglais (mais ça ne devrait pas vous faire trop peur !)\nVous allez parfois vous arracher les cheveux sur des fichiers de style complexes"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#geoserver---comment-utiliser-la-documentation",
    "href": "cours/geonum/slides_serveurs_carto.html#geoserver---comment-utiliser-la-documentation",
    "title": "Serveurs Cartographiques",
    "section": "GeoServer - Comment utiliser la documentation",
    "text": "GeoServer - Comment utiliser la documentation\nhttps://geoserver.org/"
  },
  {
    "objectID": "cours/geonum/slides_serveurs_carto.html#mise-en-pratique",
    "href": "cours/geonum/slides_serveurs_carto.html#mise-en-pratique",
    "title": "Serveurs Cartographiques",
    "section": "Mise en pratique",
    "text": "Mise en pratique\nPage du TP\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html",
    "href": "cours/geonum/enrichir_ma_carte.html",
    "title": "Enrichir ma carte en fonctionnalités",
    "section": "",
    "text": "Créer un menu d’affichage des couches\nInterroger une couche WMS et afficher les résultats\nFiltrer une couche WMS\nLire un flux WFS et afficher la géométrie\nCréer un curseur d’évolution temporelle\nAjouter une échelle à la carte\nPolir un peu l’interface de l’application avec du CSS\nPour aller plus loin, apprendre à utiliser des plugins OpenLayers",
    "crumbs": [
      "Enrichir ma carte en fonctionnalités"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#objectifs",
    "href": "cours/geonum/enrichir_ma_carte.html#objectifs",
    "title": "Enrichir ma carte en fonctionnalités",
    "section": "",
    "text": "Créer un menu d’affichage des couches\nInterroger une couche WMS et afficher les résultats\nFiltrer une couche WMS\nLire un flux WFS et afficher la géométrie\nCréer un curseur d’évolution temporelle\nAjouter une échelle à la carte\nPolir un peu l’interface de l’application avec du CSS\nPour aller plus loin, apprendre à utiliser des plugins OpenLayers",
    "crumbs": [
      "Enrichir ma carte en fonctionnalités"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#cours",
    "href": "cours/geonum/enrichir_ma_carte.html#cours",
    "title": "Enrichir ma carte en fonctionnalités",
    "section": "Cours",
    "text": "Cours\nAujourd’hui, c’est de la pratique. M’entendre parler pendant des heures, c’est fini !",
    "crumbs": [
      "Enrichir ma carte en fonctionnalités"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#tp---faire-une-carte-interactive-sur-le-thème-de-lexploitation-minière-et-ses-impacts-négatifs-sur-les-populations-locales",
    "href": "cours/geonum/enrichir_ma_carte.html#tp---faire-une-carte-interactive-sur-le-thème-de-lexploitation-minière-et-ses-impacts-négatifs-sur-les-populations-locales",
    "title": "Enrichir ma carte en fonctionnalités",
    "section": "TP - Faire une carte interactive sur le thème de l’exploitation minière et ses impacts négatifs sur les populations locales",
    "text": "TP - Faire une carte interactive sur le thème de l’exploitation minière et ses impacts négatifs sur les populations locales\n\n\n\n\n\n\nImportant\n\n\n\nCe TP se base sur l’architecture déployée et le code écrit au cours du TP “OpenLayers & GeoServer”.\n\n\nC’est un titre à rallonge, mais voici en gros dans quelle direction la donnée de la Land Matrix va nous permettre de partir. Nous allons nous baser sur tout ce qui a été créé lors du TD “OpenLayers & GeoServer”. Si vous n’avez pas pu suivre le TD ou que vous avez égaré vos fichiers, merci de le signaler maintenant.\n\nCréer un menu d’affichage des couches\nSi jamais vous n’aviez pas eu le temps d’afficher plus d’une couche, voici le code avec lequel j’ai commencé ce TP. N’oubliez pas de remplacer les éléments comme l’adresse de votre GeoServer ! Et si votre application affiche déjà la couche “deals” et “deals_by_country”, inutile de copier mon code, c’est plus intéressant de repartir du votre.\nindex.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"https://openlayers.org/favicon.ico\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Transition Minerals&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\nstyle.css\n@import \"node_modules/ol/ol.css\";\n\nhtml, body {\n  margin: 0;\n  height: 100%;\n}\n#map {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n}\nmain.js\nimport './style.css';\nimport {Map, View} from 'ol';\nimport { ImageWMS } from 'ol/source';\nimport TileLayer from 'ol/layer/Tile';\nimport ImageLayer from 'ol/layer/Image';\nimport OSM from 'ol/source/OSM';\n\n// WMS de mon GeoServer\nconst geoserverWms = 'http://localhost:8080/geoserver/land_matrix/wms'\n\n// Layer: Fond de carte OSM\nconst layerOsm = new TileLayer({ source: new OSM() });\n\n// Layer: deals by country\nconst layerDealsByCountry = new ImageLayer({\n  source: new ImageWMS({\n    url: geoserverWms,\n    params: { 'LAYERS' : 'land_matrix:deals_by_country' },\n    serverType: 'geoserver',\n  })\n});\n\n// Layer: deals\nconst sourceDeals = new ImageWMS({\n  url: geoserverWms,\n  params: { 'LAYERS' : 'land_matrix:deals' },\n  serverType: 'geoserver',\n});\n\nconst layerDeals = new ImageLayer({\n  source: sourceDeals\n});\n\n// Map\nconst map = new Map({\n  target: 'map',\n  layers: [ layerOsm, layerDealsByCountry, layerDeals ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\nOn souhaite maintenant créer un menu avec des cases de type “checkbox” qui vont nous permettre de choisir si on veut afficher ou masquer une couche. On doit commencer par créer cet élément dans l’interface en modifiant index.html.\n\nDéfinissez une &lt;div&gt; dans laquelle on souhaite afficher notre menu de couches et positionnez-la avec du CSS\nAjoutez à l’intérieur un input de type checkbox avec la balise &lt;input type=\"checkbox\"/&gt; et donnez lui un label avec le nom de la couche\n\nComme c’est la première fois qu’on doit écrire du HTML ensemble, je vous guide pas à pas. Commencez par ouvrir index.html et ajouter sous la div de votre carte (la div map) une autre div, comme ceci :\n&lt;div id=\"layers\" class=\"menu\"&gt;&lt;/div&gt;\nOn crée une nouvelle div dont l’identifiant est layers, ce qui nous permettra de la retrouver par la suite. On lui a aussi ajouté une classe qu’on appelle menu et qui nous permettra d’appliquer un seul style à tous nos éléments de menu. Si c’est un peu flou maintenant, vous comprendrez plus tard en ajoutant d’autres menus.\nComme notre div est vide, on ne la voit pas. Ça va être difficile de la positionner ailleurs sur la carte. J’ai l’habitude de mettre un peu n’importe quoi à l’intérieur, juste le temps de régler mon CSS correctement. Ma div ressemble donc à :\n&lt;div id=\"layers\" class=\"menu\"&gt;cthulhu fhtagn&lt;/div&gt;\nOn pourra retirer le texte après. Vous remarquerez qu’on ne voit toujours pas notre texte. Essayez de rafraîchir la page - vous devriez le voir tout en haut à gauche de l’écran avant que la carte ne le recouvre ! C’est normal, nous n’avons pas “positionné” notre élément. Ce n’est pas un cours de CSS donc on ne rentrera pas dans les détails. Ouvrez styles.css et ajoutez le code suivant :\n.menu {\n  position: absolute;\n}\nOn sélectionne toutes les balises html avec la classe menu et on leur applique un positionnement absolu. Sauvegardez et vous devriez voir apparaître le texte. Super ! Mais… c’est moche et ça ne ressemble pas DU TOUT à un menu. Pas de souci, on y arrive. Ajoutez les éléments suivants (j’ai commenté le code pour vous aider à comprendre) :\n.menu {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  right: 20px;\n\n  /* Padding */\n  padding: 8px;\n\n  /* Dimensions minimales */\n  min-height: 80px;\n  min-width: 160px;\n\n  /* Rectangle blanc avec coins arrondis */\n  background-color: white;\n  border-radius: 8px;\n}\nAh, c’est déjà plus sympa ! On va même pouvoir supprimer le texte de notre balise HTML dans index.html. En gros, voilà ce que je fais avec ce code CSS :\n\nJ’indique que l’élément a une position absolue dans le body (donc pas relative à un élément) et qu’il doit se trouver à 20 pixels du haut (top) et 20 pixels de la droite (right) de l’écran.\nJe donne un padding, une marge intérieur, à mon élément de menu. Pour mieux comprendre, essayez de supprimer cette ligne et regardez ce qui change.\nJe donne une hauteur et une largeur minimales à mon élément pour éviter qu’il ne disparaîsse quand il est vide. Par défaut, mon élément aurait grandi et rétréci avec son contenu.\nJ’ai donné un peu de style à mon menu en lui donnant un fond blanc et des coins arrondis.\n\nVoilà globalement le niveau maximum de difficulté du CSS que je vais vous demander pour styliser votre application, mais vous pouvez évidemment allez plus loin !\nMaintenant qu’on a un menu, il va falloir ajouter la checkbox qui permettra d’afficher ou masquer ma couche. Retournez dans index.html et ajoutez la balise &lt;input&gt; et son &lt;label&gt; dans notre &lt;div id=\"layers&gt;, comme ceci :\n&lt;div id=\"layers\" class=\"menu\"&gt;\n  &lt;input type=\"checkbox\" id=\"checkbox-countries\" name=\"checkbox-countries\" checked /&gt;\n  &lt;label for=\"checkbox-countries\"&gt;Deals by countries&lt;/label&gt;\n&lt;/div&gt;\nVérifiez que vous pouvez cliquer sur la checkbox pour la cocher/décocher. L’interface est prête ! Il faut maintenant qu’on parvienne à dire à notre application qu’il faut afficher ou masquer la couche deals_by_country en fonction.\n🤔 On doit d’abord se demander comment s’y prendre pour masquer une couche dans OpenLayers.\nOn va se servir des méthodes qui sont disponibles pour tous les objets Layer de OpenLayers. La documentation nous apprend l’existence de la méthode setVisible(). Voilà ce qu’on nous en dit :\n\n\n\n\n\nLa méthode setVisible() prend un argument visible. Cet argument est de type “boolean”, il peut donc prendre la valeur true ou false. On va faire le test et utiliser cette fonction pour faire disparaître notre couche. Allez dans main.js et ajouter cette ligne à la fin de votre script :\nlayer_deals_by_country.setVisible(false);\nAttention ! layer_deals_by_country est le nom de la variable dans laquelle j’ai créé ma couche “deals_by_country”. Si vous avez nommé votre couche différemment, n’oubliez pas de changer le nom !\nNormalement, la couche ne devrait plus être visible sur la carte. Super, la méthode a fonctionné ! Il ne nous reste plus qu’à “connecter” cette méthode à notre élément checkbox.\nOn l’a déjà vu dans le TP Serveurs cartographiques (lorsqu’on affichait la légende des couches), il est possible de trouver un élément HTML et de le modifier en utilisant du JavaScript. Pour trouver un élément, le plus facile est de rechercher son identifiant id. Ajoutez en bas de main.js :\nconst checkbox_countries = document.getElementById('checkbox-countries');\nconsole.log(checkbox_countries);\nSauvegardez et allez dans la console de votre navigateur. Vous devriez voir apparaître votre tag &lt;input&gt; dans la console. Si vous le survolez avec la souris, la checkbox devrait être passée en surbrillance. Si ça fonctionne, parfait ! Ça veut dire qu’on arrive bien à récupérer notre élément de checkbox. Maintenant, on souhaite exécuter du code lorsque son statut “checked” change. Pour cela, on doit “écouter” la checkbox pour savoir si l’évènement “change” a eu lieu.\nconst checkboxCountries = document.getElementById('checkbox-countries');\n\ncheckboxCountries.addEventListener('change', (event) =&gt; {\n  if (event.currentTarget.checked) {\n    // On fait des trucs quand la checkbox est checkée\n    console.log(\"Checked\");\n  } else {\n    // On fait des trucs quand la checkbox n’est PAS checkée\n    console.log(\"Pas checked\");\n  }\n});\n\naddEventListener indique qu’on souhaite “écouter” les évènements de notre checkbox. On précise le type d’évènement avec le premier paramètre, 'change'.\nLa condition if vérifie si notre checkbox est checkée ou non. On récupère cette information grâce à event.current.checked. Si cette condition est true, on affiche “Checked” dans la console. Si cette condition est false, on affiche “Pas checked”.\n\nEssayez ! Cliquez sur la checkbox et surveillez votre console. On voit bien s’afficher les messages. On y est presque ! Maintenant, au lieu d’afficher du texte, on souhaite afficher la couche quand la condition est true et la masquer quand la condition est false.\nconst checkboxCountries = document.getElementById('checkbox-countries');\n\ncheckboxCountries.addEventListener('change', (event) =&gt; {\n  if (event.currentTarget.checked) {\n    // On fait des trucs quand la checkbox est checkée\n    layer_deals_by_country.setVisible(true);\n  } else {\n    // On fait des trucs quand la checkbox n’est PAS checkée\n    layer_deals_by_country.setVisible(false);\n  }\n});\n\n\n\n\n\n\nPensez bien à…\n\n\n\n\nChanger le nom de la couche layer_deals_by_country si vous n’avez pas appelé votre couche comme ça.\nSupprimer la ligne layer_deals_by_country.setVisible(false); toute seule au dessus ou votre couche sera masquée par défaut au moment de charger la carte.\n\n\n\nVoilà, on peut désormais afficher et masquer la couche à volonté !\n\n\n\n\n\nÀ vous ! Créez une autre checkbox qui permet d’afficher ou masquer la couche deals. J’aimerais que cette checkbox soit au-dessus de la première !\n\n\n\n\n\n\nTip\n\n\n\nSauf indication contraire (via du CSS), les éléments HTML sont affichés dans l’ordre dans lequel ils sont déclarés.\n&lt;div id=\"2\"&gt;&lt;/div&gt;\n&lt;div id=\"1\"&gt;&lt;/div&gt;\nDans cet exemple, ma div 1 sera plus bas que ma div 2. Ça devrait vous aider !\n\n\n\n\nInterroger une couche WMS et afficher les résultats\nOn souhaite maintenant interroger la couche deals en cliquant dessus. Cette étape est plus compliquée que la précédente car elle va nous demander d’utiliser fetch(), on va donc là-aussi procéder petit à petit pour bien comprendre ce qu’on fait. Ouvrez l’exemple OpenLayers WMS GetFeatureInfo (Image Layer).\nCommençons par s’intéresser à cette partie du code :\nmap.on('singleclick', function (evt) {\n  document.getElementById('info').innerHTML = '';\n  const viewResolution = /** @type {number} */ (view.getResolution());\n  const url = wmsSource.getFeatureInfoUrl(\n    evt.coordinate,\n    viewResolution,\n    'EPSG:3857',\n    {'INFO_FORMAT': 'text/html'},\n  );\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((html) =&gt; {\n        document.getElementById('info').innerHTML = html;\n      });\n  }\n});\n\n.on('singleclick') permet d’exécuter une fonction lorsqu’on clique sur la carte.\ndocument.getElementById() récupère l’élément ‘info’ dans lequel ils affichent leurs résultats.\nOn récupère la résolution de la vue de la carte grâce à la méthode dans viewResolution. On a besoin de passer cette résolution dans la fonction suivante.\nOn récupère l’url qui contient les informations de l’élément cliqué avec la méthode getFeatureInfoUrl() de la source de données.\nSi notre url est définie, alors on utilise la fonction fetch() pour récupérer la donnée à partir de cette adresse.\ndocument.getElementById() récupère à nouveau l’élément ‘info’ et définir la valeur de son innerHTML pour pouvoir afficher les résultats.\n\nCompliqué ? Non, ça va aller ! On va tranquillement réécrire cette fonction pour la couche deals. Pour rappel, voici comment j’appelle la couche deals dans mon code :\nconst sourceDeals = new ImageWMS({\n  url: geoserverWms,\n  params: { 'LAYERS' : 'land_matrix:deals' },\n  serverType: 'geoserver',\n});\n\nconst layerDeals = new ImageLayer({\n  source: sourceDeals\n});\nJe commence donc par exécuter une fonction lorsque je clique sur la carte :\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"J’ai cliqué sur la carte !\");\n});\nSauvegardez, gardez la console de votre navigateur ouverte et cliquez sur la carte pour vérifier que le message apparaît bien. Si c’est bon, on vient d’apprendre comment exécuter des fonctions en cliquant sur la carte ! On sait ensuite que dans l’exemple ils utilisent la méthode getFeatureInfoUrl() de leur source de données pour récupérer les informations des features. Ouvrez la documentation de ImageWMS on va en avoir besoin. Voilà ce qu’elle nous dit au sujet de la méthode fetFeatureInfoUrl() :\n\n\n\n\n\nLa méthode prend plusieurs paramètres :\n\ncoordinate, les coordonnées visées par le clic de l’utilisateur\nresolution, la résolution de la carte (liée à la view de ma carte)\nprojection, le système de projection de la carte : “EPSG:3857’”\nparams, un objet contenant plusieurs paramètres comme le format désiré du résultat ou encore les couches qu’on souhaite interroger\n\nRécupérons ces éléments dans l’ordre en commençant par les coordonnées. Dans l’exemple, ils référencent directement la source de coordonnées evt.coordinate dans la fonction mais ça va un peu vite. Pour mieux comprendre, on va stocker les coordonnées de notre évènement (= notre clic) dans une constante.\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"J’ai cliqué sur la carte !\");\n  \n  const coord = event.coordinate;\n});\nEn fait, l’évènement ‘singleclick’ de la carte map permet de récupérer les coordonnées du clic en accédant à sa propriété coordinate. On écrit donc event.coordinate.\n\n\n\n\n\n\nPourquoi on a “event” et pas “evt” ?\n\n\n\n\n\nJ’ai fait exprès de changer le nom du paramètre pour appeler tous les évènements “event” dans notre code et pour ajouter cette petite note. En fait, quand on crée une fonction, on peut nommer notre paramètre comme on veut. Par exemple, dans le code suivant :\nmap.on('singleclick', (event) =&gt; {\n  const coord = event.coordinate;\n});\n… la variable coordinates a la même valeur que si j’écris :\nmap.on('singleclick', (evt) =&gt; {\n  const coord = evt.coordinate;\n});\n… ou encore :\nmap.on('singleclick', (mon_evenement_qui_vient_de_ma_carte_avec_mon_clic) =&gt; {\n  const coord = mon_evenement_qui_vient_de_ma_carte_avec_mon_clic.coordinate;\n});\nBien sûr, si vous ne vous sentez pas encore trop en confiance, inutile de renommer ce genre d’éléments pour uniformiser le code. Vous pouvez garder ce que vous voyez dans le code OpenLayers.\n\n\n\nAprès les coordonnées, on récupère la résolution. On sait qu’on lit la résolution depuis la vue de la carte, donc on peut d’abord récupérer cette vue PUIS lire sa résolution (toujours dans notre fonction, pas à l’extérieur !) :\nconst view = map.getView();\nconst res = view.getResolution();\nOn peut aussi enchaîner les méthodes comme ceci :\nconst res = map.getView().getResolution();\n\n\n\n\n\n\nPourquoi on ne reprend pas le /** @type */ du code original ?\n\n\n\n\n\nParce qu’on n’en est pas à faire du TypeScript ! Ils ont fait un excès de zèle dans cet exemple. Cette syntaxe étrange signifique que le type de la constante est de type “number”, donc un nombre. Mais ça on le sait déjà de toute façon, on a lu la documentation.\n\n\n\nOn est à mi-chemin et le reste est très simple. La projection doit être indiquée par une chaîne de caractères :\nconst proj = 'EPSG:3857';\nEt on reprend les paramètres de l’exemple pour indiquer qu’on veut récupérer notre réponse au format HTML. Par défaut, GeoServer renverra la table attributaire de l’élément sous forme d’un tableau en HTML.\nconst parametres = {'INFO_FORMAT': 'text/html'};\nOn a tous nos éléments, il ne nous reste qu’à appeler la méthode getFeatureInfoUrl() sur notre source de données (attention, pas la couche !) pour générer l’url qui nous permettra de récupérer la réponse. La documentation nous indique que les paramètres doivent être renseignés dans l’ordre suivant :\n\ncoordinate\nresolution\nprojection\nparams\n\nconst url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\nOu encore, pour ressembler à l’exemple :\nconst url = sourceDeals.getFeatureInfoUrl(\n  coord,\n  res,\n  proj,\n  parametres\n);\nPour récapituler, voilà à quoi ressemble ma fonction pour le moment. J’ai ajouté un console.log() pour voir l’url s’afficher dans ma console et donc bien vérifier que j’arrive à générer cette adresse.\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"J’ai cliqué sur la carte !\");\n\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n  const parametres = {'INFO_FORMAT': 'text/html'};\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  console.log(url);\n});\nAttention, voilà la partie plus compliquée : maintenant qu’on a une addresse, on doit utilier la fonction fetch() pour récupérer la donnée. C’est une fonction bien particulière. Elle est dite “asynchrone” car elle ne bloque pas le reste du code lorsqu’elle tourne, contrairement aux autres fonctions “synchrones”. Si j’écris une fonction reboursSynchrone(), l’exécution de mon code et donc mon application est bloquée pendant que la fonction s’exécute. Si c’est une petite fonction rapide ça ne pose pas de problème. Si c’est quelque chose de plus lent, par exemple qui demande d’attendre la réponse d’un serveur dans le cas de notre fetch, notre application est bloquée et on est bien embêtés. Au contraire, si j’écris une fonction reboursAsynchrone() l’application n’attendra pas que la fonction ait terminé de s’exécuter pour pouvoir continuer de fonctionner.\nDu coup, l’asynchrone, c’est très pratique ! Par contre, comme c’est particulier et qu’il est plus difficile de prévoir quand elle va terminer son exécution et si elle va rencontrer des erreurs ou non, on va devoir lui réserver un traitement particulier. Reprenons le code de l’exemple pour l’expliquer petit à petit.\nfetch(url)\n  .then((response) =&gt; response.text())\n  .then((html) =&gt; {\n    // J’ai modifié la ligne suivante pour simplifier, on s’intéressera à elle un peu plus tard\n    console.log(\"C’est une réussite !\");\n  });\nVous noterez l’utilisation de méthodes .then() qui contiennent des fonctions. Ce sont les fonctions à exécuter quand le maillon précédent de la chaîne a fini de se résoudre. Si on devait écrire en langage courant ce que signifie ce code, voilà ce que ça donnerait :\n\nfetch(url) → “Récupère les informations qui sont disponibles à cette adresse”\n.then((response) =&gt; response.text()) → “Ensuite (”then”), quand tu as réussi à récupérer la réponse, stocke-la dans une variable que j’appelle “response” puis utilise sa méthode .text() pour récupérer du texte au format HTML”\n.then((html) =&gt; { console.log(\"C’est une réussite !\"); }) → “Ensuite, quand tu as réussi l’étape précédente, stocke le texte au format HTML de l’étape précédente dans une variable que j’appelle”html” et affiche un message dans ma console”\n\nVous noterez que j’ai précisé que .then() s’exécute si l’étape précédente a réussi. Si ce n’est pas le cas, l’exécution de notre chaîne de méthodes fetch() s’arrête et un message d’erreur s’affiche dans la console. Comme on a plutôt confiance en notre GeoServer, on peut se lancer et exécuter ce fetch() mais attention, seulement si on a bien une addresse à interroger ! Si la variable url est undefined, notre application risque de péter les plombs. On ajoute une condition autour du fetch() pour éviter les erreurs :\nif (url) {\n  fetch(url)\n    .then((response) =&gt; response.text())\n    .then((html) =&gt; {\n      console.log(\"C’est une réussite !\");\n      console.log(html);\n    });\n}\nVous pouvez tester les console.log(). Le HTML qu’on obtient n’est pas très gracieux tel quel, il vaudrait mieux l’afficher dans l’interface de l’application !\n\n\n\n\n\n\nAu secours, je n’ai toujours pas compris fetch()\n\n\n\n\n\n\n\n\n\n\nSi votre cerveau est un peu comme ça quand on parle de fetch(), n’hésitez pas à m’appeler pour avoir une nouvelle explication. J’ai peur de ne pas pouvoir faire mieux par écrit. La notion de fonction asynchrone est complexe et j’ai mis pas mal de temps à la comprendre, donc en deux minutes en plein milieu d’un TP c’est encore pire.\nSinon, vous pouvez continuer le TP, on aura d’autres occasion d’utiliser fetch(). Peut-être que les autres exemples seront plus clairs !\n\n\n\nQuand on doit afficher un nouvel élément dans l’interface, il faut toujours penser à créer une nouvelle balise HTML (souvent une &lt;div&gt;) pour le mettre à l’intérieur. Comme pour l’exemple précédent, on crée une div dans le HTML. Je place la mienne après &lt;div id=\"layers\"&gt; et je remets n’importe quoi dedans juste pour la voir dans mon interface.\n&lt;div id=\"attributes\" class=\"menu\"&gt;cthulhu ftaghn&lt;/div&gt;\nSauvegardez et regardez l’application. Et là, horreur ! Notre menu de couches est remplacé par la nouvelle div qu’on vient de créer ! C’est normal, elles ont le même style car on a aussi appelé class=\"menu\" dans la div. Le problème, c’est que dans styles.css, on voit que tous nos menus sont positionnés au même endroit : regardez top et right.\n.menu {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  right: 20px;\n\n  /* Padding */\n  padding: 8px;\n\n  /* Dimensions minimales */\n  min-height: 80px;\n  min-width: 160px;\n\n  /* Rectangle blanc avec coins arrondis */\n  background-color: white;\n  border-radius: 8px;\n}\nOn va donc devoir positionner nos deux &lt;div&gt; indépendamment l’une de l’autre. Pour les sélectionner individuellement, on peut utiliser le sélecteur # qui permet de chercher par id. Voilà mon code :\n.menu {\n  /* Padding */\n  padding: 8px;\n\n  /* Dimensions minimales */\n  min-height: 80px;\n  min-width: 160px;\n\n  /* Rectangle blanc avec coins arrondis */\n  background-color: white;\n  border-radius: 8px;\n}\n\n#layers {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  right: 20px;\n}\n\n#attributes {\n  /* Positionnement dans le body */\n  position: absolute;\n  top: 20px;\n  left: 20px;\n}\nVoilà, maintenant .menu me permet de définir un padding, des dimensions minimales, une couleur de background et des coins arrondis pour tous mes éléments avec la classe class=\"menu\", mais par contre j’ai bien positionné indépendamment mon menu de layers et ma nouvelle div attributes.\nMaintenant, modifiez le style de #attributes pour l’afficher en bas de la carte et sur toute la largeur de l’écran. Il nous faut beaucoup d’espace pour afficher notre table.\nC’est bon, vous avez une &lt;div id=\"attributes\"&gt; qui vous plaît ? Vous pouvez supprimer le texte qui était dans la div, on n’en aura plus besoin. Maintenant, on cherche à dire à notre application : “Prends le texte HTML que je récupère grâce à ma fonction et mets-le dans ma div Attributes”. On a formulé notre idée en langage naturel, on va maintenant pouvoir l’écrire en JavaScript. D’abord, on se demande à quel endroit dans notre code on récupère ce HTML. Souvenez-vous :\n// Interroger la couche deals et afficher les résultats\nmap.on('singleclick', (event) =&gt; {\n  console.log(\"J’ai cliqué sur la carte !\");\n\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n  const parametres = {'INFO_FORMAT': 'text/html'};\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((html) =&gt; {\n        // Dans cette fonction, on a accès à notre \"html\" !\n        console.log(\"C’est une réussite !\");\n        console.log(html);\n      });\n  }\n});\nVous voyez mon commentaire ? C’est dans cette fonction qu’on va écrire notre code. Zoomons sur cette petite partie :\n      .then((html) =&gt; {\n        // Dans cette fonction, on a accès à notre \"html\" !\n        console.log(\"C’est une réussite !\");\n        console.log(html);\n      });\nSi je traduis le texte précédent en langage naturel, pour rappel, ça fait :\n\nQuand tu as réussi l’étape précédente (souvenez-vous de then), alors stocke le résultat dans une variable html et :\nAffiche “C’est une réussite !” dans ma console\nAffiche le contenu du HTML dans ma console\n\nOn aimerait remplacer les deux dernières étapes par “affiche le HTML dans mon interface”. Pour cela, on utilise la ligne de code suivante (à ajouter au bon endroit dans la fonction) :\ndocument.getElementById('attributes').innerHTML = html;\nSuper, vous savez maintenant requêter une couche WMS ! Le résultat est un peu moche pour le moment mais vous pourrez revenir plus tard pour l’affiner. Si vous finissez le TP en avance, revenez sur les sections “Pour aller plus loin…”.\n\n\n\n\n\n\nPour aller plus loin…\n\n\n\n\n\nSi vous avez déjà fait le tour du TP, vous allez trouver dans cette section des éléments supplémentaires pour aller plus loin.\nEn cours de rédaction\n\n\n\n\n\nFiltrer des couches WMS\nOn a vu dans l’étape précédente qu’il était possible de requêter une couche WMS. Vous ne serez donc pas surpris d’apprendre qu’il est aussi possible de filtrer ces couches ! Les flux WMS ont beau retourner une image, on constate maintenant qu’elles ne manquent pas d’interactivité.\nGeoServer permet d’ajouter des filtres écrits au format cql à la requête pour lui dire “applique ce filtre à ma couche avant de m’envoyer le résultat”. Le filtrage se fait donc du côté du serveur. Vous pouvez trouver les spécifications WMS avec cql_filter ici et le tutoriel de filtrage là mais comme c’est une notion un peu complexe à appliquer seul, on va une fois de plus procéder étape par étape ensemble.\nDans votre GeoServer, prévisualisez la couche deals et cliquez sur les ... bleus en haut à gauche de la carte. Vous devriez voir plusieurs nouvelles options apparaître dont une qui s’appelle “Filter:”. L’option “CQL” devrait déjà être sélectionnée, gardez-la. C’est ce qu’on va utiliser pour la suite.\n\n\n\n\n\nCollez le texte suivant dans le champ CQL et cliquez sur “Appliquer” :\ndeal_size &gt; 10000\nNormalement, vous avez vu certains points disparaître. Il ne vous reste plus que les deals de plus de 10 000 hectares. Si vous avez un doute, vous pouvez vérifier en cliquant sur les points pour afficher leurs attributs. C’est facile, non ? Essayez les filtres suivant et essayez de comprendre à quoi ils peuvent servir :\nsilver = true\ntarget_country = 'Argentina'\ntarget_country = 'Argentina' OR target_country = 'Philippines'\n\n\n\n\n\n\nImportant\n\n\n\nQuand vous écrivez des chaînes de caractères dans un filtre CQL (“string”), il faut impérativement utiliser les guillemets simples 'my_string' et pas les doubles \"my_string\".\nNe me demandez pas pourquoi, ce n’est pas expliqué, il faut juste l’accepter et vivre avec.\n\n\nBien, vous savez maintenant écrire un filtre simple en CQL, mais comment est-ce qu’on fait pour filtrer la couche depuis notre application OpenLayers ? Voici mon code pour appliquer à ma couche deals un filtre qui va uniquement récupérer les mines qui produisent de l’or (Gold) ou de l’argent (Silver). Comparez ce snippet avec votre code pour comprendre où mettre ce code et ce qu’il fait :\nconst sourceDeals = new ImageWMS({\n  url: geoserverWms,\n  params: {\n    'LAYERS' : 'land_matrix:deals',\n    \"CQL_FILTER\" : \"target_country = 'Argentina' OR target_country = 'Philippines'\",\n  },\n  serverType: 'geoserver',\n});\n\n\n\n\n\n\nImportant\n\n\n\nSi vous vous êtes contenté de copier-coller tout ça dans votre code, c’est raté ! Il faut regarder mon snippet de code pour comprendre ce que vous devez ajouter à votre code existant !\n\n\nSauvegardez et regardez votre carte. Si vous avez compris ce que fait mon CQL, vous devriez rapidement être capables de dire si le filtre a fonctionné ou non. Vous voyez, filtrer un flux WMS, c’est facile !\nMaintenant, modifiez votre code pour afficher uniquement des mines qui produisent de l’or. Je vous donne deux indices : regardez la table attributaire de la couche deals et souvenez vous que “or” se dit “Gold” en anglais. Pour ceux qui ont eu des consoles portables, il y a une licence vidéoludique bien pratique pour retenir des noms de minéraux en anglais :\n\n\n\n\n\n(Si vous êtes capable d’entendre ce GIF juste en le regardant, vous commencez à être vieux aussi, désolée. Quoi qu’il en soit, j’espère que les interruptions GIFs vous font un peu décompresser.)\nMaintenant que vous savez filtrer la couche, vous pouvez ajouter un peu plus d’interactivité à votre carte. On va afficher un menu avec des boutons de type “radio” pour sélectionner des filtres. Je vous fais un schéma moche à la main pour vous aider à comprendre.\n\n\n\n\n\nVous voyez où on veut en venir ? Comme on commence à avoir l’habitude de faire des menus, je vous laisse créer et positionner celui-ci avec un peu de HTML et de CSS et on passe directement à l’ajout des boutons. On va devoir mettre dans notre élément &lt;div&gt; plusieurs boutons radio avec la balise &lt;input type=\"radio\"&gt;. Voilà le code pour les éléments “Or” et “Argent” :\n    &lt;!-- Radio button menu - production --&gt;\n    &lt;div id=\"production\" class=\"menu\"&gt;\n  \n      &lt;div&gt;\n        &lt;input type=\"radio\" id=\"button-gold\" name=\"produce\" value=\"gold\" /&gt;\n        &lt;label for=\"gold\"&gt;Or&lt;/label&gt;\n      &lt;/div&gt;\n  \n\n      &lt;div&gt;\n        &lt;input type=\"radio\" id=\"button-silver\" name=\"produce\" value=\"silver\" /&gt;\n        &lt;label for=\"silver\"&gt;Argent&lt;/label&gt;\n      &lt;/div&gt;\n\n    &lt;/div&gt;\nVous noterez plusieurs choses :\n\n&lt;input&gt; et &lt;label&gt; vont par paires\nla balise &lt;label&gt; contient le nom en français de mon élément, c’est ce qui s’affiche dans l’application\ntoutes les balises &lt;input&gt; on la même propriété name=\"produce\", on dirait donc qu’il vaut mieux continuer dans ce sens\non a une propriété id unique à chaque &lt;input&gt; qui nous permettra, au besoin, d’aller les chercher avec du JavaScript\nla propriété value de mes &lt;input&gt; semble correspondre à des colonnes de la table attributaire de ma couche\n\nAvec ces éléments, ajoutez les boutons pour Charbon, Lithium et Cobalt comme indiqués sur mon schéma plus haut. Attention à bien mettre Charbon en haut ! Quand c’est terminé, allez sur votre carte et cliquez un peu sur ces boutons radio. Normalement, vous ne pouvez pas sélectionner plus d’un seul élément à la fois au sein du groupe. Votre application sait que tous ces boutons font partie du même groupe car vous leur avez tous donné la même valeur name=\"produce\". Si vous commencez à modifier cette valeur, vous verrez apparaître un comportement indésirable.\nUne fois que votre menu est prêt, bien positionné sur la carte et que vos cinq boutons radio fonctionnent, on va pouvoir passer au JavaScript. Comme d’habitude, on va exprimer notre besoin en langage naturel : “Lorsque je sélectionne un minéral, je souhaite modifier le filtre de ma couche deals pour récupérer uniquement les deals qui produisent les minéraux sélectionnés”.\nPour rappel, voici les éléments dont on dispose :\n\non a des boutons radio avec une valeur value qui correspond à une colonne de la table attributaire\nvous avez déjà une couche qui filtre les deals qui produisent de l’or avec un filtre CQL\nle filtre CQL est tout simplement une chaîne de caractères (string)\n\nLe résultat auquel on voudrait arriver, c’est donc : “Mon CQL dans les params de la source de ma couche deals change dès que je sélectionne un nouveau minéral”.\nÇa tombe bien ! La documentation de la source ImageWMS (celle qu’on utilise pour notre couche) nous apprend qu’il existe une méthode .updateParams() qui permet de mettre à jour les paramètres d’une couche.\nCommencez par ajouter ces deux éléments en bas de main.js. Souvenez-vous de la manière dont on a “écouté” notre checkbox du premier exercice de ce TP. Le code ressemble beaucoup, non ?\nconst buttonGold = document.getElementById('button-gold');\n\nbuttonGold.addEventListener('change', () =&gt; {\n  console.log(\"Test\");\n});\nVoici ce que font les deux éléments du code :\n\nla première ligne récupère mon bouton radio qui grâce à son identifiant en utilisant la méthode .getElementById() que vous avons déjà vue précédemment\nles trois lignes suivantes nous permettent d’écouter notre bouton radio grâce à .addEventListener() et d’exécuter une fonction quand le bouton radio est coché, et la fonction affiche “Test” dans la console de développement\n\nOn y est presque. On arrive à exécuter quelque chose quand on sélectionne “Or” dans notre carte, mais ça ne nous permet pas de filtrer la couche. On va retirer notre console.log() et demander à JavaScript de modifier les paramètres de la source de notre couche deals grâce à la ligne suivante :\nsourceDeals.updateParams({ 'CQL_FILTER' : 'gold=true' });\nPour rappel, la source de mes deals est stockée dans la variable sourceDeals mais attention, il est possible que la votre porte un autre nom. Pensez à vérifier !\nHistoire de pouvoir tester au moins avec les boutons “Or” et “Argent”, je vous donne un snippet de code plus complet. Inspirez-vous aussi des commentaires que je laisse, je rappelle que j’attends un code commenté pour l’évaluation !\n// Or\nconst buttonGold = document.getElementById('button-gold');\nbuttonGold.addEventListener('change', () =&gt; {\n  // Quand l’utilisateur clique sur le bouton \"Or\", je mets à jour mon filtre CQL\n  sourceDeals.updateParams({ 'CQL_FILTER' : 'gold=true' });\n});\n\n// Argent\nconst buttonSilver = document.getElementById('button-silver');\nbuttonSilver.addEventListener('change', () =&gt; {\n  sourceDeals.updateParams({ 'CQL_FILTER' : 'silver=true' });\n});\nTestez l’application en cliquant alternativement sur les boutons radio de Or et Argent. Si les deux couches sont différentes, super, ça fonctionne !\nMaintenant que vous avez compris comment faire, faites les étapes suivantes (et souvenez-vous que c’est à vous que je demande, pas à Chat-GPT, je vous ai quand même déjà bien mâché le travail avec l’exemple ci-dessus !).\n\non a créé un filtre fonctionnel pour Or et Argent, maintenant faites la même chose pour toutes les autres options\nquand vous avez terminé, rajoutez une option “Tous” avec la valeur value=\"all\" et faites en sorte qu’il affiche tous les deals (je vous ai mis des indices ci-dessous si vous avez du mal mais essayez d’abord de réfléchir sans)\n\n\n\n\n\n\n\nIndice 1 - ajouter l’option “Tous”\n\n\n\n\n\nSouvenez vous : si vous voulez ajouter un élément à l’interface, commencez par index.html.\n\n\n\n\n\n\n\n\n\nIndice 2 - filtrer “Tous”\n\n\n\n\n\nComme on écrit du code JavaScript, on doit le faire dans main.js. Comme pour les autres options, vous pouvez récupérer le bouton radio avec .getElementById() puis l’écouter avec .addEventListener().\nPour ce qui est du filtre CQL : si on veut tous les deals, il suffit que notre filtre soit vide. Donc vous devriez avoir quelque part une chaîne de caractères (string) vide.\n\n\n\nUne fois que c’est terminé et que vous avez un beau menu fonctionnel pour filtrer vos couches, on peut passer à la suite !\n\n\nDes cercles proportionnels avec un flux WFS\nOn commence à avoir fait le tour des interactions basiques avec les flux WMS, qui pour rappel nous envoient des images. Mais, si vous vous souvenez bien, on a aussi évoqué dans le premier cours la possibilité de récupérer non pas une image mais des vecteurs grâce aux flux WFS. C’est ce qui va nous intéresser maintenant : notre objectif va être d’afficher notre couche deals_by_country_centroid et de la styliser pour afficher des cercles proportionnels. Et vous allez voir que récupérer une couche WFS avec OpenLayers, c’est du gâteau.\nJe vous donne la structure du code à écrire dans main.js. N’oubliez pas que les éléments encadrés par des chevrons \"&lt;un_truc&gt;\" doivent être remplacés par une vraie valeur. Par exemple, si je vous écris const formation = \"&lt;ma_formation&gt;\", vous devrez mettre dans votre code const formation = \"geonum\". Facile ! Voilà donc le snippet de base :\n// N’oubliez pas de mettre un commentaire pour m’expliquer ce que vous faites\nconst sourceCentroid = new VectorSource({\n  format: new GeoJSON(),\n  url: '&lt;mon_flux_wfs&gt;'\n});\n\nconst layerCentroid = new VectorLayer({\n  source: sourceCentroid,\n});\n… et les imports à ajouter tout en haut du fichier :\nimport VectorSource from 'ol/source/Vector';\nimport GeoJSON from 'ol/format/GeoJSON.js';\nimport VectorLayer from 'ol/layer/Vector';\nVous remarquez que vous avons un élément &lt;mon_flux_wms&gt; à remplacer. Pour trouver l’URL de ce flux, allez dans votre interface GeoServer, sélectionnez “Prévisualisation de la couche”. Cette fois, au lieu de choisir “OpenLayers” (qui nous donne le flux WMS), allez dans la colonne “Tous les formats” et sélectionnez GeoJSON. Je rappelle qu’on ne travaille plus sur la couche deals mais bien sur la couche deals_by_country_centroid. Il ne vous reste plus qu’à copier l’URL dans votre navigateur : c’est la valeur de url dans votre VectorSource().\n\n\n\n\n\n\nOups, j’ai oublié de retirer les chevrons “&lt;” en collant mon url\n\n\n\n\n\n\n\n\n\n\n\n\n\nIl ne reste plus qu’une seule étape pour afficher la couche sur la carte. Je vous laisse trouver laquelle !\n\n\n\n\n\n\nAllez, un petit indice ?\n\n\n\n\n\nVous l’avez déjà fait plusieurs fois dans le TP précédent et celui-ci, et c’est souvent une étape qu’on oublie.\n\n\n\n\n\n\n\n\n\n\n\nJe ne trouve vraiment pas…\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPromis, j’ai vraiment cherché !\n\n\n\n\n\nBon, d’accord. Dites-moi, comment se porte l’attribut layers de votre objet map ?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUne fois cette étape complétée, la couche devrait apparaître sur votre carte. Super ! Par contre, ça ressemble certainement à des cercles blancs, un peu transparents, avec un contour bleu. Et surtout, ce ne sont pas des cercles proportionnels !\nHeureusement, vous avez été bien attentifs pendant vos cours de Leaflet et vous avez déjà stylisé des couches à partir de donnée GeoJSON, ça devrait être super facile pour vous. Comme la documentation GeoServer n’est pas très claire sur ce point, je vous donne un snippet et je vais vous demander de l’ajuster un peu pour vérifier que vous comprendez bien qui fait quoi.\nD’abord, on importe les éléments de style dont on va avoir besoin :\nimport {Circle, Fill, Stroke, Style} from 'ol/style.js';\nOn commence par créer un style “pas proportionnel” qu’on stocke dans la constante styleCentroid.\nconst styleCentroid = new Style({\n  image: new Circle({\n    radius: 40,\n    fill: new Fill({ color: 'white' }),\n    stroke: new Stroke({ color: 'blue', width: 5 }),\n  }),\n});\nN’oubliez pas d’appeler votre style dans la propriété style de votre VectorLayer ou bien la couche ne changera pas.\nconst layerCentroid = new VectorLayer({\n  source: sourceCentroid,\n  style: styleCentroid    // On a rajouté cette ligne\n});\nAttention à l’ordre dans lequel vous ajoutez les éléments dans le code. N’oubliez pas que pour appeler une constante (ou une variable) comme styleCentroid, il faut avoir défini celle-ci avant !\nRegardez à quoi ressemble la couche maintenant qu’on lui a donné un style. C’est moche, hein ? Et bien c’est à vous de la rendre belle. Modifiez le code pour obtenir quelque chose qui ressemble à ça :\n\n\n\n\n\nNotez que les cercles ne sont pas entièrement opaques. Prenez le temps de vous appliquer, cela vous servira de base pour la suite. Quand vous avez terminé, vous pourrez utiliser ce snippet pour afficher des cercles proportionnels.\nfunction getStyleCentroid(feature) {\n  const nDeals = feature.get('n_deals');\n  const rayon = Math.sqrt(nDeals) * 0.01;\n  const style = new Style({\n    image: new Circle({\n      radius: rayon,\n      fill: new Fill({ color: 'white' }),\n      stroke: new Stroke({ color: 'blue', width: 5 }),\n    }),\n  });\n  return style;\n}\n\nconst layerCentroid = new VectorLayer({\n  source: sourceCentroid,\n  style: getStyleCentroid,\n});\nVous noterez que la différence principale ici est qu’on appelle une fonction et non une constante, et que cette fonction prend feature en argument. En fait, ce qu’il se passe, c’est que la fonction va regarder chaque objet de ma couche (chaque feature) et appliquer les étapes qu’on a définies à l’intérieur.\n\non lit un attribut de notre feature avec la méthode .get()\non calcule un rayon\non définit notre style comme précédemment, mais au lieu d’être une valeur fixe, notre propriété radius prend la valeur de notre rayon\n\nJe suis restée volontairement vague dans ce cas pour ne pas vous souffler toutes les réponses. Comme précédemment, vous allez devoir modifier le snippet de code pour rendre la couche un peu plus élégante. Je vous montre mon exemple, essayez de le reproduire le plus fidèlement possible :\n\n\n\n\n\nUne fois que c’est terminé, il reste un dernier exercice à faire avec ces cercles proportionnels. Vous aurez compris qu’ici, nos cercles sont proportionnels au nombre de deals qui sont enregistrés dans le pays. Maintenant, créez une couche de cercles proportionnels en vous basant sur la surface total couverte par les deals dans chaque pays.\nOn arrive sur la fin du TP et vous commencez (j’espère) à bien comprendre comment fonctionne notre application donc je ne vous donne pas d’indices. Faites juste attention à bien faire varier la taille des cercles petit à petit : si jamais votre navigateur essaie de dessiner des cercles trop grands, vous avez des chances de faire crasher votre ordinateur (ça m’est peut-être arrivé pendant mes tests et ce serait dommage que ça vous arrive aussi).",
    "crumbs": [
      "Enrichir ma carte en fonctionnalités"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#létape-finale",
    "href": "cours/geonum/enrichir_ma_carte.html#létape-finale",
    "title": "Enrichir ma carte en fonctionnalités",
    "section": "L’étape finale !",
    "text": "L’étape finale !\nEnfin l’étape finale du TP ! Une fois que votre application fonctionne et qu’elle vous convient, n’oubliez SURTOUT PAS de la build ! Pour le moment, vous travaillez dans ce qu’on appelle un environnement de développement mais quand vous êtes prêts à pousser une application en production, il faut la build. On l’a déjà fait au début du TP précédent mais je vous remets les instructions ici parce que je suis bien sympa (et que vous avez sûrement le cerveau en compote après tout ça) :\n\nouvrez un terminal à la racine de votre projet\nutilisez la commande cd app pour vous déplacer dans le dossier de votre application\nutilisez la commande npm run build pour build votre application, le résultat sera mis dans le dossier /dist\nallez sur http://localhost/ et vérifiez que vous voyez bien la dernière version de votre application\n\nEt voilà, bien joué ! Vous n’avez plus qu’à m’appeler pour me montrer le résultat.",
    "crumbs": [
      "Enrichir ma carte en fonctionnalités"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#jai-fini-en-avance-quest-ce-que-je-fais",
    "href": "cours/geonum/enrichir_ma_carte.html#jai-fini-en-avance-quest-ce-que-je-fais",
    "title": "Enrichir ma carte en fonctionnalités",
    "section": "J’ai fini en avance, qu’est-ce que je fais ?",
    "text": "J’ai fini en avance, qu’est-ce que je fais ?\nDéjà, bravo, c’était un gros TP. S’il reste du temps, je vais rajouter ici petit à petit des tâches pendant le TP qui vous permettront d’aller un peu plus loin et de préparer votre code pour l’évaluation. En attendant :\n\nvérifiez bien l’intendation de votre code\nvérifiez aussi qu’il soit bien commenté\naméliorez le style des couches WMS comme WFS pour avoir une carte harmonieuse et un peu stylée\najoutez un titre à votre page\najoutez une échelle (avec OpenLayers)",
    "crumbs": [
      "Enrichir ma carte en fonctionnalités"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#rajouté-à-la-fin-mais-à-faire-quand-même-une-table-attributaire-personnalisée",
    "href": "cours/geonum/enrichir_ma_carte.html#rajouté-à-la-fin-mais-à-faire-quand-même-une-table-attributaire-personnalisée",
    "title": "Enrichir ma carte en fonctionnalités",
    "section": "Rajouté à la fin MAIS À FAIRE QUAND MÊME : une table attributaire personnalisée",
    "text": "Rajouté à la fin MAIS À FAIRE QUAND MÊME : une table attributaire personnalisée\nOn va se réintéresser à notre couche WMS “deals” et à sa table attributaire (souvenez-vous : Interroger une couche WMS et afficher les résultats). Je vous remets notre code ici pour vous rappeler quels éléments permettent de récupérer la table attributaire. Attention au nom de vos couches et de vos sources, ce ne sont peut-être pas les mêmes que les miens !\nmap.on('singleclick', (event) =&gt; {\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n  const parametres = {'INFO_FORMAT': 'text/html'};\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((html) =&gt; {\n        document.getElementById('attributes').innerHTML = html;\n       });\n  }\n});\nFaites attention à cet élément :\nconst parametres = {'INFO_FORMAT': 'text/html'};\nNotez qu’on demande en fait à notre GeoServer de nous donner la réponse de notre requête au format text/html. C’est sympathique, mais difficile à customiser et surtout pas super pratique quand la table attribuaire est LONGUE. Heureusement, on peut récupérer le résultat au format JSON qui sera bien pratique pour customiser notre table.\nComme toujours, quand on souhaite ajouter un nouvel élément à notre carte, il faut qu’on commence par écrire du HTML. On va modifier notre div id=\"attributes\" pour y ajouter une table. Récupérez le code ci-dessous et regardez la différence, vous allez comprendre.\n&lt;div id=\"attributes\" class=\"menu\"&gt;\n  &lt;!-- Je crée une table --&gt;\n  &lt;table&gt;\n    &lt;!-- On utilise l’élément tr pour créer une ligne : tr = table row --&gt;\n    &lt;tr&gt;\n      &lt;!-- On utilise les éléments th (table header) pour créer les headers de nos trois colonnes --&gt;\n      &lt;th&gt;Deal ID&lt;/th&gt;\n      &lt;th&gt;Creation date&lt;/th&gt;\n      &lt;th&gt;Country&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;!-- On utilise l’élément tr pour créer une AUTRE ligne : tr = table row --&gt;\n    &lt;tr&gt;\n      &lt;!-- On crée trois colonnes vides avec td --&gt;\n      &lt;td&gt;…&lt;/td&gt;\n      &lt;td&gt;…&lt;/td&gt;\n      &lt;td&gt;…&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/table&gt;\n&lt;/div&gt;\nVous devriez maintenant voir apparaître une table dans votre div. Elle est austère, d’accord, mais vous pourrez la styliser après. Pour le moment, on va faire avec. Regardez bien mes commentaires pour comprendre comment est structuré le code. Regardez bien ces trois éléments :\n      &lt;td&gt;…&lt;/td&gt;\n      &lt;td&gt;…&lt;/td&gt;\n      &lt;td&gt;…&lt;/td&gt;\nVous comprenez sûrement qu’on souhaite remplacer ces “…” par des valeurs lorsqu’on clique sur un point de la couche. Il va donc falloir modifier cet élément HTML avec nos fonctions JavaScript. Souvenez-vous qu’on utilise les identifiants pour retrouver les éléments HTML avec .getElementById(). Donc :\n      &lt;td id=\"table-deal-id\"&gt;…&lt;/td&gt;\n      &lt;td id=\"table-creation-date\"&gt;…&lt;/td&gt;\n      &lt;td id=\"table-country\"&gt;…&lt;/td&gt;\nMaintenant qu’on a nos éléments, il va falloir les remplir. Retournez chercher votre méthode map.on() dans votre code, on va devoir l’améliorer un peu.\nmap.on('singleclick', (event) =&gt; {\n  const coord = event.coordinate;\n  const res = map.getView().getResolution();\n  const proj = 'EPSG:3857';\n\n  const parametres = { 'INFO_FORMAT': 'application/json' } // On a changé un truc ici\n\n  const url = sourceDeals.getFeatureInfoUrl(coord, res, proj, parametres);\n\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((json) =&gt; { // On a aussi changé un truc ici et dans la fonction\n        const obj = JSON.parse(json);\n        console.log(obj);\n      });\n  }\n});\nTestez votre couche et regardez le résultat dans la console. Si tout a fonctionné, vous devriez voir un objet JavaScript ! Dépliez-le et prenez le temps de l’explorer dans votre console pour comprendre ce que vous regardez. L‘information qui nous intéresse est quelque part dans features. Voilà ce qu’on doit faire avec la donnée :\n\nvérifier qu’on a bien cliqué sur une feature sur la carte (en JavaScript, ça demande de vérifier qu’on a bien de la donnée dans features)\nrécupérer la feature sur laquelle j’ai cliqué pour pouvoir accéder à ses properties\nrécupérer mes cellules pour remplacer leur contenu\nremplacer le contenu des cellules de ma table avec les properties\n\nOn va procéder petit à petit. D’abord, on vérifie qu’on a bien une feature dans feature :\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((json) =&gt; { // On a aussi changé un truc ici et dans la fonction\n        const obj = JSON.parse(json);\n        if (obj.features[0]) {\n          console.log(\"J’ai cliqué sur une feature !\");\n        } else {\n          console.log(\"J’ai cliqué à côté…\");\n        }\n      });\n  }\nOn utilise une condition if pour tester la présence d’une feature dans obj. obj.features[0] peut se traduire par : “Récupère mon tableau feature de mon obj et prends le premier élément”. La condition regarde simplement si feature[0] est vide ou non. Si ce n’est pas vide, on a reçu quelque chose, on a donc cliqué sur une feature. Au contraire, si c’est vide, c’est qu’on a cliqué à côté. Testez la fonction avant de passer à la suite.\nSi on a bien récupéré une feature, cela veut dire qu’on peut récupérer ses properties. Il suffit d’ajouter au bon endroit de la fonction les deux lignes suivantes :\nconst properties = obj.features[0].properties;\nconsole.log(properties);\nVous commencez à comprendre comment on accède à un élément dans un objet JavaScript. Il suffit d’appeler la propriété qu’on veut avec .&lt;propriété&gt;. Regardez comment est structuré votre objet properties dans la console du navigateur. Maintenant, modifiez la ligne console.log(properties); pour afficher la propriété target_country. Quand c’est réussi, passez à la suite !\nTrès bien, on sait maintenant récupérer des propriétés. Il ne nous reste plus qu’à modifier le HTML de notre document en conséquence en utilisant .innerHTML ! Je vous donne le code pour la colonne deal_id et je vous laisse compléter le code pour les deux autres colonnes.\n  if (url) {\n    fetch(url)\n      .then((response) =&gt; response.text())\n      .then((json) =&gt; {\n        const obj = JSON.parse(json);\n        if (obj.features[0]) {\n          console.log(\"J’ai cliqué sur une feature !\");\n          const properties = obj.features[0].properties;\n          console.log(properties);\n          // On affiche deal_id dans notre table\n          document.getElementById('table-deal-id').innerHTML = properties.deal_id;\n        } else {\n          console.log(\"J’ai cliqué à côté…\");\n          // On a cliqué \"nulle part\" donc on remet des … dans la colonne \"deal_id\"\n          document.getElementById('table-deal-id').innerHTML = \"\";\n        }\n      });\n  }\nTestez votre application. Normalement, ça marche ! Quand vous cliquez sur une feature, vous devriez récupérer son ID. Voilà comment on crée une table customisée pour interroger une couche ! Maintenant, à vous de compléter les deux autres colonnes. Une fois que vous avez réussi, ajoutez une colonne qui montre la valeur de mineral_resources pour le deal sur lequel vous cliquez. Et quand ça aussi ça fonctionne, prenez quelques minutes pour styliser votre table ! Google est votre ami (et ok, pourquoi pas ChatGPT si vous y tenez vraiiiiment, ça ne me dérange pas si c’est pour du CSS comme &lt;table&gt; commence à être complexe, mais on utilise l’IA intelligemment svp).",
    "crumbs": [
      "Enrichir ma carte en fonctionnalités"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#jai-fini-ça-aussi",
    "href": "cours/geonum/enrichir_ma_carte.html#jai-fini-ça-aussi",
    "title": "Enrichir ma carte en fonctionnalités",
    "section": "J’ai fini ça aussi !",
    "text": "J’ai fini ça aussi !\nFantastique ! Eh bien maintenant, débrouillez-vous pour ajouter une échelle à votre carte. Ça devrait vous occuper un moment, j’espère. Je vous donne ça, à vous de le mettre au bon endroit :\nimport ScaleLine from 'ol/control/ScaleLine.js';\nUn autre morceau, pour créer l’objet “échelle” :\nconst scaleline = new ScaleLine();\nEt enfin, trouvez comment ajouter ça à votre code existant :\nconst map = new Map({\n  controls: [scaleline],\n});\nEt voilà !",
    "crumbs": [
      "Enrichir ma carte en fonctionnalités"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#bon-ben-jai-aussi-une-échelle-sur-ma-carte",
    "href": "cours/geonum/enrichir_ma_carte.html#bon-ben-jai-aussi-une-échelle-sur-ma-carte",
    "title": "Enrichir ma carte en fonctionnalités",
    "section": "Bon, ben j’ai AUSSI une échelle sur ma carte…",
    "text": "Bon, ben j’ai AUSSI une échelle sur ma carte…\nBravo ! Vous pouvez répéter L’étape finale ! pour build votre application. Ensuite, je vous conseille de commencer à ajouter à votre carte des éléments dont vous avez besoin pour vos projets GeoNum. Vous pourriez vouloir par exemple un curseur temporel, des tooltips, etc. Commencez par faire des recherches parmi les exemples d’OpenLayers mais aussi dans les extensions disponibles sur ol-ext histoire de faire un tour des possibilités.\nEt suivant le temps qu’on a, on peut éventuellement commencez à regardez QGIS Server ensemble pendant le TP, sinon je vous ajouterai une petite notre sur le site si jamais vous préférez l’utiliser pour vos projets. Quoi qu’il en soit, vous ne serez pas notés dessus !",
    "crumbs": [
      "Enrichir ma carte en fonctionnalités"
    ]
  },
  {
    "objectID": "cours/geonum/enrichir_ma_carte.html#cette-fois-cest-vraiment-fini",
    "href": "cours/geonum/enrichir_ma_carte.html#cette-fois-cest-vraiment-fini",
    "title": "Enrichir ma carte en fonctionnalités",
    "section": "Cette fois, c’est vraiment fini !",
    "text": "Cette fois, c’est vraiment fini !\nMerci pour votre attention !",
    "crumbs": [
      "Enrichir ma carte en fonctionnalités"
    ]
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#sommaire",
    "href": "cours/geonum/slides_openlayers_td1.html#sommaire",
    "title": "Introduction à OpenLayers",
    "section": "Sommaire",
    "text": "Sommaire\n\nSe familiariser avec le code de l’application\nLes ressources OpenLayers\nConseils pour coder\nOn ajoute notre première couche ensemble"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication",
    "title": "Introduction à OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nNode JS crée beaucoup d’éléments mais voici ceux qu’on utilisera :\n\nindex.html\nstyle.css\nmain.js\n\nDeux autres explications à titre d’information :\n\nnode_modules/ contient notamment le code des librairies installées, c’est ici que vit le code source d’OpenLayers\ndist/ contient l’output du build du site, c’est les fichiers qui sont prêts à être servis par le serveur (pour nous, Caddy) pour mettre notre site en production"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-1",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-1",
    "title": "Introduction à OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nindex.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;link rel=\"icon\" type=\"image/x-icon\" href=\"https://openlayers.org/favicon.ico\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Using OpenLayers with Vite&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script type=\"module\" src=\"./main.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-2",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-2",
    "title": "Introduction à OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nindex.html\nUne référence pratique pour les balises html : W3schools.com"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-3",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-3",
    "title": "Introduction à OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nstyle.css\n@import \"node_modules/ol/ol.css\";\n\nhtml, body {\n  margin: 0;\n  height: 100%;\n}\n#map {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n}"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-4",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-4",
    "title": "Introduction à OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nstyle.css\nDes références pratiques pour écrire du CSS :\n\ncssreference.io pour la plupart des propriétés CSS\nW3schools.com pour les sélécteurs\nd’excellents guides sur css-tricks.com pour utiliser grid ou flexbox"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-5",
    "href": "cours/geonum/slides_openlayers_td1.html#se-familiariser-avec-le-code-de-lapplication-5",
    "title": "Introduction à OpenLayers",
    "section": "Se familiariser avec le code de l’application",
    "text": "Se familiariser avec le code de l’application\nmain.js\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers",
    "href": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers",
    "title": "Introduction à OpenLayers",
    "section": "Les ressources OpenLayers",
    "text": "Les ressources OpenLayers\nD’abord, la documentation. C’est la bible d’OpenLayers et vous allez devoir apprendre à la comprendre, au moins en partie, ou vous allez avoir beaucoup de mal à comprendre ce que vous faites quand vous codez. Elle peut être trouvée à cette addresse : https://openlayers.org/en/latest/apidoc/\n\nExemple d’utilisation de la documentation pour l’objet Map qui est créé dans main.js :\nTapez “Map” et cliquez sur le premier résultat (lien ici). On voit en haut de la page :\n\nComment importer cet objet Map\nUne description de ce qu’est cet objet Map\nUn exemple (“snippet”, petit morceau de code) qui montre comment utiliser Map\n\n\n\nQuand on continue à défiler vers le bas, on voit plusieurs autres sections :\n\nLa définition de la fonction pour créer l’objet Map et les options qu’il prend (new Map(options))\nLes évènements qui peuvent être déclenchés (“fired”) par notre objet Map dans la section Fires:\nLes Méthodes de l’objet Map, donc les fonctions qui peuvent être déclenchées avec cet objet Map pour généralement le lire ou le modifier"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-1",
    "href": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-1",
    "title": "Introduction à OpenLayers",
    "section": "Les ressources OpenLayers",
    "text": "Les ressources OpenLayers\nPetit point UML pour mieux comprendre (j’espère)\n\n\n\n\n\nclassDiagram\n    class Map{\n        controls\n        pixelRatio\n        interactions\n        keyboardEventTarget\n        layers\n        maxTilesLoading\n        moveTolerance\n        overlays\n        target\n        view\n        +methods…()\n    }\n\n\n\n\n\n\nOK c’est un peu compliqué. Pour simplifier, on va prendre les éléments qui nous intéressent le plus."
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-2",
    "href": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-2",
    "title": "Introduction à OpenLayers",
    "section": "Les ressources OpenLayers",
    "text": "Les ressources OpenLayers\nPetit point UML pour mieux comprendre (j’espère)\n\n\n\n\n\n\n\nclassDiagram\n    class Map{\n        target\n        layers\n        view\n        +addLayer()\n        +getlayers()\n        +getView()\n    }\n\n\n\n\n\n\n\nClasse : Map\nAttributs :\n\n\ntarget = l’id de ma &lt;div&gt; qui va contenir ma carte\nlayers = les couches créées avec OpenLayers qui doivent être ajoutées à ma carte\nview = les paramètres de la vue (centre, niveau de zoom) de ma carte lorsqu’elle est initialisée\n\n\nMéthodes :\n\n\naddLayer() = ajouter une couche créée avec OpenLayers à ma carte\ngetLayers() = récupérer les couches qui sont attachées à ma carte\ngetView() = récupérer les paramètres de la vue actuelle (centre, niveau de zoom)"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-3",
    "href": "cours/geonum/slides_openlayers_td1.html#les-ressources-openlayers-3",
    "title": "Introduction à OpenLayers",
    "section": "Les ressources OpenLayers",
    "text": "Les ressources OpenLayers\nLa galerie d’exemples\nPour créer une carte sous OpenLayers, le point d’entrée principal est la galerie d’exemples. Je vous conseille vivement de toujours commencer par là avant d’aller voir d’autres ressources comme StackOverflow, etc. comme ce sont les exemples officiels qui sont maintenus à jour et respectent les bonnes pratiques d’utilisation du code OpenLayers.\nPar exemple, si vous souhaitez ajouter un flux WMS à votre carte, basez-vous sur le code de l’exemple Single Image WMS."
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#conseils-pour-coder",
    "href": "cours/geonum/slides_openlayers_td1.html#conseils-pour-coder",
    "title": "Introduction à OpenLayers",
    "section": "Conseils pour coder",
    "text": "Conseils pour coder\n\n\nUtilisez des console.log() à outrance pour vérifier qu’une fonction a bien été appelée, qu’une variable a bien été lue, etc.\nCopiez le code des exemples OpenLayers et essayez de le changer petit à petit pour l’adapter à votre code.\nQuand vous voulez ajouter de nouveaux éléments, allez-y petit à petit et vérifiez à chaque étape que tout fonctionne, ça permettra plus facilement de retrouver les bugs.\nUne des premières choses à vérifier quand le code ne fonctionne pas est le nom des variables. Parfois on oublie un “s”, parfois on a ajouté une majuscule…\nCOMMENTEZ VOTRE CODE ! Non seulement ce sera pris en compte dans l’évaluation, mais surtout vous allez galérer à comprendre votre code en revenant dessus dans quelques mois et/ou les personnes avec qui vous allez travailler vont aussi mettre du temps à vous comprendre."
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nMaintenant, on va ajouter notre première couche WMS ensemble.\n\nOuvrez votre projet dans VSCode (ou votre éditeur préféré) si ce n’est pas déjà fait\nSi vous aviez arrêté votre serveur node, ouvrez un terminal dans votre dossier app et tapez npm start puis allez sur le lien localhost qu vous est donné pour rouvrir votre carte\n\n\nOpenLayers c’est comme tout : avant de pouvoir partir en vrille et créer vos meilleures applications, il faut bien comprendre les bases.\nDonc au lieu de connecter notre couche WMS à l’aveugle, on va chercher à comprendre comment c’est fait. Ci-dessous, un exemple d’étudiants qui ont bien étudié les bases pour comprendre ce qu’ils font."
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-1",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-1",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n🤔 Qu’est-ce qui est différent dans index.html ?\n\n\nle style n’est pas dans style.css mais dans une balise de &lt;style&gt;. Nous on a déjà un fichier de style qui fonctionne très bien et la carte en plein écran nous plait, on ne change rien.\n\n\n\n\nla balise &lt;div id=\"map\"&gt; a aussi une classe de style class = \"map\". Cela permet d’appliquer le même style à toutes les cartes avec la classe map. Nous on a une seule carte dans notre application, donc on s’en moque.\n\n\n\nEn gros, on n’a rien à modifier dans index.html ni dans le fichier de style style.css. On peut passer au gros morceau : le fichier de script main.js."
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-2",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-2",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n🤔 Qu’est-ce qui est différent dans main.js ?\n\n👆 Mon conseil : au début, ignorez toute la section import qui peut sembler un peu floue et concentrer vous sur les variables qui sont définies dans le code, puis sur les objets OpenLayers.\n\n\n\n\nNotre code :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-3",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-3",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n\n\nNotre code :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-4",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-4",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n\n\nNotre code :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-5",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-5",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n\n\nNotre code :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-6",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-6",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\n\n\nNotre code :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport TileLayer from 'ol/layer/Tile';\nimport OSM from 'ol/source/OSM';\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-7",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-7",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nLe code de l’exemple :\nimport ImageWMS from 'ol/source/ImageWMS.js';\nimport Map from 'ol/Map.js';\nimport OSM from 'ol/source/OSM.js';\nimport View from 'ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from 'ol/layer.js';\n\nconst layers = [\n  new TileLayer({\n    source: new OSM(),\n  }),\n  new ImageLayer({\n    extent: [-13884991, 2870341, -7455066, 6338219],\n    source: new ImageWMS({\n      url: 'https://ahocevar.com/geoserver/wms',\n      params: {'LAYERS': 'topp:states'},\n      ratio: 1,\n      serverType: 'geoserver',\n    }),\n  }),\n];\nconst map = new Map({\n  layers: layers,\n  target: 'map',\n  view: new View({\n    center: [-10997148, 4569099],\n    zoom: 4,\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-8",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-8",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nDe quoi j’ai besoin pour ajouter une couche WMS à ma carte ?\n\n\nIl nous faut une source pour le flux WMS qu’on crée avec l’objet ImageWMS (documentation)\nIl nous faut un objet ImageLayer pour créer notre couche à partir de notre source\nIl nous faut un objet Map (déjà créé dans notre cas) auquel ajouter la couche\n\n\n\nMa proposition de code pour créer une couche (en retirant les éléments superflus pour simplifier) :\nconst ma_source = new ImageWMS({\n  url: '&lt;lien_vers_mon_serveur&gt;',\n  params: {'LAYERS': '&lt;espace&gt;:&lt;couche&gt;'},\n  serverType: 'geoserver',\n});\n\nconst ma_couche = new ImageLayer({\n  source: ma_source,\n});\n\n\nOn pourrait aussi l’écrire en imbriquant tout comme dans l’exemple, mais je préfère séparer les éléments, je trouve ça moins confus (surtout quand on apprend).\nconst ma_couche = new ImageLayer({\n  source: new ImageWMS({\n    url: '&lt;lien_vers_mon_serveur&gt;',\n    params: {'LAYERS': '&lt;espace&gt;:&lt;couche&gt;'},\n    serverType: 'geoserver',\n  }),\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-9",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-9",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nIl nous manque un dernier détail : les imports. Si vous utilisez le code tel quel, vous allez avoir des messages d’erreur indiquant que les fonctions ne sont pas trouvées. Vous pouvez trouver les imports de trois manières :\n\nvous regardez les imports dans l’exemple OpenLayers et vous récupérez ceux dont vous avez besoin (lien)\nvous allez voir la documentation de ImageWMS par exemple et la première ligne vous indique comment importer le module dans votre code (lien)\nsi votre éditeur de code est bien fichu, il peut lui-même ajouter un import quand vous appelez un constructeur ou une méthode dans votre code\n\n👆 D’ailleurs, n’oubliez pas que les import doivent toujours être déclarés tout en haut du document !"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-10",
    "href": "cours/geonum/slides_openlayers_td1.html#on-ajoute-notre-première-couche-ensemble-10",
    "title": "Introduction à OpenLayers",
    "section": "On ajoute notre première couche ensemble",
    "text": "On ajoute notre première couche ensemble\nVoici mon résultat pour importer la couche de l’exemple d’OpenLayers :\nimport './style.css';\nimport {Map, View} from 'ol';\nimport { ImageWMS } from 'ol/source';\nimport TileLayer from 'ol/layer/Tile';\nimport ImageLayer from 'ol/layer/Image';\nimport OSM from 'ol/source/OSM';\n\nconst couche_osm = new TileLayer({ source: new OSM() });\n\nconst ma_source = new ImageWMS({\n  url: 'https://ahocevar.com/geoserver/wms',\n  params: { 'LAYERS' : 'topp:states' },\n  serverType: 'geoserver',\n});\n\nconst ma_couche = new ImageLayer({\n  source: ma_source,\n});\n\nconst map = new Map({\n  target: 'map',\n  layers: [ couche_osm, ma_couche ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});"
  },
  {
    "objectID": "cours/geonum/slides_openlayers_td1.html#à-vous",
    "href": "cours/geonum/slides_openlayers_td1.html#à-vous",
    "title": "Introduction à OpenLayers",
    "section": "À vous !",
    "text": "À vous !\nVous allez pouvoir commencer le TP suivant pour commencer à ajouter vos couches dans votre application OpenLayers.\nC’est parti !\n\n\n\n\n\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#sommaire",
    "href": "cours/geonum/slides_le_point_technique.html#sommaire",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Sommaire",
    "text": "Sommaire\n\nPrésentation brève d’OpenLayers\nLes bases de Node JS\nDe quelle architecture on a besoin ?\nVMs, Docker et Docker Compose\nNotre Docker Compose\n\nEt si on avance bien, aujourd’hui on aura non pas UN mais DEUX cours ! Alors ne perdons pas de temps et en avant !"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#présentation-brève-dopenlayers",
    "href": "cours/geonum/slides_le_point_technique.html#présentation-brève-dopenlayers",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Présentation brève d’OpenLayers",
    "text": "Présentation brève d’OpenLayers\n\nOpenLayers est une librairie JavaScript Open Source qui permet de créer des cartes interactives pour le web.\nLa librairie a plus de 11 000 stars sur GitHub et 3 000 forks.\nAu moment où j’écris ce cours, la dernière mise à jour date d’il y a deux jours.\nL’alpha d’OpenLayers (première version mise en ligne sur GitHub) date de 2013.\n\nC’est une librairie populaire, mature, maintenue et bien documentée."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#présentation-brève-dopenlayers-1",
    "href": "cours/geonum/slides_le_point_technique.html#présentation-brève-dopenlayers-1",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Présentation brève d’OpenLayers",
    "text": "Présentation brève d’OpenLayers\n🤔 Ça ressemble en tout point à Leaflet, non ? Alors pourquoi apprendre les deux ?\n\n👉 Oui et non !\n\nLeaflet est plus pratique pour obtenir rapidement une “jolie” carte avec moins de code, par exemple afficher/masquer les couches.\nMais Leaflet a aussi ses défauts : la carte est plus difficile à customiser “en profondeur” qu’OpenLayers, il y a de nombreux plug-ins qui parfois font plus ou moins la même chose, parfois ne sont plus maintenus, là où beaucoup de ces fonctionnalités sont disponibles dans le code de base d’OpenLayers.\n\n\n\nPour faire simple, selon mon expérience avec les deux librairies, OpenLayers est plus facilement customisable et se repose moins sur des plug-ins externes. Il existe une source de plug-ins pour ajouter des fonctionnalités supplémentaires publiée par l’utilisateur GitHub viglino. Ces extensions ol-ext sont régulièrement maintenues."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#présentation-brève-dopenlayers-2",
    "href": "cours/geonum/slides_le_point_technique.html#présentation-brève-dopenlayers-2",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Présentation brève d’OpenLayers",
    "text": "Présentation brève d’OpenLayers\nIl est donc intéressant de savoir utiliser à la fois Leaflet et OpenLayers car chacune des librairies a ses points forts et ses faiblesses.\nCela dit, en ce qui concerne un usage simplifié, si vous comprenez Leaflet vous comprenez aussi OpenLayers.\n\nOn va devoir créer une application Node JS pour pouvoir importer la librairie OpenLayers et commencer à coder."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js",
    "href": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Les bases de Node JS",
    "text": "Les bases de Node JS\nNode JS, c’est ce qu’on appelle un environnement runtime de JavaScript.\nVoilà. On continue ?"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js-1",
    "href": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js-1",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Les bases de Node JS",
    "text": "Les bases de Node JS\nPour simplifier, voyons comment vous écrivez et exécutez votre code JavaScript jusqu’à maintenant.\n\nOn crée un document index.html dans lequel on met quelque part une balise &lt;script&gt;\nOn écrit le code dans la balise &lt;script&gt;\nOn ouvre index.html dans le navigateur\nComme le JavaScript est dans index.html qui est ouvert dans un navigateur, le navigateur peut exécuter le code JavaScript\n\nCe n’est pas super pratique quand on commence à avoir une application qui grandit (ou “scale”)."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js-2",
    "href": "cours/geonum/slides_le_point_technique.html#les-bases-de-node-js-2",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Les bases de Node JS",
    "text": "Les bases de Node JS\nLa force de Node JS est de permettre d’exécuter du code écrit en JavaScript sans passer par le navigateur. Si par la suite vous devez écrire du code côté serveur, vous pouvez aussi le faire en JavaScript. Et surtout, Node JS permet de télécharger facilement des librairies et déployer encore plus facilement notre application pour la mettre en production en utilisant quelques lignes de commande."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#un-serveur-pour-mon-appli-web",
    "href": "cours/geonum/slides_le_point_technique.html#un-serveur-pour-mon-appli-web",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Un serveur pour mon appli web",
    "text": "Un serveur pour mon appli web\nVous vous souvenez sûrement du premier cours de Leaflet."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#un-serveur-pour-mon-appli-web-1",
    "href": "cours/geonum/slides_le_point_technique.html#un-serveur-pour-mon-appli-web-1",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Un serveur pour mon appli web",
    "text": "Un serveur pour mon appli web\nVous avez “triché” pour éviter d’avoir à utiliser un serveur. Mais maintenant, ça ne vous fait plus peur. Après tout, on a bien utilisé un serveur carto la dernière fois et tout le monde a survécu. Maintenant, on va pouvoir écrire une application web plus complexe, bien la structurer grâce à Node JS, et la servir sur un serveur web."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#de-quelle-architecture-on-a-besoin",
    "href": "cours/geonum/slides_le_point_technique.html#de-quelle-architecture-on-a-besoin",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "De quelle architecture on a besoin ?",
    "text": "De quelle architecture on a besoin ?\nFacile ! On veut :\n\nun serveur webcarto (GeoServer)\nmais aussi un serveur web pour servir notre application.\n\nDurant le premier TP, on a utilisé Docker pour déployer notre GeoServer. On peut aussi déployer notre serveur web avec Docker. Mais ça voudrait dire qu’à chaque fois, on aurait deux containers différents à allumer et éteindre, qu’il faut faire attention à ne pas les configurer de travers, ne pas oublier les lignes de commande qu’on a tapées…\n\nHeureusement, Docker dispose d’un petit outil bien pratique pour gérer des architectures à plusieurs containers : Docker Compose. Sauf que pour comprendre Docker Compose, il faut comprendre Docker. Et pour comprendre Docker, il faut comprendre les Machines Virtuelles (VM)."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nEncore de la théorie ?!\n\nOn ne va pas rentrer dans le détail, l’idée est que vous compreniez pourquoi on a utilisé Docker et pas des machines virtuelles pour nos serveurs. Docker, c’est bien. Si vous déployez des architectures par la suite, vous allez apprendre à l’aimer."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-1",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-1",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nLes Machines Virtuelles (VM)\n\nIl faut voir une machine virtuelle comme un ordinateur qui serait dématérialisé (sans composants matériels). Elle possède un processeur, de la mémoire, des espaces de stockage pour la donnée, elle peut se connecter à internet…\nOutils de création de machines virtuelles : VirtualBox, VMWare…\n\nExemple : en téléchargeant VirtualBox, je peux créer une machine virtuelle Linux sur mon ordinateur Windows.\n\nSource : microsoft.com"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-2",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-2",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nLes Machines Virtuelles (VM)\nSi je voulais mettre en place mon serveur sur une machine virtuelle, je devrais :\n\ncréer la machine (avec des caractéristiques suffisantes pour faire tourner l’application)\ninstaller et configurer mon serveur web (Apache, Nginx, Caddy)\najouter le build de mon application Node JS dans le dossier /var/www/ de mon serveur web\ntélécharger, installer et configurer GeoServer\néventuellement télécharger, installer et configurer une base Postgresql avec PostGIS et la connecter au serveur\netc."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-3",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-3",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nLes Machines Virtuelles (VM)\nMultiplier les machines virtuelles sur l’hôte est très demandeur.\n\nressources divisées entre l’hôte et les machines\nautant d’OS à faire tourner que de machines\nchaque machine = plusieurs Go d’espace\n\nC’est aussi difficile à maintenir - il faut garder tous les OS à jour, etc.\nMais nous, on aime la simplicité et éviter de consommer plein de mémoire “pour rien”."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-4",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-4",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nDocker\n\nDocker permet de faire tourner ce qu’on appelle des containers.\nLes containers sont réduits au minimum nécessaire pour faire tourner des services (un serveur, une base de données, …).\nAutre outil de containerisation : Podman\n\n\nSource : microsoft.com"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-5",
    "href": "cours/geonum/slides_le_point_technique.html#vms-docker-et-docker-compose-5",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "VMs, Docker et Docker Compose",
    "text": "VMs, Docker et Docker Compose\nDocker Compose\n\nSorti en 2013, Docker Compose permet de gérer des applications multi-containers.\nPour cela, on va rédiger un fichier de type docker-compose.yml qui va agir comme une “recette” pour permettre à Docker de créer et connecter l’ensemble des containers dont on a besoin."
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#notre-docker-compose",
    "href": "cours/geonum/slides_le_point_technique.html#notre-docker-compose",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "Notre Docker Compose",
    "text": "Notre Docker Compose\nExplications sur le contenu :\nservices:\n\n  geoserver:\n    container_name: geonum_geoserver\n    image: docker.osgeo.org/geoserver:2.26.0\n    environment:\n      - RUN_UNPRIVILEGED=true\n      - CHANGE_OWNERSHIP_ON_FOLDERS=\"/opt /opt/geoserver_data/ /mnt/geoserver_geodata\"\n      - CORS_ENABLED=true\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - $PWD/geoserver/opt:/opt/geoserver_data\n  \n  web:\n    container_name: geonum_web\n    image: caddy:latest\n    ports:\n      - \"80:80\"\n    volumes:\n      - $PWD/Caddyfile:/etc/caddy/Caddyfile\n      - $PWD/app/dist/:/srv"
  },
  {
    "objectID": "cours/geonum/slides_le_point_technique.html#à-vous",
    "href": "cours/geonum/slides_le_point_technique.html#à-vous",
    "title": "Serveurs Carto et OpenLayers - le point technique",
    "section": "À vous !",
    "text": "À vous !\nCommencez le TP “démarrage de la stack” pour mettre en place vos containers ! Ensuite, on pourra se pencher un peu plus sur le cas d’OpenLayers.\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html",
    "href": "cours/geonum/serveurs_carto.html",
    "title": "Serveurs cartographiques",
    "section": "",
    "text": "Comprendre ce qu’est un serveur cartographique et ce que sont les flux WMS, WFS, etc.\nConnaître les principaux serveurs cartographiques avec un focus sur GeoServer, un serveur cartographique Open-Source.\nApprendre à déployer une instance de GeoServer à l’aide de Docker.\nPublier des couches avec GeoServer et les styliser en passant par QGIS.\nLire les flux WMS de mon GeoServer dans une application OpenLayers basique.\nÊtre capable de déterminer dans quelles situations on a besoin d’un serveur cartographique.",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#objectifs",
    "href": "cours/geonum/serveurs_carto.html#objectifs",
    "title": "Serveurs cartographiques",
    "section": "",
    "text": "Comprendre ce qu’est un serveur cartographique et ce que sont les flux WMS, WFS, etc.\nConnaître les principaux serveurs cartographiques avec un focus sur GeoServer, un serveur cartographique Open-Source.\nApprendre à déployer une instance de GeoServer à l’aide de Docker.\nPublier des couches avec GeoServer et les styliser en passant par QGIS.\nLire les flux WMS de mon GeoServer dans une application OpenLayers basique.\nÊtre capable de déterminer dans quelles situations on a besoin d’un serveur cartographique.",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#cours",
    "href": "cours/geonum/serveurs_carto.html#cours",
    "title": "Serveurs cartographiques",
    "section": "Cours",
    "text": "Cours\nSlides : Serveurs Cartographiques",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#tp---prise-en-main-de-geoserver",
    "href": "cours/geonum/serveurs_carto.html#tp---prise-en-main-de-geoserver",
    "title": "Serveurs cartographiques",
    "section": "️TP - Prise en main de GeoServer",
    "text": "️TP - Prise en main de GeoServer\n\nDéploiement de GeoServer à l’aide de Docker\nDocumentation GeoServer - Dépôt de l’image Docker\n\n\n\n\n\n\nImportant\n\n\n\nCe TP suppose que Docker est installé sur la machine. Il a été écrit pour une machine Linux, certains chemins et lignes de commande peuvent donc être différents sur une machine Windows ou Mac.\n\n\nUne fois que Docker est installé, lancez la commande suivante pour télécharger une image de GeoServer en version 2.26.0 :\ndocker pull docker.osgeo.org/geoserver:2.26.0\nPuis, pour construire un container à partir de l’image de GeoServer :\ndocker run -it -p 80:8080 docker.osgeo.org/geoserver:2.26.0\nSi vous n’avez pas eu de message d’erreur, rendez-vous sur http://localhost/geoserver et connectez-vous avec l’identifiant admin et le mot de passe geoserver. Si l’authentification a fonctionné, félicitations, vous avez réussi à faire tourner un container avec GeoServer !\n\n\n\n\n\n\nAttends, attends… des containers, des images ? Hein ?\n\n\n\n\n\n\n\n\n\n\nPas de panique ! On n’a pas besoin de savoir exactement comment fonctionne Docker pour ce TP. Si on veut simplifier :\n\nDocker permet de faire tourner des services dans des containers créés à partir d’images.\nUne image est une recette à suivre pour créer mon container. Elle demande à Docker de créer un container basé sur Debian, d’y installer GeoServer ou bien une base PostgreSQL avec l’extension postGIS, etc.\nUn container est le produit d’une image. C’est un peu le plat cuisiné à partir de la recette. C’est à l’intérieur du container que tourne mon service comme ma base de données ou mon serveur web. On peut connecter plusieurs containers entre eux, pratique si on veut un site web et une base de données qui fonctionnent ensemble !\nUn service est généralement une base de données (ex. PostgreSQL), un serveur de site web (ex. Apache), un serveur cartographique (ex. GeoServer), etc. Comme les bonnes pratiques demandent d’avoir un seul service par container, on va parler du “container GeoServer” pour dire “le container qui contient mon service GeoServer”, ça va plus vite.\n\nSi ce n’est encore pas clair et que ça vous gêne pour la compréhension de la suite du TP, hop, on lève la main et on demande des explications, je suis là pour ça ! Et si vous voulez aller plus loin, rendez-vous sur la documentation officelle de Docker.\n\n\n\nPour vérifier que tout fonctionne, on va faire une petite manip rapide.\n\nEn haut à droite de l’écran, si ce n’est pas déjà le cas, sélectionnez le langage “fr” pour passer l’interface en français.\nAllez dans “Espaces de travail” (menu à gauche de l’écran) et cliquez sur le bouton “Ajouter un nouvel espace de travail”.\nAppelez-le “mon_espace” et donnez lui un URI mon_espace.\nVérfiez qu’il apparaît bien dans la liste de vos espaces (normalement, au-dessus de “ne”).\n\nEnsuite, on va arrêter notre container Docker. Commencez par utiliser la commande suivante :\ndocker ps\nVous devriez voir apparaître une ligne avec l’ID de votre container dans la colonne CONTAINER ID, l’image utilisée pour le construire dans la colonne IMAGE, d’autres informations qui ne nous servent pas dans ce TP et son nom dans la colonne NAME. La commande docker ps permet de lister les containers actifs en ce moment. On souhaite arrêter notre container avec la commande docker stop &lt;container_name&gt;. Pour cela, il faut utiliser le nom du container à la place de &lt;container_name&gt;. Par exemple, voici les informations de mon container :\nCONTAINER ID   IMAGE                               COMMAND                  CREATED         STATUS                            PORTS                                     NAMES\n0a885cadf11d   docker.osgeo.org/geoserver:2.26.0   \"bash /opt/startup.sh\"   8 seconds ago   Up 7 seconds (health: starting)   0.0.0.0:80-&gt;8080/tcp, [::]:80-&gt;8080/tcp   charming_pare\nLe nom de mon container est donc charming_pare. Pour arrêter mon container, je dois taper la commande suivante :\ndocker stop charming_pare\n\n\n\n\n\n\nTip\n\n\n\nQuand on tape des lignes de commande en bash, utilisez la touche tab pour auto-compléter la commande. Par exemple, ici, j’ai seulement tapé docker stop ch puis appuyé sur tab qui a complété le nom de mon container. Pratique, non ? N’hésitez pas à en abuser. Si l’auto-complete ne fonctionne pas, c’est qu’il ne trouve rien OU plusieurs résultats. Dans ce cas, continuez à écrire la commande à la main et réessayez.\n\n\nUtilisez à nouveau la commande docker ps pour vérifier que ce container n’apparaît plus dans la liste. Normalement, si vous actualisez la page GeoServer, vous devriez avoir une erreur du type “localhost refused to connect”.\nAlors, c’est bien sympa tout ça, mais en l’état, on ne va pas pouvoir ajouter de données dans notre container. Il faudrait pouvoir accéder au dossier /data de GeoServer. Heureusement, pour nous simplifier la vie, on peut utiliser Docker pour “connecter” deux dossiers en eux (monter, mount en anglais). Pour ça, il faut créer sur notre ordinateur un nouveau dossier dans lequel on mettra tout ce qu’on veut retrouver dans le /data de notre GeoServer. Promis, c’est la dernière étape aussi technique, ensuite je me détends et j’arrête de vous faire taper autant de lignes de commande.\n\n\n\n\n\nD’abord, on supprime notre container. On va en créer un nouveau dans les étapes suivantes.\ndocker rm &lt;nom_du_container&gt;\nEnsuite, on va créer un dossier à monter sur le /data de notre container.\n\nAllez dans Documents et créer un nouveau dossier “GeoServer”.\nCopiez le chemin ABSOLU vers ce dossier. Par exemple, chez moi (Ubuntu), ça donne ça : /home/marie/Documents/GeoServer\nRemplacez \"/absolute/path/on/host\" dans la commande suivante et copiez-collez la quelque part, on ne sait jamais.\n\ndocker run -it -p 80:8080 --mount src=\"/absolute/path/on/host\",target=/opt/geoserver_data/,type=bind docker.osgeo.org/geoserver:2.26.0\n\nExécutez la ligne de commande.\n\nMaintenant, on va ajouter notre jeu de données land_matrix_mines à notre dossier /data.\n\nTéléchargez le jeu de données land_matrix_mines.\nDans l’explorateur de fichiers de votre ordinateur, ouvrez votre dossier GeoServer. Normalement, vous auriez du voir apparaître plusieurs nouveaux dossiers. Allez dans /data et créez un nouveau dossier geopackage.\nGlissez le fichier land_matrix_mines.gpkg dans le dossier geopackage.\n\n\n\n\n\n\n\nJe ne peux pas créer de nouveau dossier / déplacer mon fichier !\n\n\n\n\n\nSi vous ne pouvez pas créer de nouveau dossier, c’est que vous ne disposez pas des permissions suffisantes. Dans mon cas (sur Ubuntu), tous les dossiers appartenaient à l’utilisateur et au groupe root. Il faut utiliser la commande chown :\nsudo chown -R &lt;user&gt;:&lt;group&gt; /chemin/vers/mon/dossier\nPour changer les droits de mon dossier `/home/marie/Documents/GeoServer` j’ai donc tapé :\nsudo chown -R marie:marie /home/marie/Documents/GeoServer\nSi ça ne fonctionne pas, ne restez pas bloqués et appelez-moi, on règle ça ensemble.\n\n\n\nC’est bon, ça fonctionne ? Parfait ! Les règles pour arrêter et démarrer son container restent les mêmes. Tout ce qu’il faut retenir, c’est qu’il ne faut pas supprimer ou déplacer votre dossier GeoServer sous peine de tout casser. Pour le reste, tout devrait fonctionner tranquillement.\n\n\n\n\n\n\nRappel des commandes principales\n\n\n\n\n\n# Lister les containers actifs\ndocker ps\n\n# Lister tous les containers, même arrêtés\ndocker ps -a\n\n# Démarrer mon container\ndocker start &lt;nom_du_container&gt;\n\n# Arrêter mon container\ndocker stop &lt;nom_du_container&gt;\n\n# /!\\ Supprimer mon container\ndocker rm &lt;nom_du_container&gt;\n\n\n\nVous avez survécu au déploiement du GeoServer, bien joué ! Prenez un moment pour souffler, allez vous chercher un café. La suite sera beaucoup moins prise de tête, c’est promis !\n\n\n\n\n\n\n\nEspaces de travail, Entrepôts et Couches\nCréer un espace de travail, c’est facile, on vient de le faire. Maintenant, on va créer un nouveau dépôt par défaut qu’on appellera land_matrix et dans lequel on ajoutera notre geopackage.\n\nAllez dans “Espaces de travail” et cliquez sur “Ajouter un nouvel espace de travail”.\nNommez l’espace de travail “land_matrix” et donnez lui l’URI “land_matrix”.\nCochez “Espace de travail par défaut”.\nCiquez sur “Sauvegarder”.\n\nSi tout va bien, on voit maintenant notre espace “land_matrix” dans la liste. On va pouvoir ajouter un entrepôt de données dans notre espace.\n\nAllez dans “Entrepôts” et cliquez sur “Ajouter un nouvel entrepôt”. Vous allez voir une liste de tous les types d’entrepôts de données qui peuvent être ajoutés à votre espace de travail, par exempe du GeoPackage, une base PostGIS, un Shapefile ou encore un flux WMS distant.\nSélectionnez “GeoPackage”.\nNommez la source de données “land_matrix_mines” et ajoutez une petite description, par exemple “Transactions minières de la Land Matrix, 2024”.\nDans “Paramètres de connexion” cliquez sur “Parcourir…” à droite de “database *”.\nAllez dans data/geopackage/ et cliquez sur le jeu de données land_matrix_mines.gpkg.\nVidez le champ “passwd”.\nCliquez sur “Sauvegarder”.\n\nUne fois de retour sur la page “Entrepôts”, vous devriez voir votre entrepôt “land_matrix_mines” associé à l’espace de travail “land_matrix”. On avance ! Maintenant, on veut publier et lire des couches.\n\nAllez dans “Couches” et cliquez sur “Ajouter une nouvelle couche”.\nSélectionnez “land_matrix:land_matrix_mines”. Vous devriez voir apparaître une liste de couches.\nCliquez sur “Publier” à droite de la couche “deals”.\n\nL’onglet de publication de couche permet de configurer la couche et d’y ajouter de la métadonnée. Dans ce TP, on se concentrera sur les informations “cruciales” pour définir une couche, mais vous pourrez toujours allez plus loin en utilisant la documentation GeoServer sur les couches.\nLes trois choses à faire absolument à chaque fois dans l’onglet données sont :\n\nRenseigner les informations dans “Informations de base sur les donneés” comme le nom de la couche et un résumé. N’oubliez pas de laisser “Activé” et “Publié” cochés pour rendre la couche accessible depuis l’extérieur.\nVérifier le “Système de Référence de Coordonnées (SRC)” qui doit être pré-rempli en EPSG:4326 dans notre cas. Il correspond à la projection WGS84 utilisée dans la grande majorité des cas en cartographie web.\nDéfinir les “Emprises” qui se calculent automatiquement sur GeoServer en cliquant sur “Calculer depuis les limites du SRS” et “Calculées sur les emprises natives”.\n\nCliquez ensuite sur “Appliquer” pour sauvegarder vos changements et scrollez en haut de la page pour accéder à l’onglet “Publication”.\n\nDans “Paramètres de couche”, cochez Interrogeable et vérifiez que le style par défaut est bien “point”.\n\nCliquez sur “Sauvegarder”. La couche devrait maintenant apparaître au sommet du tableau. Cliquez simplement sur le nom de la couche (ici “deals”) pour la paramétrer à nouveau si besoin. Pour vérifier que tout a fonctionné, on peut prévisualiser la couche directement depuis GeoServer.\n\nAllez dans “Prévisualisation de la Couche” (menu à gauche de l’écran).\nSur la ligne de la couche “deals”, sélectionnez “OpenLayers”.\n\nVous devriez voir apparaître quelque chose comme ça, avec des informations supplémentaires si vous cliquez sur des points (possible car notre couche est interrogeable) :\n\n\n\n\n\nSi c’est bon, bravo, ça a fonctionné ! Si vous voyez des artefacts autour des points, c’est normal. Ce que vous regardez, ce ne sont pas des polygones mais une image produite à partir de notre couche et transmise comme un flux WMS par notre serveur. L’intérêt, c’est qu’on peut afficher rapidement des couches très lourdes de cette manière, là où un GeoJSON commencerait à ramer. Et on peut toujours zoomer et cliquer sur un point pour l’interroger. C’est super pratique ! Ce flux WMS est récupéré et lu par une petite appli OpenLayers, c’est comme ça que vous êtes capable de voir la couche sur votre page web (vous sentez venir la transition vers les prochains cours, là ?).\nBon, super, on a notre couche moche. Maintenant, on en fait quoi de tous ces points rouges ?\n\n\n\n\n\nFacile. On va d’abord la rendre un peu plus belle, puis on va la lire dans notre propre application OpenLayers et commencer à faire des trucs cools avec. Mais avant, comme vous avez tout compris à ce qu’on vient de faire, ajoutez toutes les autres couches du geopackage à votre espace de travail. Quand vous avez réussi à toutes les prévisualiser (et pleuré devant leur style austère), créez un nouveau projet QGIS et importez aussi ces couches.\n\n\nStyliser mes couches\nDocumentation GeoServer “Styling”\nPour le moment, afficher notre couche “deals” va juste donner l’impression que notre carte a attrappé la varicelle. On va commencer par changer son apparence en faisant des points bien ronds et d’une couleur qui crie moins “DANGER !!!”. Pour ça, on va devoir créer un nouveau style.\n\nAllez dans “Styles” et cliquer sur “Ajouter un nouveau style”.\nNommez le style “deals” et choisissez l’espace de travail “land_matrix”. Conservez le format SLD, c’est le seul disponible sans ajouter d’extensions.\nPour nous aider, GeoServer propose de générer un SLD par défaut. Sélectionnez “Point” et cliquez sur “Générer…”. Vous devriez vous retrouver avec un fichier .xml décrivant la couche.\n\nOn pourrait aller lire en détail le SLD Cookbook de GeoServer pour écrire notre fichier manuellement, mais on est plus malins que ça. On a un super outil à disposition qui s’appelle QGIS.\n\nSi vous ne l’avez pas déjà fait, créez un projet QGIS et ajoutez les couches Land Matrix.\nDonnez un style sympa aux points de la couche deals. J’ai changé la couleur pour les rendre orange.\nAllez dans les propriétés de votre couche et dans “Symbologie”. Tout en bas, choisissez “Style” et “Enregistrer le style…”.\nChoisissez l’option “En tant que fichier SLD” et choisissez le chemin et le nom de votre fichier en cliquant sur “…” après “Fichier”. J’ai appelé le mien “deals.sld”\nAllez chercher votre fichier et ouvrez-le avec un éditeur de texte (Notepad, VSCode, peu importe).\nCopiez le contenu.\nRetournez sur votre page GeoServer, supprimez tout le contenu de la zone de texte et collez à la place le contenu de deals.sld. Voilà ce que ça donne pour moi :\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Deal&lt;/se:Name&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#ffd157&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;7&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\nVous pouvez prévisualiser la légende en cliquant sur “Aperçu de la légende”. Le bouton “Ajouter une légende” permet quand à lui d’ajouter une image customisée plutôt qu’une génération automatique. C’est pratique quand on a des légendes complexes, mais pas pour le moment. Ensuite, sauvegardez la légende quand elle vous convient.\n\n\n\n\n\n\nTip\n\n\n\nUne autre méthode pour charger le contenu d’un fichier de style .sld est de cliquer sur “Browse” en dessous de “Fichier de style”. Allez chercher votre fichier .sld et cliquez sur “Charger…” pour vous économiser quelques copier-coller par la suite !\n\n\nMaintenant, il faut dire à GeoServer qu’on veut utiliser ce style avec notre couche “deals”.\n\nAllez dans “Couches”.\nSélectionnez la couche “deals et allez dans l’onglet”Publication”.\nDans “Style par défaut”, sélectionnez “land_matrix:deals” et Sauvegardez.\n\nMaintenant, vous pouvez de nouveau prévisualiser la couche “deals” et voilà ! Nos points sont ronds et jaunes. Vous savez maintenant créer un nouveau style SLD depuis QGIS et l’ajouter à une couche dans GeoServer !\n\n\n\n\n\nNormalement, vous commencez à bien comprendre le fonctionnement de GeoServer et la publication des couches. Créez un style de couleur unique pour “deals_by_country” qu’on utilisera comme pseudo fond de carte. Ensuite, créez un style en cercles proportionnels pour “deals_by_country_centroid” en vous basant sur l’attribut “surface_ha”.\n\n\n\n\n\n\nAttention à la sémiologie\n\n\n\nJe ne veux pas voir de polygones “deals_by_country” de différentes couleurs. On n’utilise pas de carte choroplèthe pour représenter une valeur absolue, elles servent pour les valeurs relatives ou les catégories.\n\n\n\n\n\n\n\nUne fois que vous avez au moins ajouté votre style à “deals_by_country” dans GeoServer, vous pouvez passer à la suite. Si vous avez un train de retard, cliquez sur les boutons ci-dessous pour dérouler mes styles et les copier-coller dans votre GeoServer.\n\n\n\n\n\n\nSLD pour “deals_by_country”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals_by_country&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals_by_country&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Single symbol&lt;/se:Name&gt;\n          &lt;se:PolygonSymbolizer&gt;\n            &lt;se:Fill&gt;\n              &lt;se:SvgParameter name=\"fill\"&gt;#fdbf6f&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"fill-opacity\"&gt;0.35&lt;/se:SvgParameter&gt;\n            &lt;/se:Fill&gt;\n            &lt;se:Stroke&gt;\n              &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-width\"&gt;1&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-linejoin\"&gt;bevel&lt;/se:SvgParameter&gt;\n            &lt;/se:Stroke&gt;\n          &lt;/se:PolygonSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\n\n\n\n\nSLD pour “deals_by_country_centroid”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals_by_country_centroid&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals_by_country_centroid&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;201 - 5466&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;201 - 5466&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;200.81000000000000227&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThanOrEqualTo&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;4&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;5466 - 20413&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;5466 - 20413&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;10&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;20413 - 61376&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;20413 - 61376&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;16&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;61376 - 160220&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;61376 - 160220&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;22&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;160220 - 1509612&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;160220 - 1509612&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;1509612&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;29&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\nLire mes flux dans une autre application\nCourage, on touche au but. Vous aurez bientôt fait le tour du fonctionnement basique de GeoServer. Maintenant qu’on a nos couches, on veut pouvoir les lire.\nPour commencer, on va rapidement vérifier qu’on communique bien avec notre GeoServer en utilisant QGIS et la requête GetCapabilities du serveur. Cette requête, lorsqu’elle réussit, nous répond avec un fichier .xml qui explique à QGIS tout ce que le serveur est capable de faire, et notamment quelles couches peuvent être affichées.\n\nDans QGIS, cliquez sur “Ajouter une couche” et sélectionnez “WMS”.\nDans l’onglet “Couches”, cliquez sur “Nouveau”.\nAppelez la connexion “mon_geoserver” et collez l’url GetCapabilities dans “URL”. Elle devrait être identique à celle-ci :\n\nhttp://localhost/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetCapabilities\n\n\n\n\n\n\nÇa ne fonctionne pas !\n\n\n\n\n\nPour vérifier que votre requête est bonne, allez dans GeoServer, affichez n’importe quelle couche en prévisualisation et copiez l’adresse.\nhttp://localhost/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetMap&layers=land_matrix%3Adeals&bbox=-180.0%2C-90.0%2C180.0%2C90.0&width=768&height=384&srs=EPSG%3A4326&styles=&format=application/openlayers\nSupprimez tout ce qui se trouve après “request=” et ajoutez “GetCapabilities”.\nhttp://localhost/geoserver/land_matrix/wms?service=WMS&version=1.1.0&request=GetCapabilities\n\n\n\n\nCliquez ensuite sur “Connexion” et vérifiez qu’une liste de couche apparaît et qu’elle contient bien vos couches “deals”, etc.\n\nVous pouvez afficher la couche dans QGIS avec “Add” si vous le souhaitez. L’essentiel, c’est qu’on a vérifier que notre serveur émet bien des flux WMS pour nos couches et qu’on peut bien les lire. On va maintenant faire la même chose dans une application OpenLayers. Comme on n’a pas encore commencé les cours, je vous donne le code. Vous verrez, ça ressemble beaucoup à Leaflet. Dans le dossier de votre choix, créez un document index.html et collez le contenu suivant :\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;GeoServer + OpenLayers&lt;/title&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width\"&gt;\n\n        &lt;!-- CSS --&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/ol.css\" /&gt;\n        &lt;style&gt;\n        #map {\n            height: 500px;\n            width: 800px;\n        }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;GeoServer + OpenLayers&lt;/h1&gt;\n\n        &lt;div id=\"map\"&gt;&lt;/div&gt;\n\n        &lt;!-- OpenLayers JS--&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/dist/ol.js\"&gt;&lt;/script&gt;\n\n        &lt;!-- App code --&gt;\n        &lt;script&gt;\n            // OSM layer and source\n            var source_osm = new ol.source.OSM()\n            var layer_osm = new ol.layer.Tile({ source: source_osm })\n\n            // GeoServer layer and source\n\n            // Map\n            var map = new ol.Map({\n                target: 'map',\n                layers: [ layer_osm ],\n                view: new ol.View({\n                center: ol.proj.fromLonLat([2.1833, 41.3833]),\n                zoom: 2\n                })\n            });\n        &lt;/script&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\nDouble-cliquez sur index.html pour l’ouvrir dans le navigateur. Vous devriez voir apparaître une carte avec un fond OSM. On va ajouter nos couches GeoServer à cette carte.\n\n\n\n\n\nSous la section commentée “GeoServer Layer and source”, ajoutez les lignes suivantes :\nvar url_geoserver = 'http://localhost/geoserver/land_matrix/wms'\nvar source_geoserver = new ol.source.ImageWMS({\n    url: url_geoserver,\n    params: {'LAYERS': 'land_matrix:deals'},\n    serverType: 'geoserver',\n})\nvar layer_geoserver = new ol.layer.Image({ source: source_geoserver })\nEt ajoutez layer_geoserver à la liste de couches de map :\n// Map\nvar map = new ol.Map({\n    target: 'map',\n    layers: [ layer_osm, layer_geoserver ],\n    view: new ol.View({\n    center: ol.proj.fromLonLat([2.1833, 41.3833]),\n    zoom: 2\n    })\n});\nActualisez la carte. Vous devriez maintenant voir apparaître la couche “deals” de l’entrepôt “land_matrix” ! Décortiquons rapidement ces lignes de code.\nvar url_geoserver = 'http://localhost/geoserver/land_matrix/wms'\nOn récupère l’url de notre serveur. Si vous ne la trouvez pas, allez dans votre GeoServer et prévisualisez n’importe quelle couche. Récupérez l’url et coupez tout après “wms”. land_matrix est l’URI que nous avons donné à notre espace de travail (voir la section Espaces de travail du TP).\nvar source_geoserver = new ol.source.ImageWMS({\n    url: url_geoserver,\n    params: {'LAYERS': 'land_matrix:deals'},\n    serverType: 'geoserver',\n})\nOn crée ensuite une nouvelle source de données de type ImageWMS. On indique l’url de la source, à savoir l’url de notre espace de données GeoServer stocké dans la variable url_geoserver. L’image prend aussi un ou plusieurs paramètres. On indique dans ‘LAYERS’ la couche qu’on souhaite afficher. Celle ligne s’écrit toujours sous la forme :\n'LAYERS' : '&lt;entrepôt&gt;:&lt;couche&gt;'\nSi vous avez un doute, allez dans “Prévisualisation de la couche” et regardez le contenu de la colonne “Nom”. C’est la valeur à donner à ‘LAYERS’.\nEnfin, on renseigne le type du serveur, ici ‘geoserver’. Ce paramètre permet à OpenLayers de communiquer plus facilement avec GeoServer lorsque vous utiliserez des fonctionnalités plus avancées. De manière générale, cela vous permet aussi de vous souvenir du type de serveur avec lequel vous communiquez.\nChouette, après tout ça on a enfin réussi à créer, lire et afficher un flux WMS ! Sauf que, il manque encore quelque chose… la légende ! Et là vous me dites “pitié, j’en peux plus, j’ai la tête qui va exploser”. Allez, encore un petit effort. On a vu que GeoServer est capable de générer tout seul une légende, il nous suffit donc de la récupérer. Pour ça, rien de plus facile ! Le serveur distribue les images comme il distribue les couches de données. Il nous suffit de récupérer l’image en question et l’afficher dans une nouvelle &lt;div&gt; sur notre carte.\nOn reviendra en détail sur le fonctionnement des légendes dans le TP sur OpenLayers. Commencez par créer une &lt;div&gt; pour la légende sous &lt;div id=\"map\"&gt;&lt;/div&gt; :\n&lt;div id=\"map\"&gt;&lt;/div&gt;\n&lt;div&gt;&lt;img id=\"legend\" /&gt;&lt;/div&gt;\nNotre script permettra de modifier la source de l’image legend en interrogeant GeoServer à chaque fois qu’on fera changer la résolution de la carte. Dans le tag &lt;script&gt;, en dessous du code de la carte “Map”, ajoutez les lignes suivantes :\n&lt;!-- App code --&gt;\n&lt;script&gt;\n    //…\n\n    // Function to update the legend    \n    function updateLegend(resolution) {\n        const graphicUrl = source_geoserver.getLegendUrl(resolution, { 'LEGEND_OPTIONS' : 'forceLabels:on' });\n        const img = document.getElementById('legend');\n        img.src = graphicUrl;\n    };\n\n    // Initial legend\n    const resolution = map.getView().getResolution();\n    updateLegend(resolution);\n\n    // Update legend when resolution changes\n    map.getView().on('change:resolution', function (event) {\n        const resolution = event.target.getResolution();\n        updateLegend(resolution);\n    });\n\n&lt;/script&gt;\nEn résumé :\n\nLa fonction updateLegend() permet de récupérer l’url de la légende depuis notre source GeoServer source_geoserver en utilisant la méthode getLegendUrl(). On modifie ensuite la source de notre image &lt;img id=\"legend\" /&gt; sur l’url de la légende.\nLa fonction getLegendUrl() a besoin de connaître la résolution de la carte pour fonctionner.\nLorsque la carte est créée pour la première fois, on stocke sa résolution dans la variable resolution. La méthode getView() de l’objet map permet de récupérer la valeur de cette résolution. Ensuite, on exécute notre fonction updateLegend() pour récupérer la légende une première fois.\nPour mettre à jour la légende lorsque la résolution change, on écoute les évènements change:resolution de la map. À chaque fois que la résolution change, on va récupérer à nouveau cette résolution et exécuter la fonction updateLegend().\n\n\n\n\n\n\n\nCode complet de l’application\n\n\n\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;GeoServer + OpenLayers&lt;/title&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width\"&gt;\n\n        &lt;!-- CSS --&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/ol.css\" /&gt;\n        &lt;style&gt;\n        #map {\n            height: 500px;\n            width: 800px;\n        }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;GeoServer + OpenLayers&lt;/h1&gt;\n\n        &lt;div id=\"map\"&gt;&lt;/div&gt;\n        &lt;div&gt;&lt;img id=\"legend\" /&gt;&lt;/div&gt;\n\n        &lt;!-- OpenLayers JS--&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/dist/ol.js\"&gt;&lt;/script&gt;\n\n        &lt;!-- App code --&gt;\n        &lt;script&gt;\n            // OSM layer and source\n            var source_osm = new ol.source.OSM()\n            var layer_osm = new ol.layer.Tile({ source: source_osm })\n\n            // GeoServer layer and source\n            var url_geoserver = 'http://localhost/geoserver/land_matrix/wms'\n            var source_geoserver = new ol.source.ImageWMS({\n                url: url_geoserver,\n                params: {'LAYERS': 'land_matrix:deals'},\n                serverType: 'geoserver',\n            })\n            var layer_geoserver = new ol.layer.Image({ source: source_geoserver })\n\n            // Map\n            var map = new ol.Map({\n                target: 'map',\n                layers: [ layer_osm, layer_geoserver ],\n                view: new ol.View({\n                center: ol.proj.fromLonLat([2.1833, 41.3833]),\n                zoom: 2\n                })\n            });\n\n            // Function to update the legend    \n            function updateLegend(resolution) {\n                const graphicUrl = source_geoserver.getLegendUrl(resolution, { 'LEGEND_OPTIONS' : 'forceLabels:on' });\n                const img = document.getElementById('legend');\n                img.src = graphicUrl;\n            };\n\n            // Initial legend\n            const resolution = map.getView().getResolution();\n            updateLegend(resolution);\n\n            // Update legend when resolution changes\n            map.getView().on('change:resolution', function (event) {\n                const resolution = event.target.getResolution();\n                updateLegend(resolution);\n            });\n\n        &lt;/script&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;\n\n\n\nOuf ! On a enfin une légende. Pour ceux qui ont encore le temps et l’énergie, je vous propose d’afficher les autres couches et leur légende sur la carte, au moins “deals_by_country_centroids” pour avoir nos cercles proportionnels. C’est parti !",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#conclusions",
    "href": "cours/geonum/serveurs_carto.html#conclusions",
    "title": "Serveurs cartographiques",
    "section": "Conclusion(s)",
    "text": "Conclusion(s)\n\nC’est quoi l’intérêt du serveur carto, déjà ?\n\nCentralisation de la donnée et mise à jour\nDistribution de la donnée\nGestion des droits\nBien quand on a une organisation et bcp de données, s’intègre très bien dans une IDG\nBien pour les couches Raster et les couches Vecteur lourdes qui peuvent être servies en tant qu’images (WMS)\nConnexion directe à une base de données PostgreSQL\nPossibilité d’écrire des requêtes SQL pour former les couches\nPossibilité de créer des styles complexes “à la QGIS”.\n\nEst-ce que j’en ai besoin pour mon projet GeoNum ?\n\nÇa dépend des données que vous utilisez et ce que vous en faites. Le mieux c’est d’en discuter avec les profs !\n\nJe n’utilise pas de connexion à une base de données, je préfère juste afficher des couches avec un style complexe. Ce serait pas plus simple si on pouvait directement importer les couches d’un projet QGIS ?",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/serveurs_carto.html#tp---qgis-server-avec-lizmap",
    "href": "cours/geonum/serveurs_carto.html#tp---qgis-server-avec-lizmap",
    "title": "Serveurs cartographiques",
    "section": "TP - QGIS Server avec LizMap",
    "text": "TP - QGIS Server avec LizMap\nEn cours de rédaction, revenez plus tard !",
    "crumbs": [
      "Serveurs cartographiques"
    ]
  },
  {
    "objectID": "cours/geonum/evaluation.html",
    "href": "cours/geonum/evaluation.html",
    "title": "Évaluation",
    "section": "",
    "text": "Commentaires dans le code\nIntendation du code\nPas de fautes dans le texte (surtout qu’il y en a vraiment très peu !)\nOn ajoute un peu de CSS, on essaie de ne pas juste faire le minimum vital"
  },
  {
    "objectID": "cours/geonum/evaluation.html#memo",
    "href": "cours/geonum/evaluation.html#memo",
    "title": "Évaluation",
    "section": "",
    "text": "Commentaires dans le code\nIntendation du code\nPas de fautes dans le texte (surtout qu’il y en a vraiment très peu !)\nOn ajoute un peu de CSS, on essaie de ne pas juste faire le minimum vital"
  },
  {
    "objectID": "cours/geonum/evaluation.html#ce-qui-est-demandé",
    "href": "cours/geonum/evaluation.html#ce-qui-est-demandé",
    "title": "Évaluation",
    "section": "Ce qui est demandé",
    "text": "Ce qui est demandé\n…"
  },
  {
    "objectID": "cours/geonum/evaluation.html#points-bonus",
    "href": "cours/geonum/evaluation.html#points-bonus",
    "title": "Évaluation",
    "section": "Points bonus",
    "text": "Points bonus\n…"
  },
  {
    "objectID": "cours/geonum/introduction.html",
    "href": "cours/geonum/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Slides : Introduction",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#intervenante",
    "href": "cours/geonum/slides_introduction.html#intervenante",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Intervenante",
    "text": "Intervenante\nMarie Gradeler\n⛰️ Licence de Géologie\n🤠 Master d’Archéologie du Paysage (SIG, télédec, stats)\n🤷 Pas de sous en archéo donc galère de trouver du travail\n🗺️ Master GeoNum (arrivée en M2)\n💻 Stage AgroParisTech dans le cadre du Master : développement d’une appli de cartographie web\n💻 Contrat de 6 mois au CIRAD pour terminer la production de l’appli carto du stage\n💻 Depuis, je travaille comme consultante IFAD sur le project Land Matrix (création d’indicateurs, stats avec R, beaucoup de dataviz et développement Web)"
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#les-cours",
    "href": "cours/geonum/slides_introduction.html#les-cours",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Les cours",
    "text": "Les cours\n\nJeudi 21 Nov : 9h - 12h\nMercredi 27 Nov : 9h - 12h\nJeudi 28 Nov : 9h - 12h\nJeudi 28 Nov : 13h30 - 16h30\n\nOn va beaucoup travailler sur les serveurs cartographiques, notamment GeoServer, mais aussi sur la librairie de cartographie OpenLayers. Cela va nous demander de savoir écrire du code en JavaScript, d’être capable d’exécuter une ou deux lignes de commandes en Bash et de comprendre l’architecture client-serveur du web.\nJe vous recommande d’être bien attentifs aux cours de Leaflet (entre autres) qui sont complémentaires de celui-ci. Si vous connaissez Leaflet, vous connaissez presque déjà OpenLayers."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#les-ressources",
    "href": "cours/geonum/slides_introduction.html#les-ressources",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Les ressources",
    "text": "Les ressources\n💻 Mon site internet : https://gradelerm.github.io\nIl est en cours de construction mais suffit déjà à héberger les ressources pour le cours. Vous y trouverez tout le reste !\nMoi : marie.gradeler@gmail.com\nN’hésitez pas à me contacter. Mes cours sont condensés sur 2 semaines. Si quelque chose ne va pas, je dois le savoir dès la première séance. Je serai aussi disponible pour vous accompagner durant les projets GeoNum si vous avez besoin d’aide sur l’une des notions abordées en cours."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#comment-ça-se-passe",
    "href": "cours/geonum/slides_introduction.html#comment-ça-se-passe",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Comment ça se passe",
    "text": "Comment ça se passe\nOrganisation des cours\n\nPas mal de mise en pratique\nOn m’appelle si on est perdu, je suis là pour vous aider (ne me laissez pas faire mon cours dans le vide parce que vous avez abandonné tout espoir de raccrocher les wagons, ça ne sert à rien)\nSi on doit ralentir parce que j’ai trop prévu de choses techniques, on ralentit et puis c’est tout, j’adapterai l’évaluation à ce qu’on a eu le temps de voir en cours\nPas d’IA pour écrire le code ! Je donne généralement les corrigés dans le TP, vous n’en aurez même pas besoin. Pour apprendre, le mieux, c’est de faire soi-même, et ça ne m’intéresse pas trop de venir faire cours à Chat-GPT ou Gemini de toute façon.\nJe sais que c’est difficile mais on lâche son téléphone pendant le cours (ou cet onglet mal planqué) et on se concentre sur le cours. WhatsApp et les ouvertures de boosters attendront la pause café."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#évaluation",
    "href": "cours/geonum/slides_introduction.html#évaluation",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "Évaluation",
    "text": "Évaluation\nProjet à rendre basé sur une petite architecture web que je vous fournirai (et qui pourrait éventuellement servir de base pour une archi de projet GeoNum, je dis ça je dis rien…). Dans les grandes lignes, ce qui vous sera demandé :\n🛠️ Publication de couches sur un GeoServer\n🗺️ Lecture des flux WMS sur une petite appli OpenLayers\n💻 Déploiement (rudimentaire) de votre serveur GeoServer + application OpenLayers en s’appuyant sur l’architecture web fournie\nJe vais recalibrer l’évaluation suivant la vitesse à laquelle on avance et le niveau moyen de la promo en dev. Du coup, vous aurez les consignes pendant le dernier cours."
  },
  {
    "objectID": "cours/geonum/slides_introduction.html#cest-parti",
    "href": "cours/geonum/slides_introduction.html#cest-parti",
    "title": "Formation WebCarto GeoNum 2024-2025",
    "section": "C’est parti !",
    "text": "C’est parti !\nPrêts à encore entendre parler de serveurs, clients, requêtes, variables et fonctions ?\n\n\n\n\n\nCourage. Promis, ça va nous permettre de faire des trucs cools qui seront très utiles pour les projets GeoNum et si vous faites de la webcarto ou des IDGs plus tard.\n\n\n\n\nFormation WebCarto GeoNum 2024 -2025"
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html",
    "href": "cours/geonum/openlayers_geoserver.html",
    "title": "OpenLayers & GeoServer",
    "section": "",
    "text": "Savoir ce que sont Node JS, OpenLayers et Docker.\nComprendre la différence entre une machine virtuelle et un container.\nDéployer une stack de développement avec un serveur GeoServer et un serveur Caddy pour servir une application sous Node JS en utilisant Docker Compose.\nCréer une application OpenLayers avec Node JS.\nComprendre le contenu de l’application de base de OpenLayers et où doit vivre mon code.\nApprendre à utiliser la documentation et les exemples d’OpenLayers pour ajouter des éléments à ma carte.\nAfficher des couches WMS dans une application OpenLayers.",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#objectifs",
    "href": "cours/geonum/openlayers_geoserver.html#objectifs",
    "title": "OpenLayers & GeoServer",
    "section": "",
    "text": "Savoir ce que sont Node JS, OpenLayers et Docker.\nComprendre la différence entre une machine virtuelle et un container.\nDéployer une stack de développement avec un serveur GeoServer et un serveur Caddy pour servir une application sous Node JS en utilisant Docker Compose.\nCréer une application OpenLayers avec Node JS.\nComprendre le contenu de l’application de base de OpenLayers et où doit vivre mon code.\nApprendre à utiliser la documentation et les exemples d’OpenLayers pour ajouter des éléments à ma carte.\nAfficher des couches WMS dans une application OpenLayers.",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#cours---le-point-technique",
    "href": "cours/geonum/openlayers_geoserver.html#cours---le-point-technique",
    "title": "OpenLayers & GeoServer",
    "section": "Cours - Le point technique",
    "text": "Cours - Le point technique\nSlides : Le point technique",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#tp---démarrage-de-la-stack",
    "href": "cours/geonum/openlayers_geoserver.html#tp---démarrage-de-la-stack",
    "title": "OpenLayers & GeoServer",
    "section": "TP - Démarrage de la stack",
    "text": "TP - Démarrage de la stack\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nCe TP suppose que Docker et Docker Compose sont installés sur la machine. Il a été écrit pour une machine Linux, certains chemins et lignes de commande peuvent donc être différents sur une machine Windows ou Mac.\nL’éditeur de code utilisé pour l’écriture de ce TP est VSCode mais n’importe quel autre éditeur fait l’affaire.\n\n\n\nInitialiser mon dossier\nCommencez par créer un nouveau dossier dans lequel nous allons développer notre app. Vous pouvez le mettre où vous voulez - par exemple dans Mes Documents. J’ai appelé mon dossier app_openlayers_geoserver mais le nom importe peu.\nOuvez-ce dossier dans VSCode (par exemple avec un clic-droit &gt; Ouvrir avec VSCode). Vous vous trouvez à la racine du dossier. Pour la suite du TP, à chaque fois que j’évoquerais la racine du projet, il s’agita de ce dossier.\nCréez un nouveau fichier et appelez-le README.md. Il s’agit d’un simple fichier texte au format markdown qui nous servira de mémo. L’application pourrait tout à fait fonctionner sans.\nCopiez dans README.md le texte suivant et sauvegardez le document :\nPour démarrer les containers :\n`docker compose up -d`\n\nPour arrêter les containers :\n`docker compose down`\nSi jamais vous oubliez les commandes pour utiliser docker compose, vous pourrez les retrouver dans ce fichier.\nEnsuite, toujours à la racine du projet, créer un nouveau fichier et appelez-le Caddyfile (la majuscule est importante !). Collez le contenu suivant à l’intérieur et sauvegardez.\n:80 {\n    root * /srv\n    file_server\n}\n\n\n\n\n\n\nC’est quoi, ce Caddyfile ?\n\n\n\n\n\nIl s’agit du fichier de configuration du serveur Caddy que nous allons utiliser pour servir notre application OpenLayers. On aurait pu choisir d’utiliser Apache ou Nginx, mais j’aime bien Caddy, je le trouve plus clair à prendre en main.\nOn lui indique simplement trois éléments :\n\nOn sert notre application sur le port 80 (le localhost par défaut). Il faudra donc aller sur localhost pour voir notre application OpenLayers.\nCaddy doit chercher les fichiers de notre site web dans le dossier /srv (configuration par défaut).\nCaddy sait qu’on va utiliser des fichiers statiques.\n\n\n\n\n\n\nCréer (et comprendre) mon docker-compose.yml\nNormalement, si vous avez bien suivi les étapes précédentes, le contenu de votre dossier devrait ressembler à ça :\n- Caddyfile\n- README.md\nÀ la racine du projet, créez un nouveau fichier et appelez-le docker-compose.yml. Collez le contenu suivant dans ce fichier et sauvegardez.\nservices:\n\n  geoserver:\n    container_name: geonum_geoserver\n    image: docker.osgeo.org/geoserver:2.26.0\n    environment:\n      - RUN_UNPRIVILEGED=true\n      - CHANGE_OWNERSHIP_ON_FOLDERS=\"/opt /opt/geoserver_data/ /mnt/geoserver_geodata\"\n      - CORS_ENABLED=true\n      - SKIP_DEMO_DATA=true\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - ./geoserver/opt:/opt/geoserver_data\n  \n  web:\n    container_name: geonum_web\n    image: caddy:latest\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./Caddyfile:/etc/caddy/Caddyfile\n      - ./app/dist/:/srv\n\n\n\n\n\n\nEt ça, ça veut dire quoi ?\n\n\n\n\n\nSi tout s’est bien passé, on a déjà vu ensemble comment fonctionne le docker-compose.yml en cours, mais voici un petit rappel :\n\non crée deux “services”, qui sont en fait deux containers, un geoserver et un web .\npour chaque service, on indique :\n\nle nom qu’on donne au container (pour éviter les noms générés aléatoirement comme lors du précédent TP, qui ne sont pas super clairs)\nle nom de l’image Docker (pour rappel, image = recette pour construire un container) qu’on souhaite utiliser\nles ports qu’on souhaite connecter, sous la forme HOST_PORT:CONTAINER_PORT . Exemple pour GeoServer : je sais qu’il est toujours servi sur le port 8080, donc si j’écris 3000:8080, ça veut dire que sur mon ordinateur je dois aller sur localhost:3000 pour pouvoir regarder le port 8080 de mon container et voir mon GeoServer.\nSi ce n’est pas clair et que ça vous travaille de comprendre comment ça fonctionne, on m’appelle !\ndes volumes dans lesquels on stocke de la donnée, ici on va connecter les volumes docker à des dossier dans notre ordinateur (comme au TP précédent) en utilisant la syntaxe HOST_DIRECTORY:CONTAINER_DIRECTORY . Pour reprendre l’exemple de GeoServer, je sais que par défaut la donnée est stockée dans /opt/geoserver_data/ dans le serveur. Je dis donc à mon container de se connecter à un dossier sur ma machine dans $PWD/geoserver/opt , un dossier qui sera créé au premier lancement de la stack. Comme on l’a expérimenté au TP précédent, monter des volumes depuis les containers sur mon ordinateur est le moyen le plus simple d’y transférer de la donnée. Ce n’est pas toujours aussi simple d’accéder à l’intérieur d’un serveur - c’est toute la puissance de Docker, et c’est pour ça qu’on s’en sert !\n\n\nCe n’est encore pas super clair ? Attendez de commencer à manipuler le TP, ça viendra tout seul. Si c’est toujours flou au bout de quelques exercices, appelez-moi et on refait une explication !\n\n\n\n\n\nInitialiser mon application OpenLayers\nDocumentation OpenLayers\nAvant de pouvoir lancer tous nos services, on doit encore créer notre application OpenLayers. Ouvrez un terminal à la racine du projet. Vous avez deux options :\n\nla simple : ouvrez un Terminal dans votre editeur de Code (par exemple, dans VSCode, allez dans le menu en haut et cliquez sur “Terminal”)\nla moins simple : ouvez un terminal et déplacez-vous jusqu’à votre projet en utilisant la commande cd /chemin/de/mon/projet\n\nUne fois que le terminal est ouvert dans le projet (vérifiez bien deux fois !), tapez la commande suivante pour créer un projet OpenLayers qu’on appelle “app” :\nnpm create ol-app app\n\n\n\n\n\n\nJ’ai un message d’erreur “could not find commit hash for HEAD”\n\n\n\n\n\nCela doit vouloir dire que git n’est pas installé sur la machine. Pour savoir comment installer Git pour Linux, Windows et MacOS, rendez-vous sur le site officiel de Git : https://git-scm.com/book/en/v2/Getting-Started-Installing-Git\nPour gagner du temps, voilà la page pour Windows : https://git-scm.com/downloads/win\nQuand git est installé, recommencez l’étape précédente. Si ça ne fonctionne toujours pas, essayez de :\n\nfermer et ouvrir de nouveau VS Code\nredémarrer l’ordinateur\n\nPour moi ça a fonctionné dans la salle de TP 🤞\n\n\n\nVous devriez voir un nouveau dossier appelé “app”. Tapez la commande suivante pour vous “déplacer” dans le dossier “app”.\ncd app\nOn va démarrer notre application avec la commande suivante :\nnpm start\nVous devriez avoir quelque chose comme ça dans votre terminal :\n  VITE v5.4.11  ready in 137 ms\n\n  ➜  Local:   http://localhost:5173/\n  ➜  Network: use --host to expose\n  ➜  press h + enter to show help\nSuper, le serveur de développement de l’application fonctionne ! On va pouvoir y accéder en entrant dans le navigateur l’adresse indiquée dans Local. Allez-y et vérifiez que vous voyez bien une carte.\n\n\n\n\n\n\nUn serveur de développement ?\n\n\n\n\n\nComme on l’a vu en cours, l’un des intérêts de Node JS est qu’il permet d’avoir un serveur de développement pour servir notre application facilement et la mettre à jour au fur et à mesure des changements. Pour lancer ce serveur de développement, on utilise la commande npm start depuis le dossier app.\nPar contre, c’est un serveur de développement et non pas de production. On apprendra donc pendant le dernier cours à mettre en production une application - ce sera dans le rendu de votre évaluation, mais pas de pression 😈\n\n\n\nSi vous voyez bien une carte, il ne reste que deux toutes petites étapes et on va enfin pouvoir passer à la suite.\nD’abord, quittez le serveur de développement (ctrl + c dans le terminal). Tapez ensuite la commande suivante :\nnpm run build\nNode JS va créer un build, une version pour la production de notre site. C’est ce build qui va être servi par notre fameux serveur Caddy qu’on a vu dans le docker-compose.yml. Les fichiers de cette application se trouvent dans le dossier ./app/dist/.\nPour vérifier que tout a fonctionné, tapez les commandes suivantes dans votre terminal :\ncd ..\ndocker compose up\nLa première commande permet de retourner à la racine du projet. La seconde demande à Docker de créer nos containers à partir des instructions de docker-compose.yml. Le démarrage peut prendre un peu de temps, profitez-en pour vous reposer un peu le cerveau.\nQuand c’est terminé, le contenu de votre projet devrait ressembler à ça :\n- app/\n- geoserver/\n- Caddyfile\n- docker-compose.yml\n- README.md\nSi c’est le cas, il reste une dernière chose à vérifier.\n\nallez sur http://localhost/ et confirmez que vous voyez bien une carte\nallez sur http://localhost:8080/geoserver/ et confirmez que vous voyez bien une interface de GeoServer\n\nSi tout est OK, félicitations ! Vous venez de créer une stack avec un serveur pour votre application en Node JS et un GeoServer.",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#cours---les-bases-dopenlayers",
    "href": "cours/geonum/openlayers_geoserver.html#cours---les-bases-dopenlayers",
    "title": "OpenLayers & GeoServer",
    "section": "Cours - Les bases d’OpenLayers",
    "text": "Cours - Les bases d’OpenLayers\nSlides : Les bases d’OpenLayers",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#tp---cartographie-web-avec-geoserver-et-openlayers",
    "href": "cours/geonum/openlayers_geoserver.html#tp---cartographie-web-avec-geoserver-et-openlayers",
    "title": "OpenLayers & GeoServer",
    "section": "TP - Cartographie web avec GeoServer et OpenLayers",
    "text": "TP - Cartographie web avec GeoServer et OpenLayers\n\nImporter la couche de l’exemple OpenLayers\nEn vous basant sur l’exemple OpenLayers “Single Image WMS”, importez la couche de cet exemple dans votre application.\n\n\n\n\n\n\nRappels pour démarrer mon application\n\n\n\n\n\n\nOuvrir le fichier du projet (si vous avez suivi le premier TP il devrait s’appeler app_openlayers_geoserver) dans votre éditeur de code, par exemple VS Code\nOuvrir un terminal et taper cd app pour vous déplacer dans le dossier de votre application\nTapez npm start pour démarrer le serveur de développement\nOuvrez le localhost indiqué dans votre terminal pour voir votre application\n\n\n\n\nEssayez un peu par vous-même avant de simplement copier-coller ma solution depuis les diapos ! N’oubliez pas que tant que votre code fonctionne, c’est bon. Il n’y a pas une seule et unique manière d’écrire votre application. Souvent, dans mes solutions, je vais écrire du code un peu plus long que la moyenne pour bien décortiquer ce qu’on fait avec OpenLayers. Plus on va avancer dans les TPs et plus vous devrez comparer votre code au mien plutôt que copier-coller (on ne va sûrement pas appeler toutes les variables pareil).\n\n\n\n\n\n\nMa solution (code montré dans les diapos)\n\n\n\n\n\nimport './style.css';\nimport {Map, View} from 'ol';\nimport { ImageWMS } from 'ol/source';\nimport TileLayer from 'ol/layer/Tile';\nimport ImageLayer from 'ol/layer/Image';\nimport OSM from 'ol/source/OSM';\n\n// Je sors la couche OSM de l’objet Map pour la stocker dans une variable\nconst couche_osm = new TileLayer({ source: new OSM() });\n\n// Création de la source et la couche\nconst ma_source = new ImageWMS({\n  url: 'https://ahocevar.com/geoserver/wms',\n  params: { 'LAYERS' : 'topp:states' },\n  serverType: 'geoserver',\n});\n\nconst ma_couche = new ImageLayer({\n  source: ma_source,\n});\n\n// Création de l’objet map avec appel de mes deux couches \"couche_osm\" et \"ma_couche\" dans layers\nconst map = new Map({\n  target: 'map',\n  layers: [ couche_osm, ma_couche ],\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\n\n\nMaintenant, modifiez le code pour créer directement ma_couche sans passer par une source ma_source. Pour rappel, voici le morceau de code que j’avais mis dans mes diapos :\nconst ma_couche = new ImageLayer({\n  source: new ImageWMS({\n    url: '&lt;lien_vers_mon_serveur&gt;',\n    params: {'LAYERS': '&lt;espace&gt;:&lt;couche&gt;'},\n    serverType: 'geoserver',\n  }),\n});\n\n\n\n\n\n\nTip\n\n\n\nAttention à la différence entre les virgules et les points-virgules !\n\n\nPour cet exercice, pas de solution, ça devrait couler de source. Si vous bloquez, appelez-moi ! Je le dis et le re-dis, mais on ne reste pas dans son coin à s’arracher les cheveux. C’est contre productif et en plus si on ne me demande pas de l’aide je sers juste à tourner en rond dans la salle. C’est un peu ennuyeux.\nQuand ça fonctionne, on passe à la suite !\n\n\nImporter une couche depuis mon GeoServer\nCommencez par vérifier que vos containers Docker tournent toujours. Pour ça, rendez-vous sur http://localhost:8080/geoserver/ et vérifiez que vous voyez bien l’interface de GeoServer. Sinon, démarrez la stack depuis Docker Desktop ou bien ouvrez un terminal à la racine de votre projet et tapez docker compose up.\nOn souhaite maintenant ajouter une couche OpenLayers depuis notre GeoServer.\nVous avez une impression de déjà-vu ? Normal ! Si vous avez bien suivi le TP précédent, ce sera un jeu d’enfant pour vous. Si vous voulez retourner au TP pour être guidés parce que vous avez un trou de mémoire, c’est par ici. Pour vous aider, je vous remets ici quelques éléments :\n\nLe jeu de données land_matrix_mines à télécharger\nLe fichier de style SLD des couches à copier ci-dessous (vous n’êtes pas obligés d’utiliser ceux-ci !)\n\n\n\n\n\n\n\nSLD pour “deals”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Deal&lt;/se:Name&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#ffd157&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;7&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\n\n\n\n\nSLD pour “deals_by_country”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals_by_country&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals_by_country&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;Single symbol&lt;/se:Name&gt;\n          &lt;se:PolygonSymbolizer&gt;\n            &lt;se:Fill&gt;\n              &lt;se:SvgParameter name=\"fill\"&gt;#fdbf6f&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"fill-opacity\"&gt;0.35&lt;/se:SvgParameter&gt;\n            &lt;/se:Fill&gt;\n            &lt;se:Stroke&gt;\n              &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-width\"&gt;1&lt;/se:SvgParameter&gt;\n              &lt;se:SvgParameter name=\"stroke-linejoin\"&gt;bevel&lt;/se:SvgParameter&gt;\n            &lt;/se:Stroke&gt;\n          &lt;/se:PolygonSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\n\n\n\n\n\n\nSLD pour “deals_by_country_centroid”\n\n\n\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:se=\"http://www.opengis.net/se\" xmlns:ogc=\"http://www.opengis.net/ogc\" xsi:schemaLocation=\"http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1.0\"&gt;\n  &lt;NamedLayer&gt;\n    &lt;se:Name&gt;gpkg_land_matrix — deals_by_country_centroid&lt;/se:Name&gt;\n    &lt;UserStyle&gt;\n      &lt;se:Name&gt;gpkg_land_matrix — deals_by_country_centroid&lt;/se:Name&gt;\n      &lt;se:FeatureTypeStyle&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;201 - 5466&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;201 - 5466&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;200.81000000000000227&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThanOrEqualTo&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;4&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;5466 - 20413&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;5466 - 20413&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;5466.3999999999996362&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;10&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;20413 - 61376&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;20413 - 61376&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;20412.80000000001018634&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;16&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;61376 - 160220&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;61376 - 160220&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;61375.88199999996868428&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;22&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n        &lt;se:Rule&gt;\n          &lt;se:Name&gt;160220 - 1509612&lt;/se:Name&gt;\n          &lt;se:Description&gt;\n            &lt;se:Title&gt;160220 - 1509612&lt;/se:Title&gt;\n          &lt;/se:Description&gt;\n          &lt;ogc:Filter xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n            &lt;ogc:And&gt;\n              &lt;ogc:PropertyIsGreaterThan&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;160220.00000000005820766&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsGreaterThan&gt;\n              &lt;ogc:PropertyIsLessThanOrEqualTo&gt;\n                &lt;ogc:PropertyName&gt;suface_ha&lt;/ogc:PropertyName&gt;\n                &lt;ogc:Literal&gt;1509612&lt;/ogc:Literal&gt;\n              &lt;/ogc:PropertyIsLessThanOrEqualTo&gt;\n            &lt;/ogc:And&gt;\n          &lt;/ogc:Filter&gt;\n          &lt;se:PointSymbolizer&gt;\n            &lt;se:Graphic&gt;\n              &lt;se:Mark&gt;\n                &lt;se:WellKnownName&gt;circle&lt;/se:WellKnownName&gt;\n                &lt;se:Fill&gt;\n                  &lt;se:SvgParameter name=\"fill\"&gt;#e5b636&lt;/se:SvgParameter&gt;\n                &lt;/se:Fill&gt;\n                &lt;se:Stroke&gt;\n                  &lt;se:SvgParameter name=\"stroke\"&gt;#232323&lt;/se:SvgParameter&gt;\n                  &lt;se:SvgParameter name=\"stroke-width\"&gt;0.5&lt;/se:SvgParameter&gt;\n                &lt;/se:Stroke&gt;\n              &lt;/se:Mark&gt;\n              &lt;se:Size&gt;29&lt;/se:Size&gt;\n            &lt;/se:Graphic&gt;\n          &lt;/se:PointSymbolizer&gt;\n        &lt;/se:Rule&gt;\n      &lt;/se:FeatureTypeStyle&gt;\n    &lt;/UserStyle&gt;\n  &lt;/NamedLayer&gt;\n&lt;/StyledLayerDescriptor&gt;\n\n\n\nUne fois que vos couches sont (à nouveau) importées dans votre GeoServer et que vous parvenez à les visualiser correctement, importez la couche “deals” dans votre application OpenLayers. Il doit s’agir d’une nouvelle couche : ne remplacez pas celle de l’exemple que nous venons d’afficher ! En utilisant le TP précédent et ce qu’on vient de voir, vous ne devriez pas avoir trop de difficultés.\nPour rappel, vous pouvez ouvrir l’outil de développement de votre navigateur avec la touche F12 et vous verrez les messages d’erreur dans l’onglet Console. C’est eux qui vous diront ce qui ne va pas dans le code !\nAu besoin, vous pouvez utiliser une fusée de détresse, mais comme pour les vraies, c’est mieux de les allumer quand on en a besoin et pas juste parce qu’on est curieux.\n\n\n\n\n\n\nFusée de détresse : comment trouver l’url qui pointe vers mon service wms ?\n\n\n\n\n\n\n\n\n\n\n\nPrévisualisez votre couche dans GeoServer\nCopiez l’URL qui est dans la barre de votre navigateur\nSupprimez tout ce qui est après le “?” et votre URL devrait se terminer par “wms”, par exemple : “http://localhost/geoserver/land_matrix/wms”\n\n\n\n\n\n\n\n\n\n\nFusée de détresse : comment trouver le nom de mon espace et de ma couche ?\n\n\n\n\n\n\n\n\n\n\n\nAllez dans “Couches” ou “Prévisualisation de la couche” dans GeoServer\nTrouvez votre couche dans la liste et regardez la colonne “Nom”\nLa première partie du nom (avant les “:”) correspond à l’espace et la seconde partie au nom de la couche, par exemple : “land_matrix:deals”\n\n\n\n\n\n\n\n\n\n\nFusée de détresse : J’ai créé ma couche mais elle n’apparaît pas sur la carte\n\n\n\n\n\n\n\n\n\n\nVous pensez avoir bien créé votre source ImageWMS et votre couche ImageLayer mais il n’y a rien sur la carte et pas de message d’erreur ?\nVérifiez que vous avez bien ajouté votre couche dans la propriété layers: de votre objet map ! Pour rappel, pour ajouter un élément à un tableau (“array”) en JavaScript, il faut séparer ces éléments par des virgules.\n\n\n\nSi vous avez atteint cette ligne, bravo ! Si vous coincez, appelez-moi. Il faudrait que tout le monde parvienne à atteindre au moins cette étape avant la fin du TP.\nS’il après ça vous reste un peu de temps, ajoutez les couches “deals_by_country” et “deals_by_country_centroid” à la carte.\n\n\nJe suis en avance !\nPas de panique, on n’a pas le temps de s’ennuyer ici ! On va faire un peu de HTML et de CSS. Trouvez comment gagner de l’espace en haut de la page web pour ajouter un titre (avec la balise &lt;h1&gt;) et donnez un joli nom à votre page !\nSi vous avez encore un peu de temps, expérimentez avec le style de la carte. Vous pouvez arrondir les coins, changer la police du titre, ou pourquoi pas commencer à dégager une zone pour mettre la légende et les options d’affichage des couches.\nVous pourriez aussi relire votre code JavaScript. Est-ce que certaines informations se répètent, est-ce que vous pourriez les mettre dans des variables ?",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "cours/geonum/openlayers_geoserver.html#cest-fini-pour-aujourdhui",
    "href": "cours/geonum/openlayers_geoserver.html#cest-fini-pour-aujourdhui",
    "title": "OpenLayers & GeoServer",
    "section": "C’est fini pour aujourd’hui !",
    "text": "C’est fini pour aujourd’hui !\nMerci à vous d’avoir tenu le coup, je sais que c’était dense. Pendant les deux premiers cours, on a appris tout ce qu’il nous fallait pour les prochaines séances. Maintenant, adieu la théorie, on va pouvoir passer à la pratique et ENFIN pouvoir enrichir notre super carte interactive !",
    "crumbs": [
      "OpenLayers & GeoServer"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Accueil",
    "section": "",
    "text": "Bienvenue sur mon site en cours de construction. Si vous avez trouvé cette page, vous êtes sûrement un étudiant en master GeoNum. Les ressources pour les TD, c’est par ici !"
  }
]